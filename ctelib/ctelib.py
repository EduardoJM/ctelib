#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu May 19 15:56:31 2022 by generateDS.py version 2.40.13.
# Python 3.8.10 (default, Mar 15 2022, 12:22:08)  [GCC 9.4.0]
#
# Command line options:
#   ('-o', 'ctelib/ctelib.py')
#
# Command line arguments:
#   ./schemas/v300/cte_v3.00.xsd
#
# Command line:
#   /home/eduardo/Documentos/Repos/Contrib/ctelib/.venv/bin/generateDS -o "ctelib/ctelib.py" ./schemas/v300/cte_v3.00.xsd
#
# Current working directory (os.getcwd()):
#   ctelib
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % float(input_data)).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class CSTType(str, Enum):
    """CSTType -- classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    00 - tributa
    ç
    ã
    o normal ICMS
    
    """
    _0_0='00'


class CSTType190(str, Enum):
    """CSTType190 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do servi
    ç
    o
    20 - tributa
    ç
    ã
    o com BC reduzida do ICMS
    
    """
    _2_0='20'


class CSTType191(str, Enum):
    """CSTType191 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    Preencher com:
    40 - ICMS isen
    ç
    ã
    o;
    41 - ICMS n
    ã
    o tributada;
    51 - ICMS diferido
    
    """
    _4_0='40'
    _4_1='41'
    _5_1='51'


class CSTType192(str, Enum):
    """CSTType192 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    60 - ICMS cobrado por substitui
    ç
    ã
    o tribut
    á
    ria
    
    """
    _6_0='60'


class CSTType193(str, Enum):
    """CSTType193 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS outros
    
    """
    _9_0='90'


class CSTType194(str, Enum):
    """CSTType194 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS Outra UF
    
    """
    _9_0='90'


class CSTType195(str, Enum):
    """CSTType195 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS Simples Nacional
    
    """
    _9_0='90'


class CSTType197(str, Enum):
    """CSTType197 -- classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    00 - tributa
    ç
    ã
    o normal ICMS
    
    """
    _0_0='00'


class CSTType199(str, Enum):
    """CSTType199 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do servi
    ç
    o
    20 - tributa
    ç
    ã
    o com BC reduzida do ICMS
    
    """
    _2_0='20'


class CSTType201(str, Enum):
    """CSTType201 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    Preencher com:
    40 - ICMS isen
    ç
    ã
    o;
    41 - ICMS n
    ã
    o tributada;
    51 - ICMS diferido
    
    """
    _4_0='40'
    _4_1='41'
    _5_1='51'


class CSTType203(str, Enum):
    """CSTType203 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - Outros
    
    """
    _9_0='90'


class CSTType205(str, Enum):
    """CSTType205 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS Outra UF
    
    """
    _9_0='90'


class CSTType207(str, Enum):
    """CSTType207 -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS Simples Nacional
    
    """
    _9_0='90'


class TAmb(str, Enum):
    """TAmb -- Tipo Ambiente
    
    """
    _1='1'
    _2='2'


class TCListServ(str, Enum):
    """TCListServ -- Tipo C
    ó
    digo da Lista de Servi
    ç
    os LC 116/2003
    
    """
    _1_01='101'
    _1_02='102'
    _1_03='103'
    _1_04='104'
    _1_05='105'
    _1_06='106'
    _1_07='107'
    _1_08='108'
    _2_01='201'
    _3_02='302'
    _3_03='303'
    _3_04='304'
    _3_05='305'
    _4_01='401'
    _4_02='402'
    _4_03='403'
    _4_04='404'
    _4_05='405'
    _4_06='406'
    _4_07='407'
    _4_08='408'
    _4_09='409'
    _4_10='410'
    _4_11='411'
    _4_12='412'
    _4_13='413'
    _4_14='414'
    _4_15='415'
    _4_16='416'
    _4_17='417'
    _4_18='418'
    _4_19='419'
    _4_20='420'
    _4_21='421'
    _4_22='422'
    _4_23='423'
    _5_01='501'
    _5_02='502'
    _5_03='503'
    _5_04='504'
    _5_05='505'
    _5_06='506'
    _5_07='507'
    _5_08='508'
    _5_09='509'
    _6_01='601'
    _6_02='602'
    _6_03='603'
    _6_04='604'
    _6_05='605'
    _7_01='701'
    _7_02='702'
    _7_03='703'
    _7_04='704'
    _7_05='705'
    _7_06='706'
    _7_07='707'
    _7_08='708'
    _7_09='709'
    _7_10='710'
    _7_11='711'
    _7_12='712'
    _7_13='713'
    _7_16='716'
    _7_17='717'
    _7_18='718'
    _7_19='719'
    _7_20='720'
    _7_21='721'
    _7_22='722'
    _8_01='801'
    _8_02='802'
    _9_01='901'
    _9_02='902'
    _9_03='903'
    _1_001='1001'
    _1_002='1002'
    _1_003='1003'
    _1_004='1004'
    _1_005='1005'
    _1_006='1006'
    _1_007='1007'
    _1_008='1008'
    _1_009='1009'
    _1_010='1010'
    _1_101='1101'
    _1_102='1102'
    _1_103='1103'
    _1_104='1104'
    _1_201='1201'
    _1_202='1202'
    _1_203='1203'
    _1_204='1204'
    _1_205='1205'
    _1_206='1206'
    _1_207='1207'
    _1_208='1208'
    _1_209='1209'
    _1_210='1210'
    _1_211='1211'
    _1_212='1212'
    _1_213='1213'
    _1_214='1214'
    _1_215='1215'
    _1_216='1216'
    _1_217='1217'
    _1_302='1302'
    _1_303='1303'
    _1_304='1304'
    _1_305='1305'
    _1_401='1401'
    _1_402='1402'
    _1_403='1403'
    _1_404='1404'
    _1_405='1405'
    _1_406='1406'
    _1_407='1407'
    _1_408='1408'
    _1_409='1409'
    _1_410='1410'
    _1_411='1411'
    _1_412='1412'
    _1_413='1413'
    _1_501='1501'
    _1_502='1502'
    _1_503='1503'
    _1_504='1504'
    _1_505='1505'
    _1_506='1506'
    _1_507='1507'
    _1_508='1508'
    _1_509='1509'
    _1_510='1510'
    _1_511='1511'
    _1_512='1512'
    _1_513='1513'
    _1_514='1514'
    _1_515='1515'
    _1_516='1516'
    _1_517='1517'
    _1_518='1518'
    _1_601='1601'
    _1_701='1701'
    _1_702='1702'
    _1_703='1703'
    _1_704='1704'
    _1_705='1705'
    _1_706='1706'
    _1_708='1708'
    _1_709='1709'
    _1_710='1710'
    _1_711='1711'
    _1_712='1712'
    _1_713='1713'
    _1_714='1714'
    _1_715='1715'
    _1_716='1716'
    _1_717='1717'
    _1_718='1718'
    _1_719='1719'
    _1_720='1720'
    _1_721='1721'
    _1_722='1722'
    _1_723='1723'
    _1_724='1724'
    _1_801='1801'
    _1_901='1901'
    _2_001='2001'
    _2_002='2002'
    _2_003='2003'
    _2_101='2101'
    _2_201='2201'
    _2_301='2301'
    _2_401='2401'
    _2_501='2501'
    _2_502='2502'
    _2_503='2503'
    _2_504='2504'
    _2_601='2601'
    _2_701='2701'
    _2_801='2801'
    _2_901='2901'
    _3_001='3001'
    _3_101='3101'
    _3_201='3201'
    _3_301='3301'
    _3_401='3401'
    _3_501='3501'
    _3_601='3601'
    _3_701='3701'
    _3_801='3801'
    _3_901='3901'
    _4_001='4001'


class TCOrgaoIBGE(str, Enum):
    """TCOrgaoIBGE -- Tipo C
    ó
    digo de org
    ã
    o (UF da tabela do IBGE + 90 SUFRAMA + 91 RFB +  94 SVC-RS + 95 SVC-SP + 96  Sinc. Chaves do RS para SVSP
    
    """
    _1_1='11'
    _1_2='12'
    _1_3='13'
    _1_4='14'
    _1_5='15'
    _1_6='16'
    _1_7='17'
    _2_1='21'
    _2_2='22'
    _2_3='23'
    _2_4='24'
    _2_5='25'
    _2_6='26'
    _2_7='27'
    _2_8='28'
    _2_9='29'
    _3_1='31'
    _3_2='32'
    _3_3='33'
    _3_5='35'
    _4_1='41'
    _4_2='42'
    _4_3='43'
    _5_0='50'
    _5_1='51'
    _5_2='52'
    _5_3='53'
    _9_0='90'
    _9_1='91'
    _9_3='93'
    _9_4='94'
    _9_5='95'
    _9_6='96'


class TCRT(str, Enum):
    """TCRT -- Tipo C
    ó
    digo Regime Tribut
    á
    rio
    
    """
    _1='1'
    _2='2'
    _3='3'


class TCodUfIBGE(str, Enum):
    """TCodUfIBGE -- Tipo C
    ó
    digo da UF da tabela do IBGE
    
    """
    _1_1='11'
    _1_2='12'
    _1_3='13'
    _1_4='14'
    _1_5='15'
    _1_6='16'
    _1_7='17'
    _2_1='21'
    _2_2='22'
    _2_3='23'
    _2_4='24'
    _2_5='25'
    _2_6='26'
    _2_7='27'
    _2_8='28'
    _2_9='29'
    _3_1='31'
    _3_2='32'
    _3_3='33'
    _3_5='35'
    _4_1='41'
    _4_2='42'
    _4_3='43'
    _5_0='50'
    _5_1='51'
    _5_2='52'
    _5_3='53'


class TDocAssoc(str, Enum):
    """TDocAssoc --  Tipo Documento Associado
    
    """
    _0_7='07'
    _0_8='08'
    _0_9='09'
    _1_0='10'
    _1_1='11'
    _1_2='12'
    _1_3='13'


class TFinCTe(str, Enum):
    """TFinCTe -- Tipo Finalidade da CT-e
    
    """
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class TFinCTeOS(str, Enum):
    """TFinCTeOS -- Tipo Finalidade da CT-e Outros Servi
    ç
    os
    
    """
    _0='0'
    _1='1'


class TFinGTVe(str, Enum):
    """TFinGTVe -- Tipo Finalidade da GTV-e
    
    """
    _4='4'


class TModCT(str, Enum):
    """TModCT -- Tipo Modelo Documento Fiscal
    
    """
    _5_7='57'


class TModCTOS(str, Enum):
    """TModCTOS -- Tipo Modelo Documento Fiscal
    
    """
    _6_7='67'


class TModCT_Carga_OS(str, Enum):
    """TModCT_Carga_OS -- Tipo Modelo Documento Fiscal
    
    """
    _5_7='57'
    _6_7='67'


class TModDoc(str, Enum):
    """TModDoc --  Tipo Modelo do Documento
    
    """
    _0_1='01'
    _1_B='1B'
    _0_2='02'
    _2_D='2D'
    _2_E='2E'
    _0_4='04'
    _0_6='06'
    _0_7='07'
    _0_8='08'
    _8_B='8B'
    _0_9='09'
    _1_0='10'
    _1_1='11'
    _1_3='13'
    _1_4='14'
    _1_5='15'
    _1_6='16'
    _1_7='17'
    _1_8='18'
    _2_0='20'
    _2_1='21'
    _2_2='22'
    _2_3='23'
    _2_4='24'
    _2_5='25'
    _2_6='26'
    _2_7='27'
    _2_8='28'
    _5_5='55'


class TModGTVe(str, Enum):
    """TModGTVe -- Tipo Modelo Documento Fiscal
    
    """
    _6_4='64'


class TModNF(str, Enum):
    """TModNF -- Tipo Modelo Documento Fiscal - NF Remetente
    
    """
    _0_1='01'
    _0_4='04'


class TModTransp(str, Enum):
    """TModTransp --  Tipo Modal transporte
    
    """
    _0_1='01'
    _0_2='02'
    _0_3='03'
    _0_4='04'
    _0_5='05'
    _0_6='06'


class TModTranspGTVe(str, Enum):
    """TModTranspGTVe --  Tipo Modal transporte GTVe
    
    """
    _0_1='01'
    _0_6='06'


class TModTranspOS(str, Enum):
    """TModTranspOS --  Tipo Modal transporte Outros Servi
    ç
    os
    
    """
    _0_1='01'
    _0_2='02'
    _0_3='03'
    _0_4='04'


class TProcEmi(str, Enum):
    """TProcEmi -- Tipo processo de emiss
    ã
    o do CT-e
    
    """
    _0='0'
    _3='3'


class TTransformURI(str, Enum):
    HTTPWWWW_3ORG_2000_09XMLDSIGENVELOPEDSIGNATURE='http://www.w3.org/2000/09/xmldsig#enveloped-signature'
    HTTPWWWW_3ORGTR_2001RECXMLC_14_N_20010315='http://www.w3.org/TR/2001/REC-xml-c14n-20010315'


class TUF_sem_EX(str, Enum):
    """TUF_sem_EX -- Tipo Sigla da UF, sem Exterior
    
    """
    AC='AC'
    AL='AL'
    AM='AM'
    AP='AP'
    BA='BA'
    CE='CE'
    DF='DF'
    ES='ES'
    GO='GO'
    MA='MA'
    MG='MG'
    MS='MS'
    MT='MT'
    PA='PA'
    PB='PB'
    PE='PE'
    PI='PI'
    PR='PR'
    RJ='RJ'
    RN='RN'
    RO='RO'
    RR='RR'
    RS='RS'
    SC='SC'
    SE='SE'
    SP='SP'
    TO='TO'


class TUf(str, Enum):
    """TUf -- Tipo Sigla da UF
    
    """
    AC='AC'
    AL='AL'
    AM='AM'
    AP='AP'
    BA='BA'
    CE='CE'
    DF='DF'
    ES='ES'
    GO='GO'
    MA='MA'
    MG='MG'
    MS='MS'
    MT='MT'
    PA='PA'
    PB='PB'
    PE='PE'
    PI='PI'
    PR='PR'
    RJ='RJ'
    RN='RN'
    RO='RO'
    RR='RR'
    RS='RS'
    SC='SC'
    SE='SE'
    SP='SP'
    TO='TO'
    EX='EX'


class TtipoUnidCarga(str, Enum):
    """TtipoUnidCarga -- Tipo da Unidade de Carga
    
    """
    _1='1'
    _2='2'
    _3='3'
    _4='4'


class TtipoUnidTransp(str, Enum):
    """TtipoUnidTransp -- Tipo da Unidade de Transporte
    
    """
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'
    _7='7'


class cUnidType(str, Enum):
    """cUnidType -- C
    ó
    digo da Unidade de Medida
    Preencher com:
    00-M3;
    01-KG;
    02-TON;
    03-UNIDADE;
    04-LITROS;
    05-MMBTU
    
    """
    _0_0='00'
    _0_1='01'
    _0_2='02'
    _0_3='03'
    _0_4='04'
    _0_5='05'


class indAlteraTomaType(str, Enum):
    """indAlteraTomaType -- Indicador de CT-e Altera
    ç
    ã
    o de Tomador
    
    """
    _1='1'


class indGlobalizadoType(str, Enum):
    """indGlobalizadoType -- Indicador de CT-e Globalizado
    Informar valor 1 quando for Globalizado e n
    ã
    o informar a tag quando n
    ã
    o tratar de CT-e Globalizado
    
    """
    _1='1'


class indIETomaType(str, Enum):
    """indIETomaType -- Indicador da IE do tomador:
    1
    –
    Contribuinte ICMS;
    2
    –
    Contribuinte isento de inscri
    ç
    ã
    o;
    9
    –
    N
    ã
    o Contribuinte
    Aplica-se ao tomador que for indicado no toma3 ou toma4
    
    """
    _1='1'
    _2='2'
    _9='9'


class indIETomaType104(str, Enum):
    """indIETomaType104 -- Indicador da IE do tomador:
    1
    –
    Contribuinte ICMS;
    2
    –
    Contribuinte isento de inscri
    ç
    ã
    o;
    9
    –
    N
    ã
    o Contribuinte
    Aplica-se ao tomador que for indicado no toma3 ou toma4
    
    """
    _1='1'
    _2='2'
    _9='9'


class indIETomaType37(str, Enum):
    """indIETomaType37 -- Indicador do papel do tomador na presta
    ç
    ã
    o do servi
    ç
    o:
    1
    –
    Contribuinte ICMS;
    2
    –
    Contribuinte isento de inscri
    ç
    ã
    o;
    9
    –
    N
    ã
    o Contribuinte
    Aplica-se ao tomador que for indicado no toma3 ou toma4
    
    """
    _1='1'
    _2='2'
    _9='9'


class indSNType(str, Enum):
    """indSNType -- Indica se o contribuinte
    é
    Simples Nacional			1=Sim
    
    """
    _1='1'


class indSNType208(str, Enum):
    """indSNType208 -- Indica se o contribuinte
    é
    Simples Nacional			1=Sim
    
    """
    _1='1'


class modalType(str, Enum):
    """modalType -- Modal da GTV-e
    Preencher com:
    01-Rodovi
    á
    rio
    06-Multimodal
    
    """
    _0_1='01'
    _0_6='06'


class respSegType(str, Enum):
    """respSegType -- Respons
    á
    vel pelo seguro
    Preencher com:
    4 - Emitente do CT-e;
    5 - Tomador de Servi
    ç
    o.
    
    """
    _4='4'
    _5='5'


class retiraType(str, Enum):
    """retiraType -- Indicador se o Recebedor retira no Aeroporto, Filial, Porto ou Esta
    ç
    ã
    o de Destino?
    Preencher com: 0 - sim; 1 - n
    ã
    o
    
    """
    _0='0'
    _1='1'


class tomaType1(str, Enum):
    """tomaType1 -- Tomador do Servi
    ç
    o
    Preencher com:
    0-Remetente;
    1-Destinat
    á
    rio
    
    """
    _0='0'
    _1='1'


class tomaType2(str, Enum):
    """tomaType2 -- Tomador do Servi
    ç
    o
    Preencher com:
    4 - Outros
    Obs: Informar os dados cadastrais do tomador do servi
    ç
    o
    
    """
    _4='4'


class tomaType38(str, Enum):
    """tomaType38 -- Tomador do Servi
    ç
    o
    Preencher com:
    0-Remetente;
    1-Expedidor;
    2-Recebedor;
    3-Destinat
    á
    rio
    Ser
    ã
    o utilizadas as informa
    ç
    õ
    es contidas no respectivo grupo, conforme indicado pelo conte
    ú
    do deste campo
    
    """
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class tomaType39(str, Enum):
    """tomaType39 -- Tomador do Servi
    ç
    o
    Preencher com:
    4 - Outros
    Obs: Informar os dados cadastrais do tomador do servi
    ç
    o
    
    """
    _4='4'


class tpCompType(str, Enum):
    """tpCompType -- Tipo do Componente
    1-Custodia
    2-Embarque
    3-Tempo de espera
    4-Malote
    5-Ad Valorem
    6-Outros
    
    """
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'


class tpDocType(str, Enum):
    """tpDocType -- Tipo de documento origin
    á
    rio
    Preencher com:
    00 - Declara
    ç
    ã
    o;
    10 - Dutovi
    á
    rio;
    59 - CF-e SAT;
    65 - NFC-e;
    99 - Outros
    
    """
    _0_0='00'
    _1_0='10'
    _5_9='59'
    _6_5='65'
    _9_9='99'


class tpEmisType(str, Enum):
    """tpEmisType -- Forma de emiss
    ã
    o da GTV-e
    Preencher com:
    1 - Normal;
    2- Contingencia offline
    7 - Autoriza
    ç
    ã
    o pela SVC-RS;
    8 - Autoriza
    ç
    ã
    o pela SVC-SP
    
    """
    _1='1'
    _2='2'
    _7='7'
    _8='8'


class tpEmisType32(str, Enum):
    """tpEmisType32 -- Forma de emiss
    ã
    o do CT-e
    Preencher com:
    1 - Normal;
    3-Regime Especial NFF;  4-EPEC pela SVC; 5 - Conting
    ê
    ncia FSDA;
    7 - Autoriza
    ç
    ã
    o pela SVC-RS;
    8 - Autoriza
    ç
    ã
    o pela SVC-SP
    
    """
    _1='1'
    _3='3'
    _4='4'
    _5='5'
    _7='7'
    _8='8'


class tpEmisType99(str, Enum):
    """tpEmisType99 -- Forma de emiss
    ã
    o do CT-e
    Preencher com:
    1 - Normal;
    5 - Conting
    ê
    ncia FSDA;
    7 - Autoriza
    ç
    ã
    o pela SVC-RS;
    8 - Autoriza
    ç
    ã
    o pela SVC-SP
    
    """
    _1='1'
    _5='5'
    _7='7'
    _8='8'


class tpEspecieType(str, Enum):
    """tpEspecieType -- Tipo da Esp
    é
    cie
    1 - C
    é
    dula
    2 - Cheque
    3 - Moeda
    4 - Outros
    
    """
    _1='1'
    _2='2'
    _3='3'
    _4='4'


class tpHorType(str, Enum):
    """tpHorType -- Tipo de hora
    0- Sem hora definida
    
    """
    _0='0'


class tpHorType50(str, Enum):
    """tpHorType50 -- Tipo de hora
    Preencher com:
    1 - No hor
    á
    rio;
    2 - At
    é
    o hor
    á
    rio;
    3 - A partir do hor
    á
    rio.
    
    """
    _1='1'
    _2='2'
    _3='3'


class tpHorType51(str, Enum):
    """tpHorType51 --  Tipo de hora
    4 - No intervalo de tempo
    
    """
    _4='4'


class tpImpType(str, Enum):
    """tpImpType -- Formato de impress
    ã
    o do DACTE
    Preencher com: 1 - Retrato; 2 - Paisagem.
    
    """
    _1='1'
    _2='2'


class tpImpType31(str, Enum):
    """tpImpType31 -- Formato de impress
    ã
    o do DACTE
    Preencher com: 1 - Retrato; 2 - Paisagem.
    
    """
    _1='1'
    _2='2'


class tpImpType98(str, Enum):
    """tpImpType98 -- Formato de impress
    ã
    o do DACTE OS
    Preencher com: 1 - Retrato; 2 - Paisagem.
    
    """
    _1='1'
    _2='2'


class tpNumerarioType(str, Enum):
    """tpNumerarioType -- Nacionalidade do Numer
    á
    rio
    1 - Nacional
    2 - Estrangeiro
    
    """
    _1='1'
    _2='2'


class tpPerType(str, Enum):
    """tpPerType -- Tipo de data/per
    í
    odo programado para entrega
    0- Sem data definida
    
    """
    _0='0'


class tpPerType48(str, Enum):
    """tpPerType48 -- Tipo de data/per
    í
    odo programado para entrega
    Preencher com:
    1-Na data;
    2-At
    é
    a data;
    3-A partir da data
    
    """
    _1='1'
    _2='2'
    _3='3'


class tpPerType49(str, Enum):
    """tpPerType49 -- Tipo per
    í
    odo
    4-no per
    í
    odo
    
    """
    _4='4'


class tpServType(str, Enum):
    """tpServType -- Tipo do Servi
    ç
    o
    Preencher com:
    9 - GTV
    
    """
    _9='9'


class tpServType103(str, Enum):
    """tpServType103 -- Tipo do Servi
    ç
    o
    Preencher com:
    6 - Transporte de Pessoas;
    7 - Transporte de Valores;
    8 - Excesso de Bagagem.
    
    """
    _6='6'
    _7='7'
    _8='8'


class tpServType36(str, Enum):
    """tpServType36 -- Tipo do Servi
    ç
    o
    Preencher com:
    0 - Normal;1 - Subcontrata
    ç
    ã
    o;
    2 - Redespacho;3 - Redespacho Intermedi
    á
    rio; 4 - Servi
    ç
    o Vinculado a Multimodal
    
    """
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'


class TGTVe(GeneratedsSuper):
    """TGTVe -- Tipo Guia de Transporte de Valores Eletr
    ô
    nica (Modelo 64)
    versao -- Vers
    ã
    o do leiaute
    infCte -- Informa
    ç
    õ
    es do CT-e do tipo GTV-e
    infCTeSupl -- Informa
    ç
    õ
    es suplementares da GTV-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, infCte=None, infCTeSupl=None, Signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.infCte = infCte
        self.infCte_nsprefix_ = None
        self.infCTeSupl = infCTeSupl
        self.infCTeSupl_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TGTVe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TGTVe.subclass:
            return TGTVe.subclass(*args_, **kwargs_)
        else:
            return TGTVe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infCte(self):
        return self.infCte
    def set_infCte(self, infCte):
        self.infCte = infCte
    def get_infCTeSupl(self):
        return self.infCTeSupl
    def set_infCTeSupl(self, infCTeSupl):
        self.infCTeSupl = infCTeSupl
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_versaoType13(self, value):
        # Validate type versaoType13, a restriction on TVerCTe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoType13_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoType13_patterns_, ))
    validate_versaoType13_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.infCte is not None or
            self.infCTeSupl is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TGTVe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TGTVe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TGTVe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TGTVe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TGTVe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TGTVe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TGTVe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infCte is not None:
            namespaceprefix_ = self.infCte_nsprefix_ + ':' if (UseCapturedNS_ and self.infCte_nsprefix_) else ''
            self.infCte.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCte', pretty_print=pretty_print)
        if self.infCTeSupl is not None:
            namespaceprefix_ = self.infCTeSupl_nsprefix_ + ':' if (UseCapturedNS_ and self.infCTeSupl_nsprefix_) else ''
            self.infCTeSupl.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCTeSupl', pretty_print=pretty_print)
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_versaoType13(self.versao)    # validate type versaoType13
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infCte':
            obj_ = infCteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCte = obj_
            obj_.original_tagname_ = 'infCte'
        elif nodeName_ == 'infCTeSupl':
            obj_ = infCTeSuplType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCTeSupl = obj_
            obj_.original_tagname_ = 'infCTeSupl'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TGTVe


class TProtCTe(GeneratedsSuper):
    """TProtCTe -- Tipo Protocolo de status resultado do processamento da CT-e
    infProt -- Dados do protocolo de status
    infFisco -- Mensagem do Fisco
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, infProt=None, infFisco=None, Signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.infProt = infProt
        self.infProt_nsprefix_ = None
        self.infFisco = infFisco
        self.infFisco_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TProtCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TProtCTe.subclass:
            return TProtCTe.subclass(*args_, **kwargs_)
        else:
            return TProtCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infProt(self):
        return self.infProt
    def set_infProt(self, infProt):
        self.infProt = infProt
    def get_infFisco(self):
        return self.infFisco
    def set_infFisco(self, infFisco):
        self.infFisco = infFisco
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_versaoType14(self, value):
        # Validate type versaoType14, a restriction on TVerCTe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoType14_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoType14_patterns_, ))
    validate_versaoType14_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.infProt is not None or
            self.infFisco is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TProtCTe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TProtCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TProtCTe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TProtCTe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TProtCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TProtCTe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TProtCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infProt is not None:
            namespaceprefix_ = self.infProt_nsprefix_ + ':' if (UseCapturedNS_ and self.infProt_nsprefix_) else ''
            self.infProt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infProt', pretty_print=pretty_print)
        if self.infFisco is not None:
            namespaceprefix_ = self.infFisco_nsprefix_ + ':' if (UseCapturedNS_ and self.infFisco_nsprefix_) else ''
            self.infFisco.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infFisco', pretty_print=pretty_print)
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_versaoType14(self.versao)    # validate type versaoType14
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infProt':
            obj_ = infProtType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infProt = obj_
            obj_.original_tagname_ = 'infProt'
        elif nodeName_ == 'infFisco':
            obj_ = infFiscoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infFisco = obj_
            obj_.original_tagname_ = 'infFisco'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TProtCTe


class TProtCTeOS(GeneratedsSuper):
    """TProtCTeOS -- Tipo Protocolo de status resultado do processamento do CT-e OS (Modelo 67)
    infProt -- Dados do protocolo de status
    infFisco -- Mensagem do Fisco
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, infProt=None, infFisco=None, Signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.infProt = infProt
        self.infProt_nsprefix_ = None
        self.infFisco = infFisco
        self.infFisco_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TProtCTeOS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TProtCTeOS.subclass:
            return TProtCTeOS.subclass(*args_, **kwargs_)
        else:
            return TProtCTeOS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infProt(self):
        return self.infProt
    def set_infProt(self, infProt):
        self.infProt = infProt
    def get_infFisco(self):
        return self.infFisco
    def set_infFisco(self, infFisco):
        self.infFisco = infFisco
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_versaoType19(self, value):
        # Validate type versaoType19, a restriction on TVerCTe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoType19_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoType19_patterns_, ))
    validate_versaoType19_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.infProt is not None or
            self.infFisco is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TProtCTeOS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TProtCTeOS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TProtCTeOS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TProtCTeOS')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TProtCTeOS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TProtCTeOS'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TProtCTeOS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infProt is not None:
            namespaceprefix_ = self.infProt_nsprefix_ + ':' if (UseCapturedNS_ and self.infProt_nsprefix_) else ''
            self.infProt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infProt', pretty_print=pretty_print)
        if self.infFisco is not None:
            namespaceprefix_ = self.infFisco_nsprefix_ + ':' if (UseCapturedNS_ and self.infFisco_nsprefix_) else ''
            self.infFisco.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infFisco', pretty_print=pretty_print)
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_versaoType19(self.versao)    # validate type versaoType19
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infProt':
            obj_ = infProtType15.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infProt = obj_
            obj_.original_tagname_ = 'infProt'
        elif nodeName_ == 'infFisco':
            obj_ = infFiscoType17.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infFisco = obj_
            obj_.original_tagname_ = 'infFisco'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TProtCTeOS


class TProtGTVe(GeneratedsSuper):
    """TProtGTVe -- Tipo Protocolo de status resultado do processamento da GTV-e (Modelo 64)
    infProt -- Dados do protocolo de status
    infFisco -- Mensagem do Fisco
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, infProt=None, infFisco=None, Signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.infProt = infProt
        self.infProt_nsprefix_ = None
        self.infFisco = infFisco
        self.infFisco_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TProtGTVe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TProtGTVe.subclass:
            return TProtGTVe.subclass(*args_, **kwargs_)
        else:
            return TProtGTVe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infProt(self):
        return self.infProt
    def set_infProt(self, infProt):
        self.infProt = infProt
    def get_infFisco(self):
        return self.infFisco
    def set_infFisco(self, infFisco):
        self.infFisco = infFisco
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_versaoType24(self, value):
        # Validate type versaoType24, a restriction on TVerCTe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoType24_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoType24_patterns_, ))
    validate_versaoType24_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.infProt is not None or
            self.infFisco is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TProtGTVe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TProtGTVe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TProtGTVe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TProtGTVe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TProtGTVe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TProtGTVe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TProtGTVe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infProt is not None:
            namespaceprefix_ = self.infProt_nsprefix_ + ':' if (UseCapturedNS_ and self.infProt_nsprefix_) else ''
            self.infProt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infProt', pretty_print=pretty_print)
        if self.infFisco is not None:
            namespaceprefix_ = self.infFisco_nsprefix_ + ':' if (UseCapturedNS_ and self.infFisco_nsprefix_) else ''
            self.infFisco.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infFisco', pretty_print=pretty_print)
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_versaoType24(self.versao)    # validate type versaoType24
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infProt':
            obj_ = infProtType20.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infProt = obj_
            obj_.original_tagname_ = 'infProt'
        elif nodeName_ == 'infFisco':
            obj_ = infFiscoType22.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infFisco = obj_
            obj_.original_tagname_ = 'infFisco'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TProtGTVe


class TRetCTe(GeneratedsSuper):
    """TRetCTe -- Tipo Retorno do Pedido de Autoriza
    ç
    ã
    o de CT-e (Modelo 57)
    tpAmb -- Identifica
    ç
    ã
    o do Ambiente:
    1 - Produ
    ç
    ã
    o
    2 - Homologa
    ç
    ã
    o
    cUF -- Identifica
    ç
    ã
    o da UF
    verAplic -- Vers
    ã
    o do Aplicativo que processou a CT-e
    cStat -- c
    ó
    digo do status do retorno da consulta.
    xMotivo -- Descri
    ç
    ã
    o literal do status do do retorno da consulta.
    protCTe -- Reposta ao processamento do CT-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, cUF=None, verAplic=None, cStat=None, xMotivo=None, protCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cUF_nsprefix_ = None
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.verAplic_nsprefix_ = None
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.cStat_nsprefix_ = None
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.xMotivo_nsprefix_ = None
        self.protCTe = protCTe
        self.protCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetCTe.subclass:
            return TRetCTe.subclass(*args_, **kwargs_)
        else:
            return TRetCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_protCTe(self):
        return self.protCTe
    def set_protCTe(self, protCTe):
        self.protCTe = protCTe
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TCodUfIBGE(self, value):
        result = True
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TVerAplic(self, value):
        result = True
        # Validate type TVerAplic, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TVerAplic' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TVerAplic' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerAplic_patterns_, ))
                result = False
        return result
    validate_TVerAplic_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TStat(self, value):
        result = True
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TStat_patterns_, ))
                result = False
        return result
    validate_TStat_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerCTe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerCTe_patterns_, ))
    validate_TVerCTe_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.tpAmb is not None or
            self.cUF is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.protCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRetCTe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TRetCTe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TRetCTe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TRetCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TRetCTe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versao), input_name='versao')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRetCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.cUF is not None:
            namespaceprefix_ = self.cUF_nsprefix_ + ':' if (UseCapturedNS_ and self.cUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            namespaceprefix_ = self.verAplic_nsprefix_ + ':' if (UseCapturedNS_ and self.verAplic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.cStat is not None:
            namespaceprefix_ = self.cStat_nsprefix_ + ':' if (UseCapturedNS_ and self.cStat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            namespaceprefix_ = self.xMotivo_nsprefix_ + ':' if (UseCapturedNS_ and self.xMotivo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
        if self.protCTe is not None:
            namespaceprefix_ = self.protCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.protCTe_nsprefix_) else ''
            self.protCTe.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protCTe', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'cUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cUF')
            value_ = self.gds_validate_string(value_, node, 'cUF')
            self.cUF = value_
            self.cUF_nsprefix_ = child_.prefix
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'verAplic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verAplic')
            value_ = self.gds_validate_string(value_, node, 'verAplic')
            self.verAplic = value_
            self.verAplic_nsprefix_ = child_.prefix
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'cStat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cStat')
            value_ = self.gds_validate_string(value_, node, 'cStat')
            self.cStat = value_
            self.cStat_nsprefix_ = child_.prefix
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMotivo')
            value_ = self.gds_validate_string(value_, node, 'xMotivo')
            self.xMotivo = value_
            self.xMotivo_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'protCTe':
            obj_ = TProtCTe.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protCTe = obj_
            obj_.original_tagname_ = 'protCTe'
# end class TRetCTe


class TRetGTVe(GeneratedsSuper):
    """TRetGTVe -- Tipo Retorno do Pedido de Autoriza
    ç
    ã
    o de GTV-e (Modelo 64)
    tpAmb -- Identifica
    ç
    ã
    o do Ambiente:
    1 - Produ
    ç
    ã
    o
    2 - Homologa
    ç
    ã
    o
    cUF -- Identifica
    ç
    ã
    o da UF
    verAplic -- Vers
    ã
    o do Aplicativo que processou a GTV-e
    cStat -- c
    ó
    digo do status do retorno da consulta.
    xMotivo -- Descri
    ç
    ã
    o literal do status do do retorno da consulta.
    protCTe -- Reposta ao processamento do CT-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, cUF=None, verAplic=None, cStat=None, xMotivo=None, protCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cUF_nsprefix_ = None
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.verAplic_nsprefix_ = None
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.cStat_nsprefix_ = None
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.xMotivo_nsprefix_ = None
        self.protCTe = protCTe
        self.protCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetGTVe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetGTVe.subclass:
            return TRetGTVe.subclass(*args_, **kwargs_)
        else:
            return TRetGTVe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_protCTe(self):
        return self.protCTe
    def set_protCTe(self, protCTe):
        self.protCTe = protCTe
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TCodUfIBGE(self, value):
        result = True
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TVerAplic(self, value):
        result = True
        # Validate type TVerAplic, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TVerAplic' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TVerAplic' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerAplic_patterns_, ))
                result = False
        return result
    validate_TVerAplic_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TStat(self, value):
        result = True
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TStat_patterns_, ))
                result = False
        return result
    validate_TStat_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerCTe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerCTe_patterns_, ))
    validate_TVerCTe_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.tpAmb is not None or
            self.cUF is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.protCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRetGTVe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetGTVe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TRetGTVe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TRetGTVe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TRetGTVe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TRetGTVe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versao), input_name='versao')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRetGTVe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.cUF is not None:
            namespaceprefix_ = self.cUF_nsprefix_ + ':' if (UseCapturedNS_ and self.cUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            namespaceprefix_ = self.verAplic_nsprefix_ + ':' if (UseCapturedNS_ and self.verAplic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.cStat is not None:
            namespaceprefix_ = self.cStat_nsprefix_ + ':' if (UseCapturedNS_ and self.cStat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            namespaceprefix_ = self.xMotivo_nsprefix_ + ':' if (UseCapturedNS_ and self.xMotivo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
        if self.protCTe is not None:
            namespaceprefix_ = self.protCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.protCTe_nsprefix_) else ''
            self.protCTe.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protCTe', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'cUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cUF')
            value_ = self.gds_validate_string(value_, node, 'cUF')
            self.cUF = value_
            self.cUF_nsprefix_ = child_.prefix
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'verAplic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verAplic')
            value_ = self.gds_validate_string(value_, node, 'verAplic')
            self.verAplic = value_
            self.verAplic_nsprefix_ = child_.prefix
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'cStat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cStat')
            value_ = self.gds_validate_string(value_, node, 'cStat')
            self.cStat = value_
            self.cStat_nsprefix_ = child_.prefix
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMotivo')
            value_ = self.gds_validate_string(value_, node, 'xMotivo')
            self.xMotivo = value_
            self.xMotivo_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'protCTe':
            obj_ = TProtGTVe.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protCTe = obj_
            obj_.original_tagname_ = 'protCTe'
# end class TRetGTVe


class TRetCTeOS(GeneratedsSuper):
    """TRetCTeOS -- Tipo Retorno do Pedido de Autoriza
    ç
    ã
    o de CT-e OS (Modelo 67)
    tpAmb -- Identifica
    ç
    ã
    o do Ambiente:
    1 - Produ
    ç
    ã
    o
    2 - Homologa
    ç
    ã
    o
    cUF -- Identifica
    ç
    ã
    o da UF
    verAplic -- Vers
    ã
    o do Aplicativo que processou a CT-e
    cStat -- c
    ó
    digo do status do retorno da consulta.
    xMotivo -- Descri
    ç
    ã
    o literal do status do do retorno da consulta.
    protCTe -- Reposta ao processamento do CT-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, cUF=None, verAplic=None, cStat=None, xMotivo=None, protCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cUF_nsprefix_ = None
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.verAplic_nsprefix_ = None
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.cStat_nsprefix_ = None
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.xMotivo_nsprefix_ = None
        self.protCTe = protCTe
        self.protCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetCTeOS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetCTeOS.subclass:
            return TRetCTeOS.subclass(*args_, **kwargs_)
        else:
            return TRetCTeOS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_protCTe(self):
        return self.protCTe
    def set_protCTe(self, protCTe):
        self.protCTe = protCTe
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TCodUfIBGE(self, value):
        result = True
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TVerAplic(self, value):
        result = True
        # Validate type TVerAplic, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TVerAplic' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TVerAplic' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerAplic_patterns_, ))
                result = False
        return result
    validate_TVerAplic_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TStat(self, value):
        result = True
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TStat_patterns_, ))
                result = False
        return result
    validate_TStat_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerCTe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerCTe_patterns_, ))
    validate_TVerCTe_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.tpAmb is not None or
            self.cUF is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.protCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRetCTeOS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetCTeOS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TRetCTeOS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TRetCTeOS')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TRetCTeOS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TRetCTeOS'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versao), input_name='versao')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRetCTeOS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.cUF is not None:
            namespaceprefix_ = self.cUF_nsprefix_ + ':' if (UseCapturedNS_ and self.cUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            namespaceprefix_ = self.verAplic_nsprefix_ + ':' if (UseCapturedNS_ and self.verAplic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.cStat is not None:
            namespaceprefix_ = self.cStat_nsprefix_ + ':' if (UseCapturedNS_ and self.cStat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            namespaceprefix_ = self.xMotivo_nsprefix_ + ':' if (UseCapturedNS_ and self.xMotivo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
        if self.protCTe is not None:
            namespaceprefix_ = self.protCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.protCTe_nsprefix_) else ''
            self.protCTe.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protCTe', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'cUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cUF')
            value_ = self.gds_validate_string(value_, node, 'cUF')
            self.cUF = value_
            self.cUF_nsprefix_ = child_.prefix
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'verAplic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verAplic')
            value_ = self.gds_validate_string(value_, node, 'verAplic')
            self.verAplic = value_
            self.verAplic_nsprefix_ = child_.prefix
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'cStat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cStat')
            value_ = self.gds_validate_string(value_, node, 'cStat')
            self.cStat = value_
            self.cStat_nsprefix_ = child_.prefix
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMotivo')
            value_ = self.gds_validate_string(value_, node, 'xMotivo')
            self.xMotivo = value_
            self.xMotivo_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'protCTe':
            obj_ = TProtCTeOS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protCTe = obj_
            obj_.original_tagname_ = 'protCTe'
# end class TRetCTeOS


class TCTe(GeneratedsSuper):
    """TCTe -- Tipo Conhecimento de Transporte Eletr
    ô
    nico (Modelo 57)
    infCte -- Informa
    ç
    õ
    es do CT-e
    infCTeSupl -- Informa
    ç
    õ
    es suplementares do CT-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, infCte=None, infCTeSupl=None, Signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.infCte = infCte
        self.infCte_nsprefix_ = None
        self.infCTeSupl = infCTeSupl
        self.infCTeSupl_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TCTe.subclass:
            return TCTe.subclass(*args_, **kwargs_)
        else:
            return TCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infCte(self):
        return self.infCte
    def set_infCte(self, infCte):
        self.infCte = infCte
    def get_infCTeSupl(self):
        return self.infCTeSupl
    def set_infCTeSupl(self, infCTeSupl):
        self.infCTeSupl = infCTeSupl
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def _hasContent(self):
        if (
            self.infCte is not None or
            self.infCTeSupl is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TCTe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TCTe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TCTe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TCTe'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infCte is not None:
            namespaceprefix_ = self.infCte_nsprefix_ + ':' if (UseCapturedNS_ and self.infCte_nsprefix_) else ''
            self.infCte.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCte', pretty_print=pretty_print)
        if self.infCTeSupl is not None:
            namespaceprefix_ = self.infCTeSupl_nsprefix_ + ':' if (UseCapturedNS_ and self.infCTeSupl_nsprefix_) else ''
            self.infCTeSupl.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCTeSupl', pretty_print=pretty_print)
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infCte':
            obj_ = infCteType25.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCte = obj_
            obj_.original_tagname_ = 'infCte'
        elif nodeName_ == 'infCTeSupl':
            obj_ = infCTeSuplType90.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCTeSupl = obj_
            obj_.original_tagname_ = 'infCTeSupl'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TCTe


class TCTeOS(GeneratedsSuper):
    """TCTeOS -- Tipo Conhecimento de Transporte Eletr
    ô
    nico Outros Servi
    ç
    os (Modelo 67)
    versao -- Vers
    ã
    o do leiaute
    infCte -- Informa
    ç
    õ
    es do CT-e Outros Servi
    ç
    os
    infCTeSupl -- Informa
    ç
    õ
    es suplementares do CT-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, infCte=None, infCTeSupl=None, Signature=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.infCte = infCte
        self.infCte_nsprefix_ = None
        self.infCTeSupl = infCTeSupl
        self.infCTeSupl_nsprefix_ = None
        self.Signature = Signature
        self.Signature_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TCTeOS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TCTeOS.subclass:
            return TCTeOS.subclass(*args_, **kwargs_)
        else:
            return TCTeOS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infCte(self):
        return self.infCte
    def set_infCte(self, infCte):
        self.infCte = infCte
    def get_infCTeSupl(self):
        return self.infCTeSupl
    def set_infCTeSupl(self, infCTeSupl):
        self.infCTeSupl = infCTeSupl
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_versaoType161(self, value):
        # Validate type versaoType161, a restriction on TVerCTe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoType161_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoType161_patterns_, ))
    validate_versaoType161_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.infCte is not None or
            self.infCTeSupl is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TCTeOS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TCTeOS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TCTeOS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TCTeOS')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TCTeOS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TCTeOS'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TCTeOS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infCte is not None:
            namespaceprefix_ = self.infCte_nsprefix_ + ':' if (UseCapturedNS_ and self.infCte_nsprefix_) else ''
            self.infCte.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCte', pretty_print=pretty_print)
        if self.infCTeSupl is not None:
            namespaceprefix_ = self.infCTeSupl_nsprefix_ + ':' if (UseCapturedNS_ and self.infCTeSupl_nsprefix_) else ''
            self.infCTeSupl.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCTeSupl', pretty_print=pretty_print)
        if self.Signature is not None:
            namespaceprefix_ = self.Signature_nsprefix_ + ':' if (UseCapturedNS_ and self.Signature_nsprefix_) else ''
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_versaoType161(self.versao)    # validate type versaoType161
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infCte':
            obj_ = infCteType92.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCte = obj_
            obj_.original_tagname_ = 'infCte'
        elif nodeName_ == 'infCTeSupl':
            obj_ = infCTeSuplType159.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCTeSupl = obj_
            obj_.original_tagname_ = 'infCTeSupl'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TCTeOS


class TEnviCTe(GeneratedsSuper):
    """TEnviCTe -- Tipo Pedido de Concess
    ã
    o de Autoriza
    ç
    ã
    o da CT-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, idLote=None, CTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.idLote = idLote
        self.validate_TIdLote(self.idLote)
        self.idLote_nsprefix_ = None
        if CTe is None:
            self.CTe = []
        else:
            self.CTe = CTe
        self.CTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnviCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnviCTe.subclass:
            return TEnviCTe.subclass(*args_, **kwargs_)
        else:
            return TEnviCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idLote(self):
        return self.idLote
    def set_idLote(self, idLote):
        self.idLote = idLote
    def get_CTe(self):
        return self.CTe
    def set_CTe(self, CTe):
        self.CTe = CTe
    def add_CTe(self, value):
        self.CTe.append(value)
    def insert_CTe_at(self, index, value):
        self.CTe.insert(index, value)
    def replace_CTe_at(self, index, value):
        self.CTe[index] = value
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TIdLote(self, value):
        result = True
        # Validate type TIdLote, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TIdLote_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TIdLote_patterns_, ))
                result = False
        return result
    validate_TIdLote_patterns_ = [['^([0-9]{1,15})$']]
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerCTe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerCTe_patterns_, ))
    validate_TVerCTe_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.idLote is not None or
            self.CTe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEnviCTe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnviCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEnviCTe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEnviCTe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEnviCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEnviCTe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versao), input_name='versao')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEnviCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.idLote is not None:
            namespaceprefix_ = self.idLote_nsprefix_ + ':' if (UseCapturedNS_ and self.idLote_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidLote>%s</%sidLote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.idLote), input_name='idLote')), namespaceprefix_ , eol_))
        for CTe_ in self.CTe:
            namespaceprefix_ = self.CTe_nsprefix_ + ':' if (UseCapturedNS_ and self.CTe_nsprefix_) else ''
            CTe_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CTe', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'idLote':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'idLote')
            value_ = self.gds_validate_string(value_, node, 'idLote')
            self.idLote = value_
            self.idLote_nsprefix_ = child_.prefix
            # validate type TIdLote
            self.validate_TIdLote(self.idLote)
        elif nodeName_ == 'CTe':
            obj_ = TCTe.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CTe.append(obj_)
            obj_.original_tagname_ = 'CTe'
# end class TEnviCTe


class TRetEnviCTe(GeneratedsSuper):
    """TRetEnviCTe -- Tipo Retorno do Pedido de Concess
    ã
    o de Autoriza
    ç
    ã
    o da CT-e
    tpAmb -- Identifica
    ç
    ã
    o do Ambiente:1 - Produ
    ç
    ã
    o; 2 - Homologa
    ç
    ã
    o
    cUF -- Identifica
    ç
    ã
    o da UF
    verAplic -- Vers
    ã
    o do Aplicativo que recebeu o Lote.
    cStat -- C
    ó
    digo do status da mensagem enviada.
    xMotivo -- Descri
    ç
    ã
    o literal do status do servi
    ç
    o solicitado.
    infRec -- Dados do Recibo do Lote
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, cUF=None, verAplic=None, cStat=None, xMotivo=None, infRec=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cUF_nsprefix_ = None
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.verAplic_nsprefix_ = None
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.cStat_nsprefix_ = None
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.xMotivo_nsprefix_ = None
        self.infRec = infRec
        self.infRec_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetEnviCTe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetEnviCTe.subclass:
            return TRetEnviCTe.subclass(*args_, **kwargs_)
        else:
            return TRetEnviCTe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_infRec(self):
        return self.infRec
    def set_infRec(self, infRec):
        self.infRec = infRec
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TCodUfIBGE(self, value):
        result = True
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TVerAplic(self, value):
        result = True
        # Validate type TVerAplic, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TVerAplic' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TVerAplic' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerAplic_patterns_, ))
                result = False
        return result
    validate_TVerAplic_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TStat(self, value):
        result = True
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TStat_patterns_, ))
                result = False
        return result
    validate_TStat_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TVerCTe(self, value):
        # Validate type TVerCTe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerCTe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerCTe_patterns_, ))
    validate_TVerCTe_patterns_ = [['^(3\\.00)$']]
    def _hasContent(self):
        if (
            self.tpAmb is not None or
            self.cUF is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.infRec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRetEnviCTe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetEnviCTe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TRetEnviCTe':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TRetEnviCTe')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TRetEnviCTe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TRetEnviCTe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versao), input_name='versao')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRetEnviCTe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.cUF is not None:
            namespaceprefix_ = self.cUF_nsprefix_ + ':' if (UseCapturedNS_ and self.cUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            namespaceprefix_ = self.verAplic_nsprefix_ + ':' if (UseCapturedNS_ and self.verAplic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.cStat is not None:
            namespaceprefix_ = self.cStat_nsprefix_ + ':' if (UseCapturedNS_ and self.cStat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            namespaceprefix_ = self.xMotivo_nsprefix_ + ':' if (UseCapturedNS_ and self.xMotivo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
        if self.infRec is not None:
            namespaceprefix_ = self.infRec_nsprefix_ + ':' if (UseCapturedNS_ and self.infRec_nsprefix_) else ''
            self.infRec.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infRec', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerCTe(self.versao)    # validate type TVerCTe
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'cUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cUF')
            value_ = self.gds_validate_string(value_, node, 'cUF')
            self.cUF = value_
            self.cUF_nsprefix_ = child_.prefix
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'verAplic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verAplic')
            value_ = self.gds_validate_string(value_, node, 'verAplic')
            self.verAplic = value_
            self.verAplic_nsprefix_ = child_.prefix
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'cStat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cStat')
            value_ = self.gds_validate_string(value_, node, 'cStat')
            self.cStat = value_
            self.cStat_nsprefix_ = child_.prefix
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMotivo')
            value_ = self.gds_validate_string(value_, node, 'xMotivo')
            self.xMotivo = value_
            self.xMotivo_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'infRec':
            obj_ = infRecType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infRec = obj_
            obj_.original_tagname_ = 'infRec'
# end class TRetEnviCTe


class TEndeEmi(GeneratedsSuper):
    """TEndeEmi -- Tipo Dados do Endere
    ç
    o
    xLgr -- Logradouro
    nro -- N
    ú
    mero
    xCpl -- Complemento
    xBairro -- Bairro
    cMun -- C
    ó
    digo do munic
    í
    pio (utilizar a tabela do IBGE)
    xMun -- Nome do munic
    í
    pio
    CEP -- CEP
    Informar zeros n
    ã
    o significativos
    UF -- Sigla da UF
    fone -- Telefone
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, fone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xLgr = xLgr
        self.validate_xLgrType(self.xLgr)
        self.xLgr_nsprefix_ = None
        self.nro = nro
        self.validate_nroType162(self.nro)
        self.nro_nsprefix_ = None
        self.xCpl = xCpl
        self.validate_xCplType(self.xCpl)
        self.xCpl_nsprefix_ = None
        self.xBairro = xBairro
        self.validate_xBairroType(self.xBairro)
        self.xBairro_nsprefix_ = None
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cMun_nsprefix_ = None
        self.xMun = xMun
        self.validate_xMunType(self.xMun)
        self.xMun_nsprefix_ = None
        self.CEP = CEP
        self.validate_CEPType(self.CEP)
        self.CEP_nsprefix_ = None
        self.UF = UF
        self.validate_TUF_sem_EX(self.UF)
        self.UF_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndeEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndeEmi.subclass:
            return TEndeEmi.subclass(*args_, **kwargs_)
        else:
            return TEndeEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xLgr(self):
        return self.xLgr
    def set_xLgr(self, xLgr):
        self.xLgr = xLgr
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_xCpl(self):
        return self.xCpl
    def set_xCpl(self, xCpl):
        self.xCpl = xCpl
    def get_xBairro(self):
        return self.xBairro
    def set_xBairro(self, xBairro):
        self.xBairro = xBairro
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_CEP(self):
        return self.CEP
    def set_CEP(self, CEP):
        self.CEP = CEP
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def validate_xLgrType(self, value):
        result = True
        # Validate type xLgrType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xLgrType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xLgrType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xLgrType_patterns_, ))
                result = False
        return result
    validate_xLgrType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nroType162(self, value):
        result = True
        # Validate type nroType162, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nroType162' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nroType162' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType162_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nroType162_patterns_, ))
                result = False
        return result
    validate_nroType162_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCplType(self, value):
        result = True
        # Validate type xCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCplType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCplType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCplType_patterns_, ))
                result = False
        return result
    validate_xCplType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xBairroType(self, value):
        result = True
        # Validate type xBairroType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xBairroType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xBairroType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xBairroType_patterns_, ))
                result = False
        return result
    validate_xBairroType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunType(self, value):
        result = True
        # Validate type xMunType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunType_patterns_, ))
                result = False
        return result
    validate_xMunType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_CEPType(self, value):
        result = True
        # Validate type CEPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CEPType_patterns_, ))
                result = False
        return result
    validate_CEPType_patterns_ = [['^([0-9]{8})$']]
    def validate_TUF_sem_EX(self, value):
        result = True
        # Validate type TUF_sem_EX, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUF_sem_EX' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def _hasContent(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndeEmi', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndeEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEndeEmi':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEndeEmi')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEndeEmi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEndeEmi'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndeEmi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            namespaceprefix_ = self.xLgr_nsprefix_ + ':' if (UseCapturedNS_ and self.xLgr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLgr>%s</%sxLgr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), namespaceprefix_ , eol_))
        if self.nro is not None:
            namespaceprefix_ = self.nro_nsprefix_ + ':' if (UseCapturedNS_ and self.nro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.xCpl is not None:
            namespaceprefix_ = self.xCpl_nsprefix_ + ':' if (UseCapturedNS_ and self.xCpl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCpl>%s</%sxCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), namespaceprefix_ , eol_))
        if self.xBairro is not None:
            namespaceprefix_ = self.xBairro_nsprefix_ + ':' if (UseCapturedNS_ and self.xBairro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxBairro>%s</%sxBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            namespaceprefix_ = self.cMun_nsprefix_ + ':' if (UseCapturedNS_ and self.cMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            namespaceprefix_ = self.xMun_nsprefix_ + ':' if (UseCapturedNS_ and self.xMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.CEP is not None:
            namespaceprefix_ = self.CEP_nsprefix_ + ':' if (UseCapturedNS_ and self.CEP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespaceprefix_ , eol_))
        if self.UF is not None:
            namespaceprefix_ = self.UF_nsprefix_ + ':' if (UseCapturedNS_ and self.UF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xLgr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xLgr')
            value_ = self.gds_validate_string(value_, node, 'xLgr')
            self.xLgr = value_
            self.xLgr_nsprefix_ = child_.prefix
            # validate type xLgrType
            self.validate_xLgrType(self.xLgr)
        elif nodeName_ == 'nro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nro')
            value_ = self.gds_validate_string(value_, node, 'nro')
            self.nro = value_
            self.nro_nsprefix_ = child_.prefix
            # validate type nroType162
            self.validate_nroType162(self.nro)
        elif nodeName_ == 'xCpl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCpl')
            value_ = self.gds_validate_string(value_, node, 'xCpl')
            self.xCpl = value_
            self.xCpl_nsprefix_ = child_.prefix
            # validate type xCplType
            self.validate_xCplType(self.xCpl)
        elif nodeName_ == 'xBairro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xBairro')
            value_ = self.gds_validate_string(value_, node, 'xBairro')
            self.xBairro = value_
            self.xBairro_nsprefix_ = child_.prefix
            # validate type xBairroType
            self.validate_xBairroType(self.xBairro)
        elif nodeName_ == 'cMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMun')
            value_ = self.gds_validate_string(value_, node, 'cMun')
            self.cMun = value_
            self.cMun_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMun')
            value_ = self.gds_validate_string(value_, node, 'xMun')
            self.xMun = value_
            self.xMun_nsprefix_ = child_.prefix
            # validate type xMunType
            self.validate_xMunType(self.xMun)
        elif nodeName_ == 'CEP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CEP')
            value_ = self.gds_validate_string(value_, node, 'CEP')
            self.CEP = value_
            self.CEP_nsprefix_ = child_.prefix
            # validate type CEPType
            self.validate_CEPType(self.CEP)
        elif nodeName_ == 'UF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UF')
            value_ = self.gds_validate_string(value_, node, 'UF')
            self.UF = value_
            self.UF_nsprefix_ = child_.prefix
            # validate type TUF_sem_EX
            self.validate_TUF_sem_EX(self.UF)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
# end class TEndeEmi


class TEndereco(GeneratedsSuper):
    """TEndereco -- Tipo Dados do Endere
    ç
    o
    xLgr -- Logradouro
    nro -- N
    ú
    mero
    xCpl -- Complemento
    xBairro -- Bairro
    cMun -- C
    ó
    digo do munic
    í
    pio (utilizar a tabela do IBGE)
    Informar 9999999 para opera
    ç
    õ
    es com o exterior.
    xMun -- Nome do munic
    í
    pio
    Informar EXTERIOR para opera
    ç
    õ
    es com o exterior.
    CEP -- CEP
    Informar os zeros n
    ã
    o significativos
    UF -- Sigla da UF
    Informar EX para opera
    ç
    õ
    es com o exterior.
    cPais -- C
    ó
    digo do pa
    í
    s
    Utilizar a tabela do BACEN
    xPais -- Nome do pa
    í
    s
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, cPais=None, xPais=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xLgr = xLgr
        self.validate_xLgrType163(self.xLgr)
        self.xLgr_nsprefix_ = None
        self.nro = nro
        self.validate_nroType164(self.nro)
        self.nro_nsprefix_ = None
        self.xCpl = xCpl
        self.validate_xCplType165(self.xCpl)
        self.xCpl_nsprefix_ = None
        self.xBairro = xBairro
        self.validate_xBairroType166(self.xBairro)
        self.xBairro_nsprefix_ = None
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cMun_nsprefix_ = None
        self.xMun = xMun
        self.validate_xMunType167(self.xMun)
        self.xMun_nsprefix_ = None
        self.CEP = CEP
        self.validate_CEPType168(self.CEP)
        self.CEP_nsprefix_ = None
        self.UF = UF
        self.validate_TUf(self.UF)
        self.UF_nsprefix_ = None
        self.cPais = cPais
        self.validate_cPaisType(self.cPais)
        self.cPais_nsprefix_ = None
        self.xPais = xPais
        self.validate_xPaisType(self.xPais)
        self.xPais_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndereco.subclass:
            return TEndereco.subclass(*args_, **kwargs_)
        else:
            return TEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xLgr(self):
        return self.xLgr
    def set_xLgr(self, xLgr):
        self.xLgr = xLgr
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_xCpl(self):
        return self.xCpl
    def set_xCpl(self, xCpl):
        self.xCpl = xCpl
    def get_xBairro(self):
        return self.xBairro
    def set_xBairro(self, xBairro):
        self.xBairro = xBairro
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_CEP(self):
        return self.CEP
    def set_CEP(self, CEP):
        self.CEP = CEP
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_cPais(self):
        return self.cPais
    def set_cPais(self, cPais):
        self.cPais = cPais
    def get_xPais(self):
        return self.xPais
    def set_xPais(self, xPais):
        self.xPais = xPais
    def validate_xLgrType163(self, value):
        result = True
        # Validate type xLgrType163, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xLgrType163' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xLgrType163' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType163_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xLgrType163_patterns_, ))
                result = False
        return result
    validate_xLgrType163_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nroType164(self, value):
        result = True
        # Validate type nroType164, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nroType164' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nroType164' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType164_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nroType164_patterns_, ))
                result = False
        return result
    validate_nroType164_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCplType165(self, value):
        result = True
        # Validate type xCplType165, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCplType165' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCplType165' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType165_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCplType165_patterns_, ))
                result = False
        return result
    validate_xCplType165_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xBairroType166(self, value):
        result = True
        # Validate type xBairroType166, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xBairroType166' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xBairroType166' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType166_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xBairroType166_patterns_, ))
                result = False
        return result
    validate_xBairroType166_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunType167(self, value):
        result = True
        # Validate type xMunType167, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunType167' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunType167' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType167_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunType167_patterns_, ))
                result = False
        return result
    validate_xMunType167_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_CEPType168(self, value):
        result = True
        # Validate type CEPType168, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType168_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CEPType168_patterns_, ))
                result = False
        return result
    validate_CEPType168_patterns_ = [['^([0-9]{8})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cPaisType(self, value):
        result = True
        # Validate type cPaisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cPaisType_patterns_, ))
                result = False
        return result
    validate_cPaisType_patterns_ = [['^([0-9]{1,4})$']]
    def validate_xPaisType(self, value):
        result = True
        # Validate type xPaisType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xPaisType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xPaisType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xPaisType_patterns_, ))
                result = False
        return result
    validate_xPaisType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.cPais is not None or
            self.xPais is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndereco', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEndereco':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEndereco')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEndereco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEndereco'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            namespaceprefix_ = self.xLgr_nsprefix_ + ':' if (UseCapturedNS_ and self.xLgr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLgr>%s</%sxLgr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), namespaceprefix_ , eol_))
        if self.nro is not None:
            namespaceprefix_ = self.nro_nsprefix_ + ':' if (UseCapturedNS_ and self.nro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.xCpl is not None:
            namespaceprefix_ = self.xCpl_nsprefix_ + ':' if (UseCapturedNS_ and self.xCpl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCpl>%s</%sxCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), namespaceprefix_ , eol_))
        if self.xBairro is not None:
            namespaceprefix_ = self.xBairro_nsprefix_ + ':' if (UseCapturedNS_ and self.xBairro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxBairro>%s</%sxBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            namespaceprefix_ = self.cMun_nsprefix_ + ':' if (UseCapturedNS_ and self.cMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            namespaceprefix_ = self.xMun_nsprefix_ + ':' if (UseCapturedNS_ and self.xMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.CEP is not None:
            namespaceprefix_ = self.CEP_nsprefix_ + ':' if (UseCapturedNS_ and self.CEP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespaceprefix_ , eol_))
        if self.UF is not None:
            namespaceprefix_ = self.UF_nsprefix_ + ':' if (UseCapturedNS_ and self.UF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.cPais is not None:
            namespaceprefix_ = self.cPais_nsprefix_ + ':' if (UseCapturedNS_ and self.cPais_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespaceprefix_ , eol_))
        if self.xPais is not None:
            namespaceprefix_ = self.xPais_nsprefix_ + ':' if (UseCapturedNS_ and self.xPais_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxPais>%s</%sxPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xLgr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xLgr')
            value_ = self.gds_validate_string(value_, node, 'xLgr')
            self.xLgr = value_
            self.xLgr_nsprefix_ = child_.prefix
            # validate type xLgrType163
            self.validate_xLgrType163(self.xLgr)
        elif nodeName_ == 'nro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nro')
            value_ = self.gds_validate_string(value_, node, 'nro')
            self.nro = value_
            self.nro_nsprefix_ = child_.prefix
            # validate type nroType164
            self.validate_nroType164(self.nro)
        elif nodeName_ == 'xCpl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCpl')
            value_ = self.gds_validate_string(value_, node, 'xCpl')
            self.xCpl = value_
            self.xCpl_nsprefix_ = child_.prefix
            # validate type xCplType165
            self.validate_xCplType165(self.xCpl)
        elif nodeName_ == 'xBairro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xBairro')
            value_ = self.gds_validate_string(value_, node, 'xBairro')
            self.xBairro = value_
            self.xBairro_nsprefix_ = child_.prefix
            # validate type xBairroType166
            self.validate_xBairroType166(self.xBairro)
        elif nodeName_ == 'cMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMun')
            value_ = self.gds_validate_string(value_, node, 'cMun')
            self.cMun = value_
            self.cMun_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMun')
            value_ = self.gds_validate_string(value_, node, 'xMun')
            self.xMun = value_
            self.xMun_nsprefix_ = child_.prefix
            # validate type xMunType167
            self.validate_xMunType167(self.xMun)
        elif nodeName_ == 'CEP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CEP')
            value_ = self.gds_validate_string(value_, node, 'CEP')
            self.CEP = value_
            self.CEP_nsprefix_ = child_.prefix
            # validate type CEPType168
            self.validate_CEPType168(self.CEP)
        elif nodeName_ == 'UF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UF')
            value_ = self.gds_validate_string(value_, node, 'UF')
            self.UF = value_
            self.UF_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'cPais':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cPais')
            value_ = self.gds_validate_string(value_, node, 'cPais')
            self.cPais = value_
            self.cPais_nsprefix_ = child_.prefix
            # validate type cPaisType
            self.validate_cPaisType(self.cPais)
        elif nodeName_ == 'xPais':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xPais')
            value_ = self.gds_validate_string(value_, node, 'xPais')
            self.xPais = value_
            self.xPais_nsprefix_ = child_.prefix
            # validate type xPaisType
            self.validate_xPaisType(self.xPais)
# end class TEndereco


class TEndernac(GeneratedsSuper):
    """TEndernac -- Tipo Dados do Endere
    ç
    o
    xLgr -- Logradouro
    nro -- N
    ú
    mero
    xCpl -- Complemento
    xBairro -- Bairro
    cMun -- C
    ó
    digo do munic
    í
    pio (utilizar a tabela do IBGE), informar 9999999 para opera
    ç
    õ
    es com o exterior.
    xMun -- Nome do munic
    í
    pio, , informar EXTERIOR para opera
    ç
    õ
    es com o exterior.
    CEP -- CEP
    UF -- Sigla da UF
    Informar EX para opera
    ç
    õ
    es com o exterior.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xLgr = xLgr
        self.validate_xLgrType169(self.xLgr)
        self.xLgr_nsprefix_ = None
        self.nro = nro
        self.validate_nroType170(self.nro)
        self.nro_nsprefix_ = None
        self.xCpl = xCpl
        self.validate_xCplType171(self.xCpl)
        self.xCpl_nsprefix_ = None
        self.xBairro = xBairro
        self.validate_xBairroType172(self.xBairro)
        self.xBairro_nsprefix_ = None
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cMun_nsprefix_ = None
        self.xMun = xMun
        self.validate_xMunType173(self.xMun)
        self.xMun_nsprefix_ = None
        self.CEP = CEP
        self.validate_CEPType174(self.CEP)
        self.CEP_nsprefix_ = None
        self.UF = UF
        self.validate_TUf(self.UF)
        self.UF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndernac)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndernac.subclass:
            return TEndernac.subclass(*args_, **kwargs_)
        else:
            return TEndernac(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xLgr(self):
        return self.xLgr
    def set_xLgr(self, xLgr):
        self.xLgr = xLgr
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_xCpl(self):
        return self.xCpl
    def set_xCpl(self, xCpl):
        self.xCpl = xCpl
    def get_xBairro(self):
        return self.xBairro
    def set_xBairro(self, xBairro):
        self.xBairro = xBairro
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_CEP(self):
        return self.CEP
    def set_CEP(self, CEP):
        self.CEP = CEP
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def validate_xLgrType169(self, value):
        result = True
        # Validate type xLgrType169, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xLgrType169' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xLgrType169' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType169_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xLgrType169_patterns_, ))
                result = False
        return result
    validate_xLgrType169_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nroType170(self, value):
        result = True
        # Validate type nroType170, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nroType170' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nroType170' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType170_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nroType170_patterns_, ))
                result = False
        return result
    validate_nroType170_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCplType171(self, value):
        result = True
        # Validate type xCplType171, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCplType171' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCplType171' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType171_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCplType171_patterns_, ))
                result = False
        return result
    validate_xCplType171_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xBairroType172(self, value):
        result = True
        # Validate type xBairroType172, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xBairroType172' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xBairroType172' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType172_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xBairroType172_patterns_, ))
                result = False
        return result
    validate_xBairroType172_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunType173(self, value):
        result = True
        # Validate type xMunType173, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunType173' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunType173' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType173_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunType173_patterns_, ))
                result = False
        return result
    validate_xMunType173_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_CEPType174(self, value):
        result = True
        # Validate type CEPType174, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType174_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CEPType174_patterns_, ))
                result = False
        return result
    validate_CEPType174_patterns_ = [['^([0-9]{8})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndernac', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndernac')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEndernac':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEndernac')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEndernac', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEndernac'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndernac', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            namespaceprefix_ = self.xLgr_nsprefix_ + ':' if (UseCapturedNS_ and self.xLgr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLgr>%s</%sxLgr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), namespaceprefix_ , eol_))
        if self.nro is not None:
            namespaceprefix_ = self.nro_nsprefix_ + ':' if (UseCapturedNS_ and self.nro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.xCpl is not None:
            namespaceprefix_ = self.xCpl_nsprefix_ + ':' if (UseCapturedNS_ and self.xCpl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCpl>%s</%sxCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), namespaceprefix_ , eol_))
        if self.xBairro is not None:
            namespaceprefix_ = self.xBairro_nsprefix_ + ':' if (UseCapturedNS_ and self.xBairro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxBairro>%s</%sxBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            namespaceprefix_ = self.cMun_nsprefix_ + ':' if (UseCapturedNS_ and self.cMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            namespaceprefix_ = self.xMun_nsprefix_ + ':' if (UseCapturedNS_ and self.xMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.CEP is not None:
            namespaceprefix_ = self.CEP_nsprefix_ + ':' if (UseCapturedNS_ and self.CEP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespaceprefix_ , eol_))
        if self.UF is not None:
            namespaceprefix_ = self.UF_nsprefix_ + ':' if (UseCapturedNS_ and self.UF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xLgr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xLgr')
            value_ = self.gds_validate_string(value_, node, 'xLgr')
            self.xLgr = value_
            self.xLgr_nsprefix_ = child_.prefix
            # validate type xLgrType169
            self.validate_xLgrType169(self.xLgr)
        elif nodeName_ == 'nro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nro')
            value_ = self.gds_validate_string(value_, node, 'nro')
            self.nro = value_
            self.nro_nsprefix_ = child_.prefix
            # validate type nroType170
            self.validate_nroType170(self.nro)
        elif nodeName_ == 'xCpl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCpl')
            value_ = self.gds_validate_string(value_, node, 'xCpl')
            self.xCpl = value_
            self.xCpl_nsprefix_ = child_.prefix
            # validate type xCplType171
            self.validate_xCplType171(self.xCpl)
        elif nodeName_ == 'xBairro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xBairro')
            value_ = self.gds_validate_string(value_, node, 'xBairro')
            self.xBairro = value_
            self.xBairro_nsprefix_ = child_.prefix
            # validate type xBairroType172
            self.validate_xBairroType172(self.xBairro)
        elif nodeName_ == 'cMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMun')
            value_ = self.gds_validate_string(value_, node, 'cMun')
            self.cMun = value_
            self.cMun_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMun')
            value_ = self.gds_validate_string(value_, node, 'xMun')
            self.xMun = value_
            self.xMun_nsprefix_ = child_.prefix
            # validate type xMunType173
            self.validate_xMunType173(self.xMun)
        elif nodeName_ == 'CEP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CEP')
            value_ = self.gds_validate_string(value_, node, 'CEP')
            self.CEP = value_
            self.CEP_nsprefix_ = child_.prefix
            # validate type CEPType174
            self.validate_CEPType174(self.CEP)
        elif nodeName_ == 'UF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UF')
            value_ = self.gds_validate_string(value_, node, 'UF')
            self.UF = value_
            self.UF_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TEndernac


class TEndOrg(GeneratedsSuper):
    """TEndOrg -- Tipo Dados do Endere
    ç
    o
    xLgr -- Logradouro
    nro -- N
    ú
    mero
    xCpl -- Complemento
    xBairro -- Bairro
    cMun -- C
    ó
    digo do munic
    í
    pio (utilizar a tabela do IBGE), informar 9999999 para opera
    ç
    õ
    es com o exterior.
    xMun -- Nome do munic
    í
    pio
    Informar EXTERIOR para opera
    ç
    õ
    es com o exterior.
    CEP -- CEP
    UF -- Sigla da UF
    Informar EX para opera
    ç
    õ
    es com o exterior.
    cPais -- C
    ó
    digo do pa
    í
    s
    xPais -- Nome do pa
    í
    s
    fone -- Telefone
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, CEP=None, UF=None, cPais=None, xPais=None, fone=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xLgr = xLgr
        self.validate_xLgrType175(self.xLgr)
        self.xLgr_nsprefix_ = None
        self.nro = nro
        self.validate_nroType176(self.nro)
        self.nro_nsprefix_ = None
        self.xCpl = xCpl
        self.validate_xCplType177(self.xCpl)
        self.xCpl_nsprefix_ = None
        self.xBairro = xBairro
        self.validate_xBairroType178(self.xBairro)
        self.xBairro_nsprefix_ = None
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cMun_nsprefix_ = None
        self.xMun = xMun
        self.validate_xMunType179(self.xMun)
        self.xMun_nsprefix_ = None
        self.CEP = CEP
        self.validate_CEPType180(self.CEP)
        self.CEP_nsprefix_ = None
        self.UF = UF
        self.validate_TUf(self.UF)
        self.UF_nsprefix_ = None
        self.cPais = cPais
        self.validate_cPaisType181(self.cPais)
        self.cPais_nsprefix_ = None
        self.xPais = xPais
        self.validate_xPaisType182(self.xPais)
        self.xPais_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndOrg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndOrg.subclass:
            return TEndOrg.subclass(*args_, **kwargs_)
        else:
            return TEndOrg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xLgr(self):
        return self.xLgr
    def set_xLgr(self, xLgr):
        self.xLgr = xLgr
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_xCpl(self):
        return self.xCpl
    def set_xCpl(self, xCpl):
        self.xCpl = xCpl
    def get_xBairro(self):
        return self.xBairro
    def set_xBairro(self, xBairro):
        self.xBairro = xBairro
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_CEP(self):
        return self.CEP
    def set_CEP(self, CEP):
        self.CEP = CEP
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_cPais(self):
        return self.cPais
    def set_cPais(self, cPais):
        self.cPais = cPais
    def get_xPais(self):
        return self.xPais
    def set_xPais(self, xPais):
        self.xPais = xPais
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def validate_xLgrType175(self, value):
        result = True
        # Validate type xLgrType175, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xLgrType175' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xLgrType175' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType175_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xLgrType175_patterns_, ))
                result = False
        return result
    validate_xLgrType175_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nroType176(self, value):
        result = True
        # Validate type nroType176, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nroType176' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nroType176' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType176_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nroType176_patterns_, ))
                result = False
        return result
    validate_nroType176_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCplType177(self, value):
        result = True
        # Validate type xCplType177, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCplType177' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCplType177' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType177_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCplType177_patterns_, ))
                result = False
        return result
    validate_xCplType177_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xBairroType178(self, value):
        result = True
        # Validate type xBairroType178, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xBairroType178' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xBairroType178' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType178_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xBairroType178_patterns_, ))
                result = False
        return result
    validate_xBairroType178_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunType179(self, value):
        result = True
        # Validate type xMunType179, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunType179' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunType179' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType179_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunType179_patterns_, ))
                result = False
        return result
    validate_xMunType179_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_CEPType180(self, value):
        result = True
        # Validate type CEPType180, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType180_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_CEPType180_patterns_, ))
                result = False
        return result
    validate_CEPType180_patterns_ = [['^([0-9]{8})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cPaisType181(self, value):
        result = True
        # Validate type cPaisType181, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType181_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cPaisType181_patterns_, ))
                result = False
        return result
    validate_cPaisType181_patterns_ = [['^([0-9]{1,4})$']]
    def validate_xPaisType182(self, value):
        result = True
        # Validate type xPaisType182, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xPaisType182' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xPaisType182' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType182_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xPaisType182_patterns_, ))
                result = False
        return result
    validate_xPaisType182_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def _hasContent(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.CEP is not None or
            self.UF is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndOrg', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndOrg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEndOrg':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEndOrg')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEndOrg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEndOrg'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndOrg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            namespaceprefix_ = self.xLgr_nsprefix_ + ':' if (UseCapturedNS_ and self.xLgr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLgr>%s</%sxLgr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), namespaceprefix_ , eol_))
        if self.nro is not None:
            namespaceprefix_ = self.nro_nsprefix_ + ':' if (UseCapturedNS_ and self.nro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.xCpl is not None:
            namespaceprefix_ = self.xCpl_nsprefix_ + ':' if (UseCapturedNS_ and self.xCpl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCpl>%s</%sxCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), namespaceprefix_ , eol_))
        if self.xBairro is not None:
            namespaceprefix_ = self.xBairro_nsprefix_ + ':' if (UseCapturedNS_ and self.xBairro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxBairro>%s</%sxBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            namespaceprefix_ = self.cMun_nsprefix_ + ':' if (UseCapturedNS_ and self.cMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            namespaceprefix_ = self.xMun_nsprefix_ + ':' if (UseCapturedNS_ and self.xMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.CEP is not None:
            namespaceprefix_ = self.CEP_nsprefix_ + ':' if (UseCapturedNS_ and self.CEP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespaceprefix_ , eol_))
        if self.UF is not None:
            namespaceprefix_ = self.UF_nsprefix_ + ':' if (UseCapturedNS_ and self.UF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.cPais is not None:
            namespaceprefix_ = self.cPais_nsprefix_ + ':' if (UseCapturedNS_ and self.cPais_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespaceprefix_ , eol_))
        if self.xPais is not None:
            namespaceprefix_ = self.xPais_nsprefix_ + ':' if (UseCapturedNS_ and self.xPais_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxPais>%s</%sxPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xLgr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xLgr')
            value_ = self.gds_validate_string(value_, node, 'xLgr')
            self.xLgr = value_
            self.xLgr_nsprefix_ = child_.prefix
            # validate type xLgrType175
            self.validate_xLgrType175(self.xLgr)
        elif nodeName_ == 'nro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nro')
            value_ = self.gds_validate_string(value_, node, 'nro')
            self.nro = value_
            self.nro_nsprefix_ = child_.prefix
            # validate type nroType176
            self.validate_nroType176(self.nro)
        elif nodeName_ == 'xCpl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCpl')
            value_ = self.gds_validate_string(value_, node, 'xCpl')
            self.xCpl = value_
            self.xCpl_nsprefix_ = child_.prefix
            # validate type xCplType177
            self.validate_xCplType177(self.xCpl)
        elif nodeName_ == 'xBairro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xBairro')
            value_ = self.gds_validate_string(value_, node, 'xBairro')
            self.xBairro = value_
            self.xBairro_nsprefix_ = child_.prefix
            # validate type xBairroType178
            self.validate_xBairroType178(self.xBairro)
        elif nodeName_ == 'cMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMun')
            value_ = self.gds_validate_string(value_, node, 'cMun')
            self.cMun = value_
            self.cMun_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMun')
            value_ = self.gds_validate_string(value_, node, 'xMun')
            self.xMun = value_
            self.xMun_nsprefix_ = child_.prefix
            # validate type xMunType179
            self.validate_xMunType179(self.xMun)
        elif nodeName_ == 'CEP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CEP')
            value_ = self.gds_validate_string(value_, node, 'CEP')
            self.CEP = value_
            self.CEP_nsprefix_ = child_.prefix
            # validate type CEPType180
            self.validate_CEPType180(self.CEP)
        elif nodeName_ == 'UF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UF')
            value_ = self.gds_validate_string(value_, node, 'UF')
            self.UF = value_
            self.UF_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'cPais':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cPais')
            value_ = self.gds_validate_string(value_, node, 'cPais')
            self.cPais = value_
            self.cPais_nsprefix_ = child_.prefix
            # validate type cPaisType181
            self.validate_cPaisType181(self.cPais)
        elif nodeName_ == 'xPais':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xPais')
            value_ = self.gds_validate_string(value_, node, 'xPais')
            self.xPais = value_
            self.xPais_nsprefix_ = child_.prefix
            # validate type xPaisType182
            self.validate_xPaisType182(self.xPais)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
# end class TEndOrg


class TLocal(GeneratedsSuper):
    """TLocal -- Tipo Dados do Local de Origem ou Destino
    cMun -- C
    ó
    digo do munic
    í
    pio (utilizar a tabela do IBGE)
    xMun -- Nome do munic
    í
    pio
    UF -- Sigla da UF
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cMun=None, xMun=None, UF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cMun_nsprefix_ = None
        self.xMun = xMun
        self.validate_xMunType183(self.xMun)
        self.xMun_nsprefix_ = None
        self.UF = UF
        self.validate_TUf(self.UF)
        self.UF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TLocal.subclass:
            return TLocal.subclass(*args_, **kwargs_)
        else:
            return TLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunType183(self, value):
        result = True
        # Validate type xMunType183, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunType183' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunType183' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType183_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunType183_patterns_, ))
                result = False
        return result
    validate_xMunType183_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TLocal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TLocal':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TLocal')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TLocal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TLocal'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMun is not None:
            namespaceprefix_ = self.cMun_nsprefix_ + ':' if (UseCapturedNS_ and self.cMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            namespaceprefix_ = self.xMun_nsprefix_ + ':' if (UseCapturedNS_ and self.xMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.UF is not None:
            namespaceprefix_ = self.UF_nsprefix_ + ':' if (UseCapturedNS_ and self.UF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMun')
            value_ = self.gds_validate_string(value_, node, 'cMun')
            self.cMun = value_
            self.cMun_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMun')
            value_ = self.gds_validate_string(value_, node, 'xMun')
            self.xMun = value_
            self.xMun_nsprefix_ = child_.prefix
            # validate type xMunType183
            self.validate_xMunType183(self.xMun)
        elif nodeName_ == 'UF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UF')
            value_ = self.gds_validate_string(value_, node, 'UF')
            self.UF = value_
            self.UF_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TLocal


class TEndReEnt(GeneratedsSuper):
    """TEndReEnt --  Tipo Dados do Local de Retirada ou Entrega
    CNPJ -- N
    ú
    mero do CNPJ
    CPF -- N
    ú
    mero do CPF
    xNome -- Raz
    ã
    o Social ou Nome
    xLgr -- Logradouro
    nro -- N
    ú
    mero
    xCpl -- Complemento
    xBairro -- Bairro
    cMun -- C
    ó
    digo do munic
    í
    pio (utilizar a tabela do IBGE)
    Informar 9999999 para opera
    ç
    õ
    es com o exterior.
    xMun -- Nome do munic
    í
    pio
    Informar EXTERIOR para opera
    ç
    õ
    es com o exterior.
    UF -- Sigla da UF
    Informar EX para opera
    ç
    õ
    es com o exterior.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType184(self.xNome)
        self.xNome_nsprefix_ = None
        self.xLgr = xLgr
        self.validate_xLgrType185(self.xLgr)
        self.xLgr_nsprefix_ = None
        self.nro = nro
        self.validate_nroType186(self.nro)
        self.nro_nsprefix_ = None
        self.xCpl = xCpl
        self.validate_xCplType187(self.xCpl)
        self.xCpl_nsprefix_ = None
        self.xBairro = xBairro
        self.validate_xBairroType188(self.xBairro)
        self.xBairro_nsprefix_ = None
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cMun_nsprefix_ = None
        self.xMun = xMun
        self.validate_xMunType189(self.xMun)
        self.xMun_nsprefix_ = None
        self.UF = UF
        self.validate_TUf(self.UF)
        self.UF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndReEnt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndReEnt.subclass:
            return TEndReEnt.subclass(*args_, **kwargs_)
        else:
            return TEndReEnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xLgr(self):
        return self.xLgr
    def set_xLgr(self, xLgr):
        self.xLgr = xLgr
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_xCpl(self):
        return self.xCpl
    def set_xCpl(self, xCpl):
        self.xCpl = xCpl
    def get_xBairro(self):
        return self.xBairro
    def set_xBairro(self, xBairro):
        self.xBairro = xBairro
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_xNomeType184(self, value):
        result = True
        # Validate type xNomeType184, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType184' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType184' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType184_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType184_patterns_, ))
                result = False
        return result
    validate_xNomeType184_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xLgrType185(self, value):
        result = True
        # Validate type xLgrType185, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xLgrType185' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xLgrType185' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType185_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xLgrType185_patterns_, ))
                result = False
        return result
    validate_xLgrType185_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nroType186(self, value):
        result = True
        # Validate type nroType186, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nroType186' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nroType186' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType186_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nroType186_patterns_, ))
                result = False
        return result
    validate_nroType186_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCplType187(self, value):
        result = True
        # Validate type xCplType187, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCplType187' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCplType187' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType187_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCplType187_patterns_, ))
                result = False
        return result
    validate_xCplType187_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xBairroType188(self, value):
        result = True
        # Validate type xBairroType188, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xBairroType188' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xBairroType188' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType188_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xBairroType188_patterns_, ))
                result = False
        return result
    validate_xBairroType188_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunType189(self, value):
        result = True
        # Validate type xMunType189, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunType189' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunType189' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType189_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunType189_patterns_, ))
                result = False
        return result
    validate_xMunType189_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndReEnt', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndReEnt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEndReEnt':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEndReEnt')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEndReEnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEndReEnt'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TEndReEnt', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xLgr is not None:
            namespaceprefix_ = self.xLgr_nsprefix_ + ':' if (UseCapturedNS_ and self.xLgr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLgr>%s</%sxLgr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), namespaceprefix_ , eol_))
        if self.nro is not None:
            namespaceprefix_ = self.nro_nsprefix_ + ':' if (UseCapturedNS_ and self.nro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.xCpl is not None:
            namespaceprefix_ = self.xCpl_nsprefix_ + ':' if (UseCapturedNS_ and self.xCpl_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCpl>%s</%sxCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), namespaceprefix_ , eol_))
        if self.xBairro is not None:
            namespaceprefix_ = self.xBairro_nsprefix_ + ':' if (UseCapturedNS_ and self.xBairro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxBairro>%s</%sxBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            namespaceprefix_ = self.cMun_nsprefix_ + ':' if (UseCapturedNS_ and self.cMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            namespaceprefix_ = self.xMun_nsprefix_ + ':' if (UseCapturedNS_ and self.xMun_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.UF is not None:
            namespaceprefix_ = self.UF_nsprefix_ + ':' if (UseCapturedNS_ and self.UF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType184
            self.validate_xNomeType184(self.xNome)
        elif nodeName_ == 'xLgr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xLgr')
            value_ = self.gds_validate_string(value_, node, 'xLgr')
            self.xLgr = value_
            self.xLgr_nsprefix_ = child_.prefix
            # validate type xLgrType185
            self.validate_xLgrType185(self.xLgr)
        elif nodeName_ == 'nro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nro')
            value_ = self.gds_validate_string(value_, node, 'nro')
            self.nro = value_
            self.nro_nsprefix_ = child_.prefix
            # validate type nroType186
            self.validate_nroType186(self.nro)
        elif nodeName_ == 'xCpl':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCpl')
            value_ = self.gds_validate_string(value_, node, 'xCpl')
            self.xCpl = value_
            self.xCpl_nsprefix_ = child_.prefix
            # validate type xCplType187
            self.validate_xCplType187(self.xCpl)
        elif nodeName_ == 'xBairro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xBairro')
            value_ = self.gds_validate_string(value_, node, 'xBairro')
            self.xBairro = value_
            self.xBairro_nsprefix_ = child_.prefix
            # validate type xBairroType188
            self.validate_xBairroType188(self.xBairro)
        elif nodeName_ == 'cMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMun')
            value_ = self.gds_validate_string(value_, node, 'cMun')
            self.cMun = value_
            self.cMun_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMun')
            value_ = self.gds_validate_string(value_, node, 'xMun')
            self.xMun = value_
            self.xMun_nsprefix_ = child_.prefix
            # validate type xMunType189
            self.validate_xMunType189(self.xMun)
        elif nodeName_ == 'UF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UF')
            value_ = self.gds_validate_string(value_, node, 'UF')
            self.UF = value_
            self.UF_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TEndReEnt


class TImp(GeneratedsSuper):
    """TImp -- Tipo Dados do Imposto CT-e
    ICMS00 -- Presta
    ç
    ã
    o sujeito
    à
    tributa
    ç
    ã
    o normal do ICMS
    ICMS20 -- Presta
    ç
    ã
    o sujeito
    à
    tributa
    ç
    ã
    o com redu
    ç
    ã
    o de BC do ICMS
    ICMS45 -- ICMS  Isento, n
    ã
    o Tributado ou diferido
    ICMS60 -- Tributa
    ç
    ã
    o pelo ICMS60 - ICMS cobrado por substitui
    ç
    ã
    o tribut
    á
    ria.Responsabilidade do recolhimento do ICMS atribu
    í
    do ao tomador ou 3
    º
    por ST
    ICMS90 -- ICMS Outros
    ICMSOutraUF -- ICMS devido
    à
    UF de origem da presta
    ç
    ã
    o, quando  diferente da UF do emitente
    ICMSSN -- Simples Nacional
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ICMS00=None, ICMS20=None, ICMS45=None, ICMS60=None, ICMS90=None, ICMSOutraUF=None, ICMSSN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ICMS00 = ICMS00
        self.ICMS00_nsprefix_ = None
        self.ICMS20 = ICMS20
        self.ICMS20_nsprefix_ = None
        self.ICMS45 = ICMS45
        self.ICMS45_nsprefix_ = None
        self.ICMS60 = ICMS60
        self.ICMS60_nsprefix_ = None
        self.ICMS90 = ICMS90
        self.ICMS90_nsprefix_ = None
        self.ICMSOutraUF = ICMSOutraUF
        self.ICMSOutraUF_nsprefix_ = None
        self.ICMSSN = ICMSSN
        self.ICMSSN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TImp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TImp.subclass:
            return TImp.subclass(*args_, **kwargs_)
        else:
            return TImp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ICMS00(self):
        return self.ICMS00
    def set_ICMS00(self, ICMS00):
        self.ICMS00 = ICMS00
    def get_ICMS20(self):
        return self.ICMS20
    def set_ICMS20(self, ICMS20):
        self.ICMS20 = ICMS20
    def get_ICMS45(self):
        return self.ICMS45
    def set_ICMS45(self, ICMS45):
        self.ICMS45 = ICMS45
    def get_ICMS60(self):
        return self.ICMS60
    def set_ICMS60(self, ICMS60):
        self.ICMS60 = ICMS60
    def get_ICMS90(self):
        return self.ICMS90
    def set_ICMS90(self, ICMS90):
        self.ICMS90 = ICMS90
    def get_ICMSOutraUF(self):
        return self.ICMSOutraUF
    def set_ICMSOutraUF(self, ICMSOutraUF):
        self.ICMSOutraUF = ICMSOutraUF
    def get_ICMSSN(self):
        return self.ICMSSN
    def set_ICMSSN(self, ICMSSN):
        self.ICMSSN = ICMSSN
    def _hasContent(self):
        if (
            self.ICMS00 is not None or
            self.ICMS20 is not None or
            self.ICMS45 is not None or
            self.ICMS60 is not None or
            self.ICMS90 is not None or
            self.ICMSOutraUF is not None or
            self.ICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TImp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TImp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TImp':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TImp')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TImp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TImp'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TImp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS00 is not None:
            namespaceprefix_ = self.ICMS00_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS00_nsprefix_) else ''
            self.ICMS00.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS00', pretty_print=pretty_print)
        if self.ICMS20 is not None:
            namespaceprefix_ = self.ICMS20_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS20_nsprefix_) else ''
            self.ICMS20.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS20', pretty_print=pretty_print)
        if self.ICMS45 is not None:
            namespaceprefix_ = self.ICMS45_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS45_nsprefix_) else ''
            self.ICMS45.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS45', pretty_print=pretty_print)
        if self.ICMS60 is not None:
            namespaceprefix_ = self.ICMS60_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS60_nsprefix_) else ''
            self.ICMS60.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS60', pretty_print=pretty_print)
        if self.ICMS90 is not None:
            namespaceprefix_ = self.ICMS90_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS90_nsprefix_) else ''
            self.ICMS90.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS90', pretty_print=pretty_print)
        if self.ICMSOutraUF is not None:
            namespaceprefix_ = self.ICMSOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMSOutraUF_nsprefix_) else ''
            self.ICMSOutraUF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSOutraUF', pretty_print=pretty_print)
        if self.ICMSSN is not None:
            namespaceprefix_ = self.ICMSSN_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMSSN_nsprefix_) else ''
            self.ICMSSN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSSN', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ICMS00':
            obj_ = ICMS00Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS00 = obj_
            obj_.original_tagname_ = 'ICMS00'
        elif nodeName_ == 'ICMS20':
            obj_ = ICMS20Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS20 = obj_
            obj_.original_tagname_ = 'ICMS20'
        elif nodeName_ == 'ICMS45':
            obj_ = ICMS45Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS45 = obj_
            obj_.original_tagname_ = 'ICMS45'
        elif nodeName_ == 'ICMS60':
            obj_ = ICMS60Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS60 = obj_
            obj_.original_tagname_ = 'ICMS60'
        elif nodeName_ == 'ICMS90':
            obj_ = ICMS90Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS90 = obj_
            obj_.original_tagname_ = 'ICMS90'
        elif nodeName_ == 'ICMSOutraUF':
            obj_ = ICMSOutraUFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMSOutraUF = obj_
            obj_.original_tagname_ = 'ICMSOutraUF'
        elif nodeName_ == 'ICMSSN':
            obj_ = ICMSSNType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMSSN = obj_
            obj_.original_tagname_ = 'ICMSSN'
# end class TImp


class TImpOS(GeneratedsSuper):
    """TImpOS -- Tipo Dados do Imposto para CT-e OS
    ICMS00 -- Presta
    ç
    ã
    o sujeito
    à
    tributa
    ç
    ã
    o normal do ICMS
    ICMS20 -- Presta
    ç
    ã
    o sujeito
    à
    tributa
    ç
    ã
    o com redu
    ç
    ã
    o de BC do ICMS
    ICMS45 -- ICMS  Isento, n
    ã
    o Tributado ou diferido
    ICMS90 -- ICMS Outros
    ICMSOutraUF -- ICMS devido
    à
    UF de origem da presta
    ç
    ã
    o, quando  diferente da UF do emitente
    ICMSSN -- Simples Nacional
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ICMS00=None, ICMS20=None, ICMS45=None, ICMS90=None, ICMSOutraUF=None, ICMSSN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ICMS00 = ICMS00
        self.ICMS00_nsprefix_ = None
        self.ICMS20 = ICMS20
        self.ICMS20_nsprefix_ = None
        self.ICMS45 = ICMS45
        self.ICMS45_nsprefix_ = None
        self.ICMS90 = ICMS90
        self.ICMS90_nsprefix_ = None
        self.ICMSOutraUF = ICMSOutraUF
        self.ICMSOutraUF_nsprefix_ = None
        self.ICMSSN = ICMSSN
        self.ICMSSN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TImpOS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TImpOS.subclass:
            return TImpOS.subclass(*args_, **kwargs_)
        else:
            return TImpOS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ICMS00(self):
        return self.ICMS00
    def set_ICMS00(self, ICMS00):
        self.ICMS00 = ICMS00
    def get_ICMS20(self):
        return self.ICMS20
    def set_ICMS20(self, ICMS20):
        self.ICMS20 = ICMS20
    def get_ICMS45(self):
        return self.ICMS45
    def set_ICMS45(self, ICMS45):
        self.ICMS45 = ICMS45
    def get_ICMS90(self):
        return self.ICMS90
    def set_ICMS90(self, ICMS90):
        self.ICMS90 = ICMS90
    def get_ICMSOutraUF(self):
        return self.ICMSOutraUF
    def set_ICMSOutraUF(self, ICMSOutraUF):
        self.ICMSOutraUF = ICMSOutraUF
    def get_ICMSSN(self):
        return self.ICMSSN
    def set_ICMSSN(self, ICMSSN):
        self.ICMSSN = ICMSSN
    def _hasContent(self):
        if (
            self.ICMS00 is not None or
            self.ICMS20 is not None or
            self.ICMS45 is not None or
            self.ICMS90 is not None or
            self.ICMSOutraUF is not None or
            self.ICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TImpOS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TImpOS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TImpOS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TImpOS')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TImpOS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TImpOS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TImpOS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS00 is not None:
            namespaceprefix_ = self.ICMS00_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS00_nsprefix_) else ''
            self.ICMS00.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS00', pretty_print=pretty_print)
        if self.ICMS20 is not None:
            namespaceprefix_ = self.ICMS20_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS20_nsprefix_) else ''
            self.ICMS20.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS20', pretty_print=pretty_print)
        if self.ICMS45 is not None:
            namespaceprefix_ = self.ICMS45_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS45_nsprefix_) else ''
            self.ICMS45.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS45', pretty_print=pretty_print)
        if self.ICMS90 is not None:
            namespaceprefix_ = self.ICMS90_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS90_nsprefix_) else ''
            self.ICMS90.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS90', pretty_print=pretty_print)
        if self.ICMSOutraUF is not None:
            namespaceprefix_ = self.ICMSOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMSOutraUF_nsprefix_) else ''
            self.ICMSOutraUF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSOutraUF', pretty_print=pretty_print)
        if self.ICMSSN is not None:
            namespaceprefix_ = self.ICMSSN_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMSSN_nsprefix_) else ''
            self.ICMSSN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSSN', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ICMS00':
            obj_ = ICMS00Type196.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS00 = obj_
            obj_.original_tagname_ = 'ICMS00'
        elif nodeName_ == 'ICMS20':
            obj_ = ICMS20Type198.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS20 = obj_
            obj_.original_tagname_ = 'ICMS20'
        elif nodeName_ == 'ICMS45':
            obj_ = ICMS45Type200.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS45 = obj_
            obj_.original_tagname_ = 'ICMS45'
        elif nodeName_ == 'ICMS90':
            obj_ = ICMS90Type202.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS90 = obj_
            obj_.original_tagname_ = 'ICMS90'
        elif nodeName_ == 'ICMSOutraUF':
            obj_ = ICMSOutraUFType204.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMSOutraUF = obj_
            obj_.original_tagname_ = 'ICMSOutraUF'
        elif nodeName_ == 'ICMSSN':
            obj_ = ICMSSNType206.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMSSN = obj_
            obj_.original_tagname_ = 'ICMSSN'
# end class TImpOS


class TUnidadeTransp(GeneratedsSuper):
    """TUnidadeTransp -- Tipo Dados Unidade de Transporte
    tpUnidTransp -- Tipo da Unidade de Transporte
    1 - Rodovi
    á
    rio Tra
    ç
    ã
    o
    2 - Rodovi
    á
    rio Reboque
    3 - Navio
    4 - Balsa
    5 - Aeronave
    6 - Vag
    ã
    o
    7 - Outros
    idUnidTransp -- Identifica
    ç
    ã
    o da Unidade de Transporte
    Informar a identifica
    ç
    ã
    o conforme o tipo de unidade de transporte.
    Por exemplo: para rodovi
    á
    rio tra
    ç
    ã
    o ou reboque dever
    á
    preencher com a placa do ve
    í
    culo.
      
    * lacUnidTransp -- Lacres das Unidades de Transporte
    * infUnidCarga -- Informa
      ç
      õ
      es das Unidades de Carga (Containeres/ULD/Outros)
      Dispositivo de carga utilizada (Unit Load Device - ULD) significa todo tipo de cont
      ê
      iner de carga, vag
      ã
      o, cont
      ê
      iner de avi
      ã
      o, palete de aeronave com rede ou palete de aeronave com rede sobre um iglu.
    * qtdRat -- Quantidade rateada (Peso,Volume)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpUnidTransp=None, idUnidTransp=None, lacUnidTransp=None, infUnidCarga=None, qtdRat=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpUnidTransp = tpUnidTransp
        self.validate_TtipoUnidTransp(self.tpUnidTransp)
        self.tpUnidTransp_nsprefix_ = None
        self.idUnidTransp = idUnidTransp
        self.validate_TContainer(self.idUnidTransp)
        self.idUnidTransp_nsprefix_ = None
        if lacUnidTransp is None:
            self.lacUnidTransp = []
        else:
            self.lacUnidTransp = lacUnidTransp
        self.lacUnidTransp_nsprefix_ = None
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        self.infUnidCarga_nsprefix_ = None
        self.qtdRat = qtdRat
        self.validate_TDec_0302_0303(self.qtdRat)
        self.qtdRat_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TUnidadeTransp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TUnidadeTransp.subclass:
            return TUnidadeTransp.subclass(*args_, **kwargs_)
        else:
            return TUnidadeTransp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpUnidTransp(self):
        return self.tpUnidTransp
    def set_tpUnidTransp(self, tpUnidTransp):
        self.tpUnidTransp = tpUnidTransp
    def get_idUnidTransp(self):
        return self.idUnidTransp
    def set_idUnidTransp(self, idUnidTransp):
        self.idUnidTransp = idUnidTransp
    def get_lacUnidTransp(self):
        return self.lacUnidTransp
    def set_lacUnidTransp(self, lacUnidTransp):
        self.lacUnidTransp = lacUnidTransp
    def add_lacUnidTransp(self, value):
        self.lacUnidTransp.append(value)
    def insert_lacUnidTransp_at(self, index, value):
        self.lacUnidTransp.insert(index, value)
    def replace_lacUnidTransp_at(self, index, value):
        self.lacUnidTransp[index] = value
    def get_infUnidCarga(self):
        return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga):
        self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value):
        self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value):
        self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value):
        self.infUnidCarga[index] = value
    def get_qtdRat(self):
        return self.qtdRat
    def set_qtdRat(self, qtdRat):
        self.qtdRat = qtdRat
    def validate_TtipoUnidTransp(self, value):
        result = True
        # Validate type TtipoUnidTransp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3', '4', '5', '6', '7']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TtipoUnidTransp' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TContainer(self, value):
        result = True
        # Validate type TContainer, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TContainer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TContainer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TContainer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TContainer_patterns_, ))
                result = False
        return result
    validate_TContainer_patterns_ = [['^([A-Z0-9]+)$']]
    def validate_TDec_0302_0303(self, value):
        result = True
        # Validate type TDec_0302_0303, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_0303_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_0303_patterns_, ))
                result = False
        return result
    validate_TDec_0302_0303_patterns_ = [['^([0-9]{1,3}(\\.[0-9]{2,3})?)$']]
    def _hasContent(self):
        if (
            self.tpUnidTransp is not None or
            self.idUnidTransp is not None or
            self.lacUnidTransp or
            self.infUnidCarga or
            self.qtdRat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TUnidadeTransp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TUnidadeTransp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TUnidadeTransp':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TUnidadeTransp')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TUnidadeTransp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TUnidadeTransp'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TUnidadeTransp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpUnidTransp is not None:
            namespaceprefix_ = self.tpUnidTransp_nsprefix_ + ':' if (UseCapturedNS_ and self.tpUnidTransp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpUnidTransp>%s</%stpUnidTransp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpUnidTransp), input_name='tpUnidTransp')), namespaceprefix_ , eol_))
        if self.idUnidTransp is not None:
            namespaceprefix_ = self.idUnidTransp_nsprefix_ + ':' if (UseCapturedNS_ and self.idUnidTransp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidUnidTransp>%s</%sidUnidTransp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.idUnidTransp), input_name='idUnidTransp')), namespaceprefix_ , eol_))
        for lacUnidTransp_ in self.lacUnidTransp:
            namespaceprefix_ = self.lacUnidTransp_nsprefix_ + ':' if (UseCapturedNS_ and self.lacUnidTransp_nsprefix_) else ''
            lacUnidTransp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lacUnidTransp', pretty_print=pretty_print)
        for infUnidCarga_ in self.infUnidCarga:
            namespaceprefix_ = self.infUnidCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.infUnidCarga_nsprefix_) else ''
            infUnidCarga_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infUnidCarga', pretty_print=pretty_print)
        if self.qtdRat is not None:
            namespaceprefix_ = self.qtdRat_nsprefix_ + ':' if (UseCapturedNS_ and self.qtdRat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdRat>%s</%sqtdRat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qtdRat), input_name='qtdRat')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpUnidTransp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpUnidTransp')
            value_ = self.gds_validate_string(value_, node, 'tpUnidTransp')
            self.tpUnidTransp = value_
            self.tpUnidTransp_nsprefix_ = child_.prefix
            # validate type TtipoUnidTransp
            self.validate_TtipoUnidTransp(self.tpUnidTransp)
        elif nodeName_ == 'idUnidTransp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'idUnidTransp')
            value_ = self.gds_validate_string(value_, node, 'idUnidTransp')
            self.idUnidTransp = value_
            self.idUnidTransp_nsprefix_ = child_.prefix
            # validate type TContainer
            self.validate_TContainer(self.idUnidTransp)
        elif nodeName_ == 'lacUnidTransp':
            obj_ = lacUnidTranspType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lacUnidTransp.append(obj_)
            obj_.original_tagname_ = 'lacUnidTransp'
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'qtdRat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qtdRat')
            value_ = self.gds_validate_string(value_, node, 'qtdRat')
            self.qtdRat = value_
            self.qtdRat_nsprefix_ = child_.prefix
            # validate type TDec_0302_0303
            self.validate_TDec_0302_0303(self.qtdRat)
# end class TUnidadeTransp


class TUnidCarga(GeneratedsSuper):
    """TUnidCarga -- Tipo Dados Unidade de Carga
    tpUnidCarga -- Tipo da Unidade de Carga
    1 - Container
    2 - ULD
    3 - Pallet
    4 - Outros
    idUnidCarga -- Identifica
    ç
    ã
    o da Unidade de Carga
    Informar a identifica
    ç
    ã
    o da unidade de carga, por exemplo: n
    ú
    mero do container.
    lacUnidCarga -- Lacres das Unidades de Carga
    qtdRat -- Quantidade rateada (Peso,Volume)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpUnidCarga=None, idUnidCarga=None, lacUnidCarga=None, qtdRat=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpUnidCarga = tpUnidCarga
        self.validate_TtipoUnidCarga(self.tpUnidCarga)
        self.tpUnidCarga_nsprefix_ = None
        self.idUnidCarga = idUnidCarga
        self.validate_TContainer(self.idUnidCarga)
        self.idUnidCarga_nsprefix_ = None
        if lacUnidCarga is None:
            self.lacUnidCarga = []
        else:
            self.lacUnidCarga = lacUnidCarga
        self.lacUnidCarga_nsprefix_ = None
        self.qtdRat = qtdRat
        self.validate_TDec_0302_0303(self.qtdRat)
        self.qtdRat_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TUnidCarga)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TUnidCarga.subclass:
            return TUnidCarga.subclass(*args_, **kwargs_)
        else:
            return TUnidCarga(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpUnidCarga(self):
        return self.tpUnidCarga
    def set_tpUnidCarga(self, tpUnidCarga):
        self.tpUnidCarga = tpUnidCarga
    def get_idUnidCarga(self):
        return self.idUnidCarga
    def set_idUnidCarga(self, idUnidCarga):
        self.idUnidCarga = idUnidCarga
    def get_lacUnidCarga(self):
        return self.lacUnidCarga
    def set_lacUnidCarga(self, lacUnidCarga):
        self.lacUnidCarga = lacUnidCarga
    def add_lacUnidCarga(self, value):
        self.lacUnidCarga.append(value)
    def insert_lacUnidCarga_at(self, index, value):
        self.lacUnidCarga.insert(index, value)
    def replace_lacUnidCarga_at(self, index, value):
        self.lacUnidCarga[index] = value
    def get_qtdRat(self):
        return self.qtdRat
    def set_qtdRat(self, qtdRat):
        self.qtdRat = qtdRat
    def validate_TtipoUnidCarga(self, value):
        result = True
        # Validate type TtipoUnidCarga, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3', '4']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TtipoUnidCarga' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TContainer(self, value):
        result = True
        # Validate type TContainer, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TContainer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TContainer' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TContainer_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TContainer_patterns_, ))
                result = False
        return result
    validate_TContainer_patterns_ = [['^([A-Z0-9]+)$']]
    def validate_TDec_0302_0303(self, value):
        result = True
        # Validate type TDec_0302_0303, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_0303_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_0303_patterns_, ))
                result = False
        return result
    validate_TDec_0302_0303_patterns_ = [['^([0-9]{1,3}(\\.[0-9]{2,3})?)$']]
    def _hasContent(self):
        if (
            self.tpUnidCarga is not None or
            self.idUnidCarga is not None or
            self.lacUnidCarga or
            self.qtdRat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TUnidCarga', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TUnidCarga')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TUnidCarga':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TUnidCarga')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TUnidCarga', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TUnidCarga'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TUnidCarga', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpUnidCarga is not None:
            namespaceprefix_ = self.tpUnidCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.tpUnidCarga_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpUnidCarga>%s</%stpUnidCarga>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpUnidCarga), input_name='tpUnidCarga')), namespaceprefix_ , eol_))
        if self.idUnidCarga is not None:
            namespaceprefix_ = self.idUnidCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.idUnidCarga_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidUnidCarga>%s</%sidUnidCarga>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.idUnidCarga), input_name='idUnidCarga')), namespaceprefix_ , eol_))
        for lacUnidCarga_ in self.lacUnidCarga:
            namespaceprefix_ = self.lacUnidCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.lacUnidCarga_nsprefix_) else ''
            lacUnidCarga_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lacUnidCarga', pretty_print=pretty_print)
        if self.qtdRat is not None:
            namespaceprefix_ = self.qtdRat_nsprefix_ + ':' if (UseCapturedNS_ and self.qtdRat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtdRat>%s</%sqtdRat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qtdRat), input_name='qtdRat')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpUnidCarga':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpUnidCarga')
            value_ = self.gds_validate_string(value_, node, 'tpUnidCarga')
            self.tpUnidCarga = value_
            self.tpUnidCarga_nsprefix_ = child_.prefix
            # validate type TtipoUnidCarga
            self.validate_TtipoUnidCarga(self.tpUnidCarga)
        elif nodeName_ == 'idUnidCarga':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'idUnidCarga')
            value_ = self.gds_validate_string(value_, node, 'idUnidCarga')
            self.idUnidCarga = value_
            self.idUnidCarga_nsprefix_ = child_.prefix
            # validate type TContainer
            self.validate_TContainer(self.idUnidCarga)
        elif nodeName_ == 'lacUnidCarga':
            obj_ = lacUnidCargaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lacUnidCarga.append(obj_)
            obj_.original_tagname_ = 'lacUnidCarga'
        elif nodeName_ == 'qtdRat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qtdRat')
            value_ = self.gds_validate_string(value_, node, 'qtdRat')
            self.qtdRat = value_
            self.qtdRat_nsprefix_ = child_.prefix
            # validate type TDec_0302_0303
            self.validate_TDec_0302_0303(self.qtdRat)
# end class TUnidCarga


class TRespTec(GeneratedsSuper):
    """TRespTec -- Tipo Dados da Respons
    á
    vel T
    é
    cnico
    CNPJ -- CNPJ da pessoa jur
    í
    dica respons
    á
    vel t
    é
    cnica pelo sistema utilizado na emiss
    ã
    o do documento fiscal eletr
    ô
    nico
    Informar o CNPJ da pessoa jur
    í
    dica desenvolvedora do sistema utilizado na emiss
    ã
    o do documento fiscal eletr
    ô
    nico.
    xContato -- Nome da pessoa a ser contatada
    Informar o nome da pessoa a ser contatada na empresa desenvolvedora do sistema utilizado na emiss
    ã
    o do documento fiscal eletr
    ô
    nico. No caso de pessoa f
    í
    sica, informar o respectivo nome.
    email -- Email da pessoa jur
    í
    dica a ser contatada
    fone -- Telefone da pessoa jur
    í
    dica a ser contatada
    Preencher com o C
    ó
    digo DDD + n
    ú
    mero do telefone.
    idCSRT -- Identificador do c
    ó
    digo de seguran
    ç
    a do respons
    á
    vel t
    é
    cnico
    Identificador do CSRT utilizado para gera
    ç
    ã
    o do hash
    hashCSRT -- Hash do token do c
    ó
    digo de seguran
    ç
    a do respons
    á
    vel t
    é
    cnico
    O hashCSRT
    é
    o resultado das fun
    ç
    õ
    es SHA-1 e base64 do token CSRT fornecido pelo fisco + chave de acesso do DF-e. (Implementa
    ç
    ã
    o em futura NT)
    Observa
    ç
    ã
    o: 28 caracteres s
    ã
    o representados no schema como 20 bytes do tipo base64Binary
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, xContato=None, email=None, fone=None, idCSRT=None, hashCSRT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.xContato = xContato
        self.validate_xContatoType(self.xContato)
        self.xContato_nsprefix_ = None
        self.email = email
        self.validate_TEmail(self.email)
        self.email_nsprefix_ = None
        self.fone = fone
        self.validate_foneType(self.fone)
        self.fone_nsprefix_ = None
        self.idCSRT = idCSRT
        self.validate_idCSRTType(self.idCSRT)
        self.idCSRT_nsprefix_ = None
        self.hashCSRT = hashCSRT
        self.validate_hashCSRTType(self.hashCSRT)
        self.hashCSRT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRespTec)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRespTec.subclass:
            return TRespTec.subclass(*args_, **kwargs_)
        else:
            return TRespTec(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_xContato(self):
        return self.xContato
    def set_xContato(self, xContato):
        self.xContato = xContato
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_idCSRT(self):
        return self.idCSRT
    def set_idCSRT(self, idCSRT):
        self.idCSRT = idCSRT
    def get_hashCSRT(self):
        return self.hashCSRT
    def set_hashCSRT(self, hashCSRT):
        self.hashCSRT = hashCSRT
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_xContatoType(self, value):
        result = True
        # Validate type xContatoType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xContatoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xContatoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xContatoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xContatoType_patterns_, ))
                result = False
        return result
    validate_xContatoType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TEmail(self, value):
        result = True
        # Validate type TEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TEmail_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TEmail_patterns_, ))
                result = False
        return result
    validate_TEmail_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def validate_foneType(self, value):
        result = True
        # Validate type foneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_foneType_patterns_, ))
                result = False
        return result
    validate_foneType_patterns_ = [['^([0-9]{7,12})$']]
    def validate_idCSRTType(self, value):
        result = True
        # Validate type idCSRTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_idCSRTType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_idCSRTType_patterns_, ))
                result = False
        return result
    validate_idCSRTType_patterns_ = [['^([0-9]{3})$']]
    def validate_hashCSRTType(self, value):
        result = True
        # Validate type hashCSRTType, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if len(value) != 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on hashCSRTType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.xContato is not None or
            self.email is not None or
            self.fone is not None or
            self.idCSRT is not None or
            self.hashCSRT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRespTec', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRespTec')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TRespTec':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TRespTec')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TRespTec', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TRespTec'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TRespTec', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.xContato is not None:
            namespaceprefix_ = self.xContato_nsprefix_ + ':' if (UseCapturedNS_ and self.xContato_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxContato>%s</%sxContato>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xContato), input_name='xContato')), namespaceprefix_ , eol_))
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.idCSRT is not None:
            namespaceprefix_ = self.idCSRT_nsprefix_ + ':' if (UseCapturedNS_ and self.idCSRT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidCSRT>%s</%sidCSRT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.idCSRT), input_name='idCSRT')), namespaceprefix_ , eol_))
        if self.hashCSRT is not None:
            namespaceprefix_ = self.hashCSRT_nsprefix_ + ':' if (UseCapturedNS_ and self.hashCSRT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shashCSRT>%s</%shashCSRT>%s' % (namespaceprefix_ , self.gds_format_base64(self.hashCSRT, input_name='hashCSRT'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'xContato':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xContato')
            value_ = self.gds_validate_string(value_, node, 'xContato')
            self.xContato = value_
            self.xContato_nsprefix_ = child_.prefix
            # validate type xContatoType
            self.validate_xContatoType(self.xContato)
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type TEmail
            self.validate_TEmail(self.email)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type foneType
            self.validate_foneType(self.fone)
        elif nodeName_ == 'idCSRT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'idCSRT')
            value_ = self.gds_validate_string(value_, node, 'idCSRT')
            self.idCSRT = value_
            self.idCSRT_nsprefix_ = child_.prefix
            # validate type idCSRTType
            self.validate_idCSRTType(self.idCSRT)
        elif nodeName_ == 'hashCSRT':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'hashCSRT')
            else:
                bval_ = None
            self.hashCSRT = bval_
            self.hashCSRT_nsprefix_ = child_.prefix
            # validate type hashCSRTType
            self.validate_hashCSRTType(self.hashCSRT)
# end class TRespTec


class SignatureType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.SignedInfo = SignedInfo
        self.SignedInfo_nsprefix_ = "ds"
        self.SignatureValue = SignatureValue
        self.SignatureValue_nsprefix_ = "ds"
        self.KeyInfo = KeyInfo
        self.KeyInfo_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SignedInfo(self):
        return self.SignedInfo
    def set_SignedInfo(self, SignedInfo):
        self.SignedInfo = SignedInfo
    def get_SignatureValue(self):
        return self.SignatureValue
    def set_SignatureValue(self, SignatureValue):
        self.SignatureValue = SignatureValue
    def get_KeyInfo(self):
        return self.KeyInfo
    def set_KeyInfo(self, KeyInfo):
        self.KeyInfo = KeyInfo
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def _hasContent(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#"', name_='SignatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#"', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            namespaceprefix_ = self.SignedInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.SignedInfo_nsprefix_) else ''
            self.SignedInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            namespaceprefix_ = self.SignatureValue_nsprefix_ + ':' if (UseCapturedNS_ and self.SignatureValue_nsprefix_) else ''
            self.SignatureValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            namespaceprefix_ = self.KeyInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.KeyInfo_nsprefix_) else ''
            self.KeyInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='KeyInfo', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#"', name_='SignatureValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureValueType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignatureValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#"', name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.CanonicalizationMethod = CanonicalizationMethod
        self.CanonicalizationMethod_nsprefix_ = None
        self.SignatureMethod = SignatureMethod
        self.SignatureMethod_nsprefix_ = None
        self.Reference = Reference
        self.Reference_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CanonicalizationMethod(self):
        return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod):
        self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self):
        return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod):
        self.SignatureMethod = SignatureMethod
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def _hasContent(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='SignedInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignedInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignedInfoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            namespaceprefix_ = self.CanonicalizationMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.CanonicalizationMethod_nsprefix_) else ''
            self.CanonicalizationMethod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            namespaceprefix_ = self.SignatureMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.SignatureMethod_nsprefix_) else ''
            self.SignatureMethod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SignatureMethod', pretty_print=pretty_print)
        if self.Reference is not None:
            namespaceprefix_ = self.Reference_nsprefix_ + ':' if (UseCapturedNS_ and self.Reference_nsprefix_) else ''
            self.Reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class ReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.URI = _cast(None, URI)
        self.URI_nsprefix_ = None
        self.Type = _cast(None, Type)
        self.Type_nsprefix_ = None
        self.Transforms = Transforms
        self.Transforms_nsprefix_ = "ds"
        self.DigestMethod = DigestMethod
        self.DigestMethod_nsprefix_ = None
        self.DigestValue = DigestValue
        self.validate_DigestValueType(self.DigestValue)
        self.DigestValue_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Transforms(self):
        return self.Transforms
    def set_Transforms(self, Transforms):
        self.Transforms = Transforms
    def get_DigestMethod(self):
        return self.DigestMethod
    def set_DigestMethod(self, DigestMethod):
        self.DigestMethod = DigestMethod
    def get_DigestValue(self):
        return self.DigestValue
    def set_DigestValue(self, DigestValue):
        self.DigestValue = DigestValue
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_URI(self):
        return self.URI
    def set_URI(self, URI):
        self.URI = URI
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def validate_DigestValueType(self, value):
        result = True
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def validate_URIType(self, value):
        # Validate type URIType, a restriction on anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on URIType' % {"value" : value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ReferenceType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            namespaceprefix_ = self.Transforms_nsprefix_ + ':' if (UseCapturedNS_ and self.Transforms_nsprefix_) else ''
            self.Transforms.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            namespaceprefix_ = self.DigestMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.DigestMethod_nsprefix_) else ''
            self.DigestMethod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            namespaceprefix_ = self.DigestValue_nsprefix_ + ':' if (UseCapturedNS_ and self.DigestValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDigestValue>%s</%sDigestValue>%s' % (namespaceprefix_ , self.gds_format_base64(self.DigestValue, input_name='DigestValue'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
            self.validate_URIType(self.URI)    # validate type URIType
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DigestValue')
            else:
                bval_ = None
            self.DigestValue = bval_
            self.DigestValue_nsprefix_ = child_.prefix
            # validate type DigestValueType
            self.validate_DigestValueType(self.DigestValue)
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Transform=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
        self.Transform_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Transform(self):
        return self.Transform
    def set_Transform(self, Transform):
        self.Transform = Transform
    def add_Transform(self, value):
        self.Transform.append(value)
    def insert_Transform_at(self, index, value):
        self.Transform.insert(index, value)
    def replace_Transform_at(self, index, value):
        self.Transform[index] = value
    def _hasContent(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#"', name_='TransformsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransformsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#"', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            namespaceprefix_ = self.Transform_nsprefix_ + ':' if (UseCapturedNS_ and self.Transform_nsprefix_) else ''
            Transform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Transform', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, XPath=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
        self.XPath_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_XPath(self):
        return self.XPath
    def set_XPath(self, XPath):
        self.XPath = XPath
    def add_XPath(self, value):
        self.XPath.append(value)
    def insert_XPath_at(self, index, value):
        self.XPath.insert(index, value)
    def replace_XPath_at(self, index, value):
        self.XPath[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def validate_TTransformURI(self, value):
        # Validate type ds:TTransformURI, a restriction on anyURI.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['http://www.w3.org/2000/09/xmldsig#enveloped-signature', 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TTransformURI' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.XPath
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TransformType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransformType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='TransformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            namespaceprefix_ = self.XPath_nsprefix_ + ':' if (UseCapturedNS_ and self.XPath_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sXPath>%s</%sXPath>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(XPath_), input_name='XPath')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
            self.validate_TTransformURI(self.Algorithm)    # validate type TTransformURI
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'XPath':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'XPath')
            value_ = self.gds_validate_string(value_, node, 'XPath')
            self.XPath.append(value_)
            self.XPath_nsprefix_ = child_.prefix
# end class TransformType


class KeyInfoType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, X509Data=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ds"
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.X509Data = X509Data
        self.X509Data_nsprefix_ = "ds"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X509Data(self):
        return self.X509Data
    def set_X509Data(self, X509Data):
        self.X509Data = X509Data
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def _hasContent(self):
        if (
            self.X509Data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#"', name_='KeyInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KeyInfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyInfoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='KeyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#"', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Data is not None:
            namespaceprefix_ = self.X509Data_nsprefix_ + ':' if (UseCapturedNS_ and self.X509Data_nsprefix_) else ''
            self.X509Data.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X509Data', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X509Data':
            obj_ = X509DataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.X509Data = obj_
            obj_.original_tagname_ = 'X509Data'
# end class KeyInfoType


class X509DataType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, X509Certificate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.X509Certificate = X509Certificate
        self.X509Certificate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_X509Certificate(self):
        return self.X509Certificate
    def set_X509Certificate(self, X509Certificate):
        self.X509Certificate = X509Certificate
    def _hasContent(self):
        if (
            self.X509Certificate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='X509DataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'X509DataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509DataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='X509DataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Certificate is not None:
            namespaceprefix_ = self.X509Certificate_nsprefix_ + ':' if (UseCapturedNS_ and self.X509Certificate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509Certificate>%s</%sX509Certificate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.X509Certificate), input_name='X509Certificate')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'X509Certificate':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'X509Certificate')
            value_ = self.gds_validate_string(value_, node, 'X509Certificate')
            self.X509Certificate = value_
            self.X509Certificate_nsprefix_ = child_.prefix
# end class X509DataType


class infCteType(GeneratedsSuper):
    """infCteType -- Informa
    ç
    õ
    es do CT-e do tipo GTV-e
    versao -- Vers
    ã
    o do leiaute
    Ex: "3.00"
    Id -- Identificador da tag a ser assinada
    Informar a chave de acesso do CT-e OS e precedida do literal "CTe"
    ide -- Identifica
    ç
    ã
    o da GTV-e
    compl -- Dados complementares da GTV-e para fins operacionais ou comerciais
    emit -- Identifica
    ç
    ã
    o do Emitente da GTV-e
    rem -- Informa
    ç
    õ
    es do Remetente
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    dest -- Informa
    ç
    õ
    es do Destinat
    á
    rio
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    origem -- Informa
    ç
    õ
    es do endere
    ç
    o da origem do servi
    ç
    o
    destino -- Informa
    ç
    õ
    es do endere
    ç
    o do destino do servi
    ç
    o
    detGTV -- Grupo de informa
    ç
    õ
    es detalhadas da GTV-e
    autXML -- Autorizados para download do XML do DF-e
    Informar CNPJ ou CPF. Preencher os zeros n
    ã
    o significativos.
    infRespTec -- Informa
    ç
    õ
    es do Respons
    á
    vel T
    é
    cnico pela emiss
    ã
    o do DF-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, Id=None, ide=None, compl=None, emit=None, rem=None, dest=None, origem=None, destino=None, detGTV=None, autXML=None, infRespTec=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.ide = ide
        self.ide_nsprefix_ = None
        self.compl = compl
        self.compl_nsprefix_ = None
        self.emit = emit
        self.emit_nsprefix_ = None
        self.rem = rem
        self.rem_nsprefix_ = None
        self.dest = dest
        self.dest_nsprefix_ = None
        self.origem = origem
        self.origem_nsprefix_ = None
        self.destino = destino
        self.destino_nsprefix_ = None
        self.detGTV = detGTV
        self.detGTV_nsprefix_ = None
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
        self.autXML_nsprefix_ = None
        self.infRespTec = infRespTec
        self.infRespTec_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteType.subclass:
            return infCteType.subclass(*args_, **kwargs_)
        else:
            return infCteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ide(self):
        return self.ide
    def set_ide(self, ide):
        self.ide = ide
    def get_compl(self):
        return self.compl
    def set_compl(self, compl):
        self.compl = compl
    def get_emit(self):
        return self.emit
    def set_emit(self, emit):
        self.emit = emit
    def get_rem(self):
        return self.rem
    def set_rem(self, rem):
        self.rem = rem
    def get_dest(self):
        return self.dest
    def set_dest(self, dest):
        self.dest = dest
    def get_origem(self):
        return self.origem
    def set_origem(self, origem):
        self.origem = origem
    def get_destino(self):
        return self.destino
    def set_destino(self, destino):
        self.destino = destino
    def get_detGTV(self):
        return self.detGTV
    def set_detGTV(self, detGTV):
        self.detGTV = detGTV
    def get_autXML(self):
        return self.autXML
    def set_autXML(self, autXML):
        self.autXML = autXML
    def add_autXML(self, value):
        self.autXML.append(value)
    def insert_autXML_at(self, index, value):
        self.autXML.insert(index, value)
    def replace_autXML_at(self, index, value):
        self.autXML[index] = value
    def get_infRespTec(self):
        return self.infRespTec
    def set_infRespTec(self, infRespTec):
        self.infRespTec = infRespTec
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_versaoType(self, value):
        # Validate type versaoType, a restriction on TVerCTe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoType_patterns_, ))
    validate_versaoType_patterns_ = [['^(3\\.00)$']]
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^(CTe[0-9]{44})$']]
    def _hasContent(self):
        if (
            self.ide is not None or
            self.compl is not None or
            self.emit is not None or
            self.rem is not None or
            self.dest is not None or
            self.origem is not None or
            self.destino is not None or
            self.detGTV is not None or
            self.autXML or
            self.infRespTec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteType'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            namespaceprefix_ = self.ide_nsprefix_ + ':' if (UseCapturedNS_ and self.ide_nsprefix_) else ''
            self.ide.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ide', pretty_print=pretty_print)
        if self.compl is not None:
            namespaceprefix_ = self.compl_nsprefix_ + ':' if (UseCapturedNS_ and self.compl_nsprefix_) else ''
            self.compl.export(outfile, level, namespaceprefix_, namespacedef_='', name_='compl', pretty_print=pretty_print)
        if self.emit is not None:
            namespaceprefix_ = self.emit_nsprefix_ + ':' if (UseCapturedNS_ and self.emit_nsprefix_) else ''
            self.emit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emit', pretty_print=pretty_print)
        if self.rem is not None:
            namespaceprefix_ = self.rem_nsprefix_ + ':' if (UseCapturedNS_ and self.rem_nsprefix_) else ''
            self.rem.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rem', pretty_print=pretty_print)
        if self.dest is not None:
            namespaceprefix_ = self.dest_nsprefix_ + ':' if (UseCapturedNS_ and self.dest_nsprefix_) else ''
            self.dest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dest', pretty_print=pretty_print)
        if self.origem is not None:
            namespaceprefix_ = self.origem_nsprefix_ + ':' if (UseCapturedNS_ and self.origem_nsprefix_) else ''
            self.origem.export(outfile, level, namespaceprefix_, namespacedef_='', name_='origem', pretty_print=pretty_print)
        if self.destino is not None:
            namespaceprefix_ = self.destino_nsprefix_ + ':' if (UseCapturedNS_ and self.destino_nsprefix_) else ''
            self.destino.export(outfile, level, namespaceprefix_, namespacedef_='', name_='destino', pretty_print=pretty_print)
        if self.detGTV is not None:
            namespaceprefix_ = self.detGTV_nsprefix_ + ':' if (UseCapturedNS_ and self.detGTV_nsprefix_) else ''
            self.detGTV.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detGTV', pretty_print=pretty_print)
        for autXML_ in self.autXML:
            namespaceprefix_ = self.autXML_nsprefix_ + ':' if (UseCapturedNS_ and self.autXML_nsprefix_) else ''
            autXML_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='autXML', pretty_print=pretty_print)
        if self.infRespTec is not None:
            namespaceprefix_ = self.infRespTec_nsprefix_ + ':' if (UseCapturedNS_ and self.infRespTec_nsprefix_) else ''
            self.infRespTec.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infRespTec', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_versaoType(self.versao)    # validate type versaoType
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
            self.validate_IdType(self.Id)    # validate type IdType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ide':
            obj_ = ideType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'compl':
            obj_ = complType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.compl = obj_
            obj_.original_tagname_ = 'compl'
        elif nodeName_ == 'emit':
            obj_ = emitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'rem':
            obj_ = remType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rem = obj_
            obj_.original_tagname_ = 'rem'
        elif nodeName_ == 'dest':
            obj_ = destType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dest = obj_
            obj_.original_tagname_ = 'dest'
        elif nodeName_ == 'origem':
            obj_ = TEndeEmi.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.origem = obj_
            obj_.original_tagname_ = 'origem'
        elif nodeName_ == 'destino':
            obj_ = TEndeEmi.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.destino = obj_
            obj_.original_tagname_ = 'destino'
        elif nodeName_ == 'detGTV':
            obj_ = detGTVType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detGTV = obj_
            obj_.original_tagname_ = 'detGTV'
        elif nodeName_ == 'autXML':
            obj_ = autXMLType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
        elif nodeName_ == 'infRespTec':
            obj_ = TRespTec.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infRespTec = obj_
            obj_.original_tagname_ = 'infRespTec'
# end class infCteType


class ideType(GeneratedsSuper):
    """ideType -- Identifica
    ç
    ã
    o da GTV-e
    Informar apenas
    para tpEmis diferente de 1
    cUF -- C
    ó
    digo da UF do emitente da GTV-e.
    Utilizar a Tabela do IBGE.
    cCT -- C
    ó
    digo num
    é
    rico que comp
    õ
    e a Chave de Acesso.
    N
    ú
    mero aleat
    ó
    rio gerado pelo emitente para cada CT-e, com o objetivo de evitar acessos indevidos ao documento.
    CFOP -- C
    ó
    digo Fiscal de Opera
    ç
    õ
    es e Presta
    ç
    õ
    es
    natOp -- Natureza da Opera
    ç
    ã
    o
    mod -- Modelo do documento fiscal
    Utilizar o c
    ó
    digo 64 para identifica
    ç
    ã
    o do CT-e Guia de Transporte de Valores
    serie -- S
    é
    rie da GTV-e
    Preencher com "0" no caso de s
    é
    rie
    ú
    nica
    nCT -- N
    ú
    mero da GTV-e
    dhEmi -- Data e hora de emiss
    ã
    o da GTV-e
    Formato AAAA-MM-DDTHH:MM:DD TZD
    tpImp -- Formato de impress
    ã
    o do DACTE
    Preencher com: 1 - Retrato; 2 - Paisagem.
    tpEmis -- Forma de emiss
    ã
    o da GTV-e
    Preencher com:
    1 - Normal;
    2- Contingencia offline
    7 - Autoriza
    ç
    ã
    o pela SVC-RS;
    8 - Autoriza
    ç
    ã
    o pela SVC-SP
    cDV -- Digito Verificador da chave de acesso da GTV-e
    Informar o d
    í
    gito  de controle da chave de acesso do CT-e, que deve ser calculado com a aplica
    ç
    ã
    o do algoritmo m
    ó
    dulo 11 (base 2,9) da chave de acesso.
    tpAmb -- Tipo do Ambiente
    Preencher com:1 - Produ
    ç
    ã
    o; 2 - Homologa
    ç
    ã
    o
    tpCTe -- Tipo da GTV-e
    Preencher com:
    4 - GTV-e
    verProc -- Vers
    ã
    o do processo de emiss
    ã
    o
    Iinformar a vers
    ã
    o do aplicativo emissor de CT-e.
    cMunEnv -- C
    ó
    digo do Munic
    í
    pio de envio da GTV-e (de onde o documento foi transmitido)
    Utilizar a tabela do IBGE. Informar 9999999 para as opera
    ç
    õ
    es com o exterior.
    xMunEnv -- Nome do Munic
    í
    pio de envio da GTV-e (de onde o documento foi transmitido)
    Informar PAIS/Municipio para as opera
    ç
    õ
    es com o exterior.
    UFEnv -- Sigla da UF de envio da GTV-e (de onde o documento foi transmitido)
    Informar 'EX' para opera
    ç
    õ
    es com o exterior.
    modal -- Modal da GTV-e
    Preencher com:
    01-Rodovi
    á
    rio
    06-Multimodal
    tpServ -- Tipo do Servi
    ç
    o
    Preencher com:
    9 - GTV
    indIEToma -- Indicador da IE do tomador:
    1
    –
    Contribuinte ICMS;
    2
    –
    Contribuinte isento de inscri
    ç
    ã
    o;
    9
    –
    N
    ã
    o Contribuinte
    Aplica-se ao tomador que for indicado no toma3 ou toma4
    dhSaidaOrig -- Data e hora de saida da origem
    Formato AAAA-MM-DDTHH:MM:DD TZD
    dhChegadaDest -- Data e hora de chegada no destino
    Formato AAAA-MM-DDTHH:MM:DD TZD
    toma -- Indicador do "papel" do tomador do servi
    ç
    o no GT-e
    tomaTerceiro -- Indicador do "papel" do tomador do servi
    ç
    o no CTV-e
    dhCont -- Data e Hora da entrada em conting
    ê
    ncia
    Informar a data e hora no formato AAAA-MM-DDTHH:MM:SS
    xJust -- Justificativa da entrada em conting
    ê
    ncia
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cUF=None, cCT=None, CFOP=None, natOp=None, mod=None, serie=None, nCT=None, dhEmi=None, tpImp=None, tpEmis=None, cDV=None, tpAmb=None, tpCTe=None, verProc=None, cMunEnv=None, xMunEnv=None, UFEnv=None, modal=None, tpServ=None, indIEToma=None, dhSaidaOrig=None, dhChegadaDest=None, toma=None, tomaTerceiro=None, dhCont=None, xJust=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cUF_nsprefix_ = None
        self.cCT = cCT
        self.validate_cCTType(self.cCT)
        self.cCT_nsprefix_ = None
        self.CFOP = CFOP
        self.validate_TCfop(self.CFOP)
        self.CFOP_nsprefix_ = None
        self.natOp = natOp
        self.validate_natOpType(self.natOp)
        self.natOp_nsprefix_ = None
        self.mod = mod
        self.validate_TModGTVe(self.mod)
        self.mod_nsprefix_ = None
        self.serie = serie
        self.validate_serieType(self.serie)
        self.serie_nsprefix_ = None
        self.nCT = nCT
        self.validate_TNF(self.nCT)
        self.nCT_nsprefix_ = None
        self.dhEmi = dhEmi
        self.validate_dhEmiType(self.dhEmi)
        self.dhEmi_nsprefix_ = None
        self.tpImp = tpImp
        self.validate_tpImpType(self.tpImp)
        self.tpImp_nsprefix_ = None
        self.tpEmis = tpEmis
        self.validate_tpEmisType(self.tpEmis)
        self.tpEmis_nsprefix_ = None
        self.cDV = cDV
        self.validate_cDVType(self.cDV)
        self.cDV_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.tpCTe = tpCTe
        self.validate_tpCTeType(self.tpCTe)
        self.tpCTe_nsprefix_ = None
        self.verProc = verProc
        self.validate_verProcType(self.verProc)
        self.verProc_nsprefix_ = None
        self.cMunEnv = cMunEnv
        self.validate_TCodMunIBGE(self.cMunEnv)
        self.cMunEnv_nsprefix_ = None
        self.xMunEnv = xMunEnv
        self.validate_xMunEnvType(self.xMunEnv)
        self.xMunEnv_nsprefix_ = None
        self.UFEnv = UFEnv
        self.validate_TUf(self.UFEnv)
        self.UFEnv_nsprefix_ = None
        self.modal = modal
        self.validate_modalType(self.modal)
        self.modal_nsprefix_ = None
        self.tpServ = tpServ
        self.validate_tpServType(self.tpServ)
        self.tpServ_nsprefix_ = None
        self.indIEToma = indIEToma
        self.validate_indIETomaType(self.indIEToma)
        self.indIEToma_nsprefix_ = None
        self.dhSaidaOrig = dhSaidaOrig
        self.validate_dhSaidaOrigType(self.dhSaidaOrig)
        self.dhSaidaOrig_nsprefix_ = None
        self.dhChegadaDest = dhChegadaDest
        self.validate_dhChegadaDestType(self.dhChegadaDest)
        self.dhChegadaDest_nsprefix_ = None
        self.toma = toma
        self.toma_nsprefix_ = None
        self.tomaTerceiro = tomaTerceiro
        self.tomaTerceiro_nsprefix_ = None
        self.dhCont = dhCont
        self.validate_TDateTimeUTC(self.dhCont)
        self.dhCont_nsprefix_ = None
        self.xJust = xJust
        self.validate_xJustType(self.xJust)
        self.xJust_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideType.subclass:
            return ideType.subclass(*args_, **kwargs_)
        else:
            return ideType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_cCT(self):
        return self.cCT
    def set_cCT(self, cCT):
        self.cCT = cCT
    def get_CFOP(self):
        return self.CFOP
    def set_CFOP(self, CFOP):
        self.CFOP = CFOP
    def get_natOp(self):
        return self.natOp
    def set_natOp(self, natOp):
        self.natOp = natOp
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_nCT(self):
        return self.nCT
    def set_nCT(self, nCT):
        self.nCT = nCT
    def get_dhEmi(self):
        return self.dhEmi
    def set_dhEmi(self, dhEmi):
        self.dhEmi = dhEmi
    def get_tpImp(self):
        return self.tpImp
    def set_tpImp(self, tpImp):
        self.tpImp = tpImp
    def get_tpEmis(self):
        return self.tpEmis
    def set_tpEmis(self, tpEmis):
        self.tpEmis = tpEmis
    def get_cDV(self):
        return self.cDV
    def set_cDV(self, cDV):
        self.cDV = cDV
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_tpCTe(self):
        return self.tpCTe
    def set_tpCTe(self, tpCTe):
        self.tpCTe = tpCTe
    def get_verProc(self):
        return self.verProc
    def set_verProc(self, verProc):
        self.verProc = verProc
    def get_cMunEnv(self):
        return self.cMunEnv
    def set_cMunEnv(self, cMunEnv):
        self.cMunEnv = cMunEnv
    def get_xMunEnv(self):
        return self.xMunEnv
    def set_xMunEnv(self, xMunEnv):
        self.xMunEnv = xMunEnv
    def get_UFEnv(self):
        return self.UFEnv
    def set_UFEnv(self, UFEnv):
        self.UFEnv = UFEnv
    def get_modal(self):
        return self.modal
    def set_modal(self, modal):
        self.modal = modal
    def get_tpServ(self):
        return self.tpServ
    def set_tpServ(self, tpServ):
        self.tpServ = tpServ
    def get_indIEToma(self):
        return self.indIEToma
    def set_indIEToma(self, indIEToma):
        self.indIEToma = indIEToma
    def get_dhSaidaOrig(self):
        return self.dhSaidaOrig
    def set_dhSaidaOrig(self, dhSaidaOrig):
        self.dhSaidaOrig = dhSaidaOrig
    def get_dhChegadaDest(self):
        return self.dhChegadaDest
    def set_dhChegadaDest(self, dhChegadaDest):
        self.dhChegadaDest = dhChegadaDest
    def get_toma(self):
        return self.toma
    def set_toma(self, toma):
        self.toma = toma
    def get_tomaTerceiro(self):
        return self.tomaTerceiro
    def set_tomaTerceiro(self, tomaTerceiro):
        self.tomaTerceiro = tomaTerceiro
    def get_dhCont(self):
        return self.dhCont
    def set_dhCont(self, dhCont):
        self.dhCont = dhCont
    def get_xJust(self):
        return self.xJust
    def set_xJust(self, xJust):
        self.xJust = xJust
    def validate_TCodUfIBGE(self, value):
        result = True
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cCTType(self, value):
        result = True
        # Validate type cCTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cCTType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cCTType_patterns_, ))
                result = False
        return result
    validate_cCTType_patterns_ = [['^([0-9]{8})$']]
    def validate_TCfop(self, value):
        result = True
        # Validate type TCfop, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCfop_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCfop_patterns_, ))
                result = False
        return result
    validate_TCfop_patterns_ = [['^([123567][0-9]([0-9][1-9]|[1-9][0-9]))$']]
    def validate_natOpType(self, value):
        result = True
        # Validate type natOpType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on natOpType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on natOpType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_natOpType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_natOpType_patterns_, ))
                result = False
        return result
    validate_natOpType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TModGTVe(self, value):
        result = True
        # Validate type TModGTVe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['64']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TModGTVe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_serieType(self, value):
        result = True
        # Validate type serieType, a restriction on TSerie.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_serieType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_serieType_patterns_, ))
                result = False
        return result
    validate_serieType_patterns_ = [['^(0|[1-9]{1}[0-9]{0,2})$']]
    def validate_TNF(self, value):
        result = True
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TNF_patterns_, ))
                result = False
        return result
    validate_TNF_patterns_ = [['^([1-9]{1}[0-9]{0,8})$']]
    def validate_dhEmiType(self, value):
        result = True
        # Validate type dhEmiType, a restriction on TDateTimeUTC.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_dhEmiType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_dhEmiType_patterns_, ))
                result = False
        return result
    validate_dhEmiType_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_tpImpType(self, value):
        result = True
        # Validate type tpImpType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpImpType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tpEmisType(self, value):
        result = True
        # Validate type tpEmisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '7', '8']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpEmisType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cDVType(self, value):
        result = True
        # Validate type cDVType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cDVType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cDVType_patterns_, ))
                result = False
        return result
    validate_cDVType_patterns_ = [['^([0-9]{1})$']]
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tpCTeType(self, value):
        result = True
        # Validate type tpCTeType, a restriction on TFinGTVe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['4']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpCTeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_verProcType(self, value):
        result = True
        # Validate type verProcType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on verProcType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on verProcType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_verProcType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_verProcType_patterns_, ))
                result = False
        return result
    validate_verProcType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunEnvType(self, value):
        result = True
        # Validate type xMunEnvType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunEnvType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunEnvType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunEnvType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunEnvType_patterns_, ))
                result = False
        return result
    validate_xMunEnvType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_modalType(self, value):
        result = True
        # Validate type modalType, a restriction on TModTranspGTVe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['01', '06']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on modalType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            value = value
            enumerations = ['01', '06']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on modalType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tpServType(self, value):
        result = True
        # Validate type tpServType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['9']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpServType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_indIETomaType(self, value):
        result = True
        # Validate type indIETomaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '9']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on indIETomaType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_dhSaidaOrigType(self, value):
        result = True
        # Validate type dhSaidaOrigType, a restriction on TDateTimeUTC.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_dhSaidaOrigType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_dhSaidaOrigType_patterns_, ))
                result = False
        return result
    validate_dhSaidaOrigType_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_dhChegadaDestType(self, value):
        result = True
        # Validate type dhChegadaDestType, a restriction on TDateTimeUTC.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_dhChegadaDestType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_dhChegadaDestType_patterns_, ))
                result = False
        return result
    validate_dhChegadaDestType_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_TDateTimeUTC(self, value):
        result = True
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDateTimeUTC_patterns_, ))
                result = False
        return result
    validate_TDateTimeUTC_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_xJustType(self, value):
        result = True
        # Validate type xJustType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xJustType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xJustType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xJustType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xJustType_patterns_, ))
                result = False
        return result
    validate_xJustType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.cUF is not None or
            self.cCT is not None or
            self.CFOP is not None or
            self.natOp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nCT is not None or
            self.dhEmi is not None or
            self.tpImp is not None or
            self.tpEmis is not None or
            self.cDV is not None or
            self.tpAmb is not None or
            self.tpCTe is not None or
            self.verProc is not None or
            self.cMunEnv is not None or
            self.xMunEnv is not None or
            self.UFEnv is not None or
            self.modal is not None or
            self.tpServ is not None or
            self.indIEToma is not None or
            self.dhSaidaOrig is not None or
            self.dhChegadaDest is not None or
            self.toma is not None or
            self.tomaTerceiro is not None or
            self.dhCont is not None or
            self.xJust is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ideType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ideType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ideType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ideType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ideType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ideType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            namespaceprefix_ = self.cUF_nsprefix_ + ':' if (UseCapturedNS_ and self.cUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.cCT is not None:
            namespaceprefix_ = self.cCT_nsprefix_ + ':' if (UseCapturedNS_ and self.cCT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scCT>%s</%scCT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cCT), input_name='cCT')), namespaceprefix_ , eol_))
        if self.CFOP is not None:
            namespaceprefix_ = self.CFOP_nsprefix_ + ':' if (UseCapturedNS_ and self.CFOP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCFOP>%s</%sCFOP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CFOP), input_name='CFOP')), namespaceprefix_ , eol_))
        if self.natOp is not None:
            namespaceprefix_ = self.natOp_nsprefix_ + ':' if (UseCapturedNS_ and self.natOp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snatOp>%s</%snatOp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.natOp), input_name='natOp')), namespaceprefix_ , eol_))
        if self.mod is not None:
            namespaceprefix_ = self.mod_nsprefix_ + ':' if (UseCapturedNS_ and self.mod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            namespaceprefix_ = self.serie_nsprefix_ + ':' if (UseCapturedNS_ and self.serie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.nCT is not None:
            namespaceprefix_ = self.nCT_nsprefix_ + ':' if (UseCapturedNS_ and self.nCT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snCT>%s</%snCT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nCT), input_name='nCT')), namespaceprefix_ , eol_))
        if self.dhEmi is not None:
            namespaceprefix_ = self.dhEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dhEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhEmi>%s</%sdhEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhEmi), input_name='dhEmi')), namespaceprefix_ , eol_))
        if self.tpImp is not None:
            namespaceprefix_ = self.tpImp_nsprefix_ + ':' if (UseCapturedNS_ and self.tpImp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpImp>%s</%stpImp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpImp), input_name='tpImp')), namespaceprefix_ , eol_))
        if self.tpEmis is not None:
            namespaceprefix_ = self.tpEmis_nsprefix_ + ':' if (UseCapturedNS_ and self.tpEmis_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpEmis>%s</%stpEmis>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpEmis), input_name='tpEmis')), namespaceprefix_ , eol_))
        if self.cDV is not None:
            namespaceprefix_ = self.cDV_nsprefix_ + ':' if (UseCapturedNS_ and self.cDV_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scDV>%s</%scDV>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cDV), input_name='cDV')), namespaceprefix_ , eol_))
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.tpCTe is not None:
            namespaceprefix_ = self.tpCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.tpCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpCTe>%s</%stpCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpCTe), input_name='tpCTe')), namespaceprefix_ , eol_))
        if self.verProc is not None:
            namespaceprefix_ = self.verProc_nsprefix_ + ':' if (UseCapturedNS_ and self.verProc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverProc>%s</%sverProc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), namespaceprefix_ , eol_))
        if self.cMunEnv is not None:
            namespaceprefix_ = self.cMunEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.cMunEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunEnv>%s</%scMunEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunEnv), input_name='cMunEnv')), namespaceprefix_ , eol_))
        if self.xMunEnv is not None:
            namespaceprefix_ = self.xMunEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.xMunEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMunEnv>%s</%sxMunEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMunEnv), input_name='xMunEnv')), namespaceprefix_ , eol_))
        if self.UFEnv is not None:
            namespaceprefix_ = self.UFEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.UFEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFEnv>%s</%sUFEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFEnv), input_name='UFEnv')), namespaceprefix_ , eol_))
        if self.modal is not None:
            namespaceprefix_ = self.modal_nsprefix_ + ':' if (UseCapturedNS_ and self.modal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodal>%s</%smodal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modal), input_name='modal')), namespaceprefix_ , eol_))
        if self.tpServ is not None:
            namespaceprefix_ = self.tpServ_nsprefix_ + ':' if (UseCapturedNS_ and self.tpServ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpServ>%s</%stpServ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpServ), input_name='tpServ')), namespaceprefix_ , eol_))
        if self.indIEToma is not None:
            namespaceprefix_ = self.indIEToma_nsprefix_ + ':' if (UseCapturedNS_ and self.indIEToma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindIEToma>%s</%sindIEToma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indIEToma), input_name='indIEToma')), namespaceprefix_ , eol_))
        if self.dhSaidaOrig is not None:
            namespaceprefix_ = self.dhSaidaOrig_nsprefix_ + ':' if (UseCapturedNS_ and self.dhSaidaOrig_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhSaidaOrig>%s</%sdhSaidaOrig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhSaidaOrig), input_name='dhSaidaOrig')), namespaceprefix_ , eol_))
        if self.dhChegadaDest is not None:
            namespaceprefix_ = self.dhChegadaDest_nsprefix_ + ':' if (UseCapturedNS_ and self.dhChegadaDest_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhChegadaDest>%s</%sdhChegadaDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhChegadaDest), input_name='dhChegadaDest')), namespaceprefix_ , eol_))
        if self.toma is not None:
            namespaceprefix_ = self.toma_nsprefix_ + ':' if (UseCapturedNS_ and self.toma_nsprefix_) else ''
            self.toma.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toma', pretty_print=pretty_print)
        if self.tomaTerceiro is not None:
            namespaceprefix_ = self.tomaTerceiro_nsprefix_ + ':' if (UseCapturedNS_ and self.tomaTerceiro_nsprefix_) else ''
            self.tomaTerceiro.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tomaTerceiro', pretty_print=pretty_print)
        if self.dhCont is not None:
            namespaceprefix_ = self.dhCont_nsprefix_ + ':' if (UseCapturedNS_ and self.dhCont_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhCont>%s</%sdhCont>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhCont), input_name='dhCont')), namespaceprefix_ , eol_))
        if self.xJust is not None:
            namespaceprefix_ = self.xJust_nsprefix_ + ':' if (UseCapturedNS_ and self.xJust_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxJust>%s</%sxJust>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xJust), input_name='xJust')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cUF')
            value_ = self.gds_validate_string(value_, node, 'cUF')
            self.cUF = value_
            self.cUF_nsprefix_ = child_.prefix
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'cCT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cCT')
            value_ = self.gds_validate_string(value_, node, 'cCT')
            self.cCT = value_
            self.cCT_nsprefix_ = child_.prefix
            # validate type cCTType
            self.validate_cCTType(self.cCT)
        elif nodeName_ == 'CFOP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CFOP')
            value_ = self.gds_validate_string(value_, node, 'CFOP')
            self.CFOP = value_
            self.CFOP_nsprefix_ = child_.prefix
            # validate type TCfop
            self.validate_TCfop(self.CFOP)
        elif nodeName_ == 'natOp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'natOp')
            value_ = self.gds_validate_string(value_, node, 'natOp')
            self.natOp = value_
            self.natOp_nsprefix_ = child_.prefix
            # validate type natOpType
            self.validate_natOpType(self.natOp)
        elif nodeName_ == 'mod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mod')
            value_ = self.gds_validate_string(value_, node, 'mod')
            self.mod = value_
            self.mod_nsprefix_ = child_.prefix
            # validate type TModGTVe
            self.validate_TModGTVe(self.mod)
        elif nodeName_ == 'serie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serie')
            value_ = self.gds_validate_string(value_, node, 'serie')
            self.serie = value_
            self.serie_nsprefix_ = child_.prefix
            # validate type serieType
            self.validate_serieType(self.serie)
        elif nodeName_ == 'nCT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nCT')
            value_ = self.gds_validate_string(value_, node, 'nCT')
            self.nCT = value_
            self.nCT_nsprefix_ = child_.prefix
            # validate type TNF
            self.validate_TNF(self.nCT)
        elif nodeName_ == 'dhEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhEmi')
            value_ = self.gds_validate_string(value_, node, 'dhEmi')
            self.dhEmi = value_
            self.dhEmi_nsprefix_ = child_.prefix
            # validate type dhEmiType
            self.validate_dhEmiType(self.dhEmi)
        elif nodeName_ == 'tpImp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpImp')
            value_ = self.gds_validate_string(value_, node, 'tpImp')
            self.tpImp = value_
            self.tpImp_nsprefix_ = child_.prefix
            # validate type tpImpType
            self.validate_tpImpType(self.tpImp)
        elif nodeName_ == 'tpEmis':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpEmis')
            value_ = self.gds_validate_string(value_, node, 'tpEmis')
            self.tpEmis = value_
            self.tpEmis_nsprefix_ = child_.prefix
            # validate type tpEmisType
            self.validate_tpEmisType(self.tpEmis)
        elif nodeName_ == 'cDV':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cDV')
            value_ = self.gds_validate_string(value_, node, 'cDV')
            self.cDV = value_
            self.cDV_nsprefix_ = child_.prefix
            # validate type cDVType
            self.validate_cDVType(self.cDV)
        elif nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'tpCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpCTe')
            value_ = self.gds_validate_string(value_, node, 'tpCTe')
            self.tpCTe = value_
            self.tpCTe_nsprefix_ = child_.prefix
            # validate type tpCTeType
            self.validate_tpCTeType(self.tpCTe)
        elif nodeName_ == 'verProc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verProc')
            value_ = self.gds_validate_string(value_, node, 'verProc')
            self.verProc = value_
            self.verProc_nsprefix_ = child_.prefix
            # validate type verProcType
            self.validate_verProcType(self.verProc)
        elif nodeName_ == 'cMunEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMunEnv')
            value_ = self.gds_validate_string(value_, node, 'cMunEnv')
            self.cMunEnv = value_
            self.cMunEnv_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunEnv)
        elif nodeName_ == 'xMunEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMunEnv')
            value_ = self.gds_validate_string(value_, node, 'xMunEnv')
            self.xMunEnv = value_
            self.xMunEnv_nsprefix_ = child_.prefix
            # validate type xMunEnvType
            self.validate_xMunEnvType(self.xMunEnv)
        elif nodeName_ == 'UFEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UFEnv')
            value_ = self.gds_validate_string(value_, node, 'UFEnv')
            self.UFEnv = value_
            self.UFEnv_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UFEnv)
        elif nodeName_ == 'modal':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'modal')
            value_ = self.gds_validate_string(value_, node, 'modal')
            self.modal = value_
            self.modal_nsprefix_ = child_.prefix
            # validate type modalType
            self.validate_modalType(self.modal)
        elif nodeName_ == 'tpServ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpServ')
            value_ = self.gds_validate_string(value_, node, 'tpServ')
            self.tpServ = value_
            self.tpServ_nsprefix_ = child_.prefix
            # validate type tpServType
            self.validate_tpServType(self.tpServ)
        elif nodeName_ == 'indIEToma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indIEToma')
            value_ = self.gds_validate_string(value_, node, 'indIEToma')
            self.indIEToma = value_
            self.indIEToma_nsprefix_ = child_.prefix
            # validate type indIETomaType
            self.validate_indIETomaType(self.indIEToma)
        elif nodeName_ == 'dhSaidaOrig':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhSaidaOrig')
            value_ = self.gds_validate_string(value_, node, 'dhSaidaOrig')
            self.dhSaidaOrig = value_
            self.dhSaidaOrig_nsprefix_ = child_.prefix
            # validate type dhSaidaOrigType
            self.validate_dhSaidaOrigType(self.dhSaidaOrig)
        elif nodeName_ == 'dhChegadaDest':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhChegadaDest')
            value_ = self.gds_validate_string(value_, node, 'dhChegadaDest')
            self.dhChegadaDest = value_
            self.dhChegadaDest_nsprefix_ = child_.prefix
            # validate type dhChegadaDestType
            self.validate_dhChegadaDestType(self.dhChegadaDest)
        elif nodeName_ == 'toma':
            obj_ = tomaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toma = obj_
            obj_.original_tagname_ = 'toma'
        elif nodeName_ == 'tomaTerceiro':
            obj_ = tomaTerceiroType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tomaTerceiro = obj_
            obj_.original_tagname_ = 'tomaTerceiro'
        elif nodeName_ == 'dhCont':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhCont')
            value_ = self.gds_validate_string(value_, node, 'dhCont')
            self.dhCont = value_
            self.dhCont_nsprefix_ = child_.prefix
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhCont)
        elif nodeName_ == 'xJust':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xJust')
            value_ = self.gds_validate_string(value_, node, 'xJust')
            self.xJust = value_
            self.xJust_nsprefix_ = child_.prefix
            # validate type xJustType
            self.validate_xJustType(self.xJust)
# end class ideType


class tomaType(GeneratedsSuper):
    """tomaType -- Indicador do "papel" do tomador do servi
    ç
    o no GT-e
    toma -- Tomador do Servi
    ç
    o
    Preencher com:
    0-Remetente;
    1-Destinat
    á
    rio
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, toma=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.toma = toma
        self.validate_tomaType1(self.toma)
        self.toma_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tomaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tomaType.subclass:
            return tomaType.subclass(*args_, **kwargs_)
        else:
            return tomaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_toma(self):
        return self.toma
    def set_toma(self, toma):
        self.toma = toma
    def validate_tomaType1(self, value):
        result = True
        # Validate type tomaType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tomaType1' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.toma is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tomaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tomaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tomaType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tomaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tomaType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.toma is not None:
            namespaceprefix_ = self.toma_nsprefix_ + ':' if (UseCapturedNS_ and self.toma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoma>%s</%stoma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.toma), input_name='toma')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'toma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'toma')
            value_ = self.gds_validate_string(value_, node, 'toma')
            self.toma = value_
            self.toma_nsprefix_ = child_.prefix
            # validate type tomaType1
            self.validate_tomaType1(self.toma)
# end class tomaType


class tomaTerceiroType(GeneratedsSuper):
    """tomaTerceiroType -- Indicador do "papel" do tomador do servi
    ç
    o no CTV-e
    toma -- Tomador do Servi
    ç
    o
    Preencher com:
    4 - Outros
    Obs: Informar os dados cadastrais do tomador do servi
    ç
    o
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do tomador ou ISENTO se tomador
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o tomador n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar o conte
    ú
    do.
    xNome -- Raz
    ã
    o Social ou Nome
    xFant -- Nome Fantasia
    fone -- Telefone
    enderToma -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, toma=None, CNPJ=None, CPF=None, IE=None, xNome=None, xFant=None, fone=None, enderToma=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.toma = toma
        self.validate_tomaType2(self.toma)
        self.toma_nsprefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType(self.xNome)
        self.xNome_nsprefix_ = None
        self.xFant = xFant
        self.validate_xFantType(self.xFant)
        self.xFant_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.enderToma = enderToma
        self.enderToma_nsprefix_ = None
        self.email = email
        self.validate_TEmail(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tomaTerceiroType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tomaTerceiroType.subclass:
            return tomaTerceiroType.subclass(*args_, **kwargs_)
        else:
            return tomaTerceiroType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_toma(self):
        return self.toma
    def set_toma(self, toma):
        self.toma = toma
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_enderToma(self):
        return self.enderToma
    def set_enderToma(self, enderToma):
        self.enderToma = enderToma
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_tomaType2(self, value):
        result = True
        # Validate type tomaType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['4']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tomaType2' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType(self, value):
        result = True
        # Validate type IEType, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType_patterns_, ))
                result = False
        return result
    validate_IEType_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType(self, value):
        result = True
        # Validate type xNomeType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType_patterns_, ))
                result = False
        return result
    validate_xNomeType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xFantType(self, value):
        result = True
        # Validate type xFantType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xFantType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xFantType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xFantType_patterns_, ))
                result = False
        return result
    validate_xFantType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_TEmail(self, value):
        result = True
        # Validate type TEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TEmail_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TEmail_patterns_, ))
                result = False
        return result
    validate_TEmail_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.toma is not None or
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.fone is not None or
            self.enderToma is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaTerceiroType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tomaTerceiroType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tomaTerceiroType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tomaTerceiroType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tomaTerceiroType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tomaTerceiroType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaTerceiroType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.toma is not None:
            namespaceprefix_ = self.toma_nsprefix_ + ':' if (UseCapturedNS_ and self.toma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoma>%s</%stoma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.toma), input_name='toma')), namespaceprefix_ , eol_))
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            namespaceprefix_ = self.xFant_nsprefix_ + ':' if (UseCapturedNS_ and self.xFant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.enderToma is not None:
            namespaceprefix_ = self.enderToma_nsprefix_ + ':' if (UseCapturedNS_ and self.enderToma_nsprefix_) else ''
            self.enderToma.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderToma', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'toma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'toma')
            value_ = self.gds_validate_string(value_, node, 'toma')
            self.toma = value_
            self.toma_nsprefix_ = child_.prefix
            # validate type tomaType2
            self.validate_tomaType2(self.toma)
        elif nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType
            self.validate_IEType(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType
            self.validate_xNomeType(self.xNome)
        elif nodeName_ == 'xFant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xFant')
            value_ = self.gds_validate_string(value_, node, 'xFant')
            self.xFant = value_
            self.xFant_nsprefix_ = child_.prefix
            # validate type xFantType
            self.validate_xFantType(self.xFant)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'enderToma':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderToma = obj_
            obj_.original_tagname_ = 'enderToma'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class tomaTerceiroType


class complType(GeneratedsSuper):
    """complType -- Dados complementares da GTV-e para fins operacionais ou comerciais
    xCaracAd -- Caracter
    í
    stica adicional do transporte
    Texto livre:
    REENTREGA; DEVOLU
    Ç
    Ã
    O; REFATURAMENTO; etc
    xCaracSer -- Caracter
    í
    stica adicional do servi
    ç
    o
    Texto livre:
    ENTREGA EXPRESSA; LOG
    Í
    STICA REVERSA; CONVENCIONAL; EMERGENCIAL; etc
    xEmi -- Funcion
    á
    rio emissor da GTV-e
    xObs -- Observa
    ç
    õ
    es Gerais
    ObsCont -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    ObsFisco -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCaracAd=None, xCaracSer=None, xEmi=None, xObs=None, ObsCont=None, ObsFisco=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCaracAd = xCaracAd
        self.validate_xCaracAdType(self.xCaracAd)
        self.xCaracAd_nsprefix_ = None
        self.xCaracSer = xCaracSer
        self.validate_xCaracSerType(self.xCaracSer)
        self.xCaracSer_nsprefix_ = None
        self.xEmi = xEmi
        self.validate_xEmiType(self.xEmi)
        self.xEmi_nsprefix_ = None
        self.xObs = xObs
        self.validate_xObsType(self.xObs)
        self.xObs_nsprefix_ = None
        if ObsCont is None:
            self.ObsCont = []
        else:
            self.ObsCont = ObsCont
        self.ObsCont_nsprefix_ = None
        if ObsFisco is None:
            self.ObsFisco = []
        else:
            self.ObsFisco = ObsFisco
        self.ObsFisco_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complType.subclass:
            return complType.subclass(*args_, **kwargs_)
        else:
            return complType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xCaracAd(self):
        return self.xCaracAd
    def set_xCaracAd(self, xCaracAd):
        self.xCaracAd = xCaracAd
    def get_xCaracSer(self):
        return self.xCaracSer
    def set_xCaracSer(self, xCaracSer):
        self.xCaracSer = xCaracSer
    def get_xEmi(self):
        return self.xEmi
    def set_xEmi(self, xEmi):
        self.xEmi = xEmi
    def get_xObs(self):
        return self.xObs
    def set_xObs(self, xObs):
        self.xObs = xObs
    def get_ObsCont(self):
        return self.ObsCont
    def set_ObsCont(self, ObsCont):
        self.ObsCont = ObsCont
    def add_ObsCont(self, value):
        self.ObsCont.append(value)
    def insert_ObsCont_at(self, index, value):
        self.ObsCont.insert(index, value)
    def replace_ObsCont_at(self, index, value):
        self.ObsCont[index] = value
    def get_ObsFisco(self):
        return self.ObsFisco
    def set_ObsFisco(self, ObsFisco):
        self.ObsFisco = ObsFisco
    def add_ObsFisco(self, value):
        self.ObsFisco.append(value)
    def insert_ObsFisco_at(self, index, value):
        self.ObsFisco.insert(index, value)
    def replace_ObsFisco_at(self, index, value):
        self.ObsFisco[index] = value
    def validate_xCaracAdType(self, value):
        result = True
        # Validate type xCaracAdType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCaracAdType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCaracAdType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCaracAdType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCaracAdType_patterns_, ))
                result = False
        return result
    validate_xCaracAdType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCaracSerType(self, value):
        result = True
        # Validate type xCaracSerType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCaracSerType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCaracSerType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCaracSerType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCaracSerType_patterns_, ))
                result = False
        return result
    validate_xCaracSerType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xEmiType(self, value):
        result = True
        # Validate type xEmiType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xEmiType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xEmiType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xEmiType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xEmiType_patterns_, ))
                result = False
        return result
    validate_xEmiType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xObsType(self, value):
        result = True
        # Validate type xObsType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xObsType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xObsType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xObsType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xObsType_patterns_, ))
                result = False
        return result
    validate_xObsType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xCaracAd is not None or
            self.xCaracSer is not None or
            self.xEmi is not None or
            self.xObs is not None or
            self.ObsCont or
            self.ObsFisco
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='complType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='complType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='complType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xCaracAd is not None:
            namespaceprefix_ = self.xCaracAd_nsprefix_ + ':' if (UseCapturedNS_ and self.xCaracAd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCaracAd>%s</%sxCaracAd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCaracAd), input_name='xCaracAd')), namespaceprefix_ , eol_))
        if self.xCaracSer is not None:
            namespaceprefix_ = self.xCaracSer_nsprefix_ + ':' if (UseCapturedNS_ and self.xCaracSer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCaracSer>%s</%sxCaracSer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCaracSer), input_name='xCaracSer')), namespaceprefix_ , eol_))
        if self.xEmi is not None:
            namespaceprefix_ = self.xEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.xEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxEmi>%s</%sxEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xEmi), input_name='xEmi')), namespaceprefix_ , eol_))
        if self.xObs is not None:
            namespaceprefix_ = self.xObs_nsprefix_ + ':' if (UseCapturedNS_ and self.xObs_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxObs>%s</%sxObs>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xObs), input_name='xObs')), namespaceprefix_ , eol_))
        for ObsCont_ in self.ObsCont:
            namespaceprefix_ = self.ObsCont_nsprefix_ + ':' if (UseCapturedNS_ and self.ObsCont_nsprefix_) else ''
            ObsCont_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObsCont', pretty_print=pretty_print)
        for ObsFisco_ in self.ObsFisco:
            namespaceprefix_ = self.ObsFisco_nsprefix_ + ':' if (UseCapturedNS_ and self.ObsFisco_nsprefix_) else ''
            ObsFisco_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObsFisco', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xCaracAd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCaracAd')
            value_ = self.gds_validate_string(value_, node, 'xCaracAd')
            self.xCaracAd = value_
            self.xCaracAd_nsprefix_ = child_.prefix
            # validate type xCaracAdType
            self.validate_xCaracAdType(self.xCaracAd)
        elif nodeName_ == 'xCaracSer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCaracSer')
            value_ = self.gds_validate_string(value_, node, 'xCaracSer')
            self.xCaracSer = value_
            self.xCaracSer_nsprefix_ = child_.prefix
            # validate type xCaracSerType
            self.validate_xCaracSerType(self.xCaracSer)
        elif nodeName_ == 'xEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xEmi')
            value_ = self.gds_validate_string(value_, node, 'xEmi')
            self.xEmi = value_
            self.xEmi_nsprefix_ = child_.prefix
            # validate type xEmiType
            self.validate_xEmiType(self.xEmi)
        elif nodeName_ == 'xObs':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xObs')
            value_ = self.gds_validate_string(value_, node, 'xObs')
            self.xObs = value_
            self.xObs_nsprefix_ = child_.prefix
            # validate type xObsType
            self.validate_xObsType(self.xObs)
        elif nodeName_ == 'ObsCont':
            obj_ = ObsContType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsCont.append(obj_)
            obj_.original_tagname_ = 'ObsCont'
        elif nodeName_ == 'ObsFisco':
            obj_ = ObsFiscoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsFisco.append(obj_)
            obj_.original_tagname_ = 'ObsFisco'
# end class complType


class ObsContType(GeneratedsSuper):
    """ObsContType -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    xCampo -- Identifica
    ç
    ã
    o do campo
    xTexto -- Conte
    ú
    do do campo
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCampo = _cast(None, xCampo)
        self.xCampo_nsprefix_ = None
        self.xTexto = xTexto
        self.validate_xTextoType(self.xTexto)
        self.xTexto_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsContType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsContType.subclass:
            return ObsContType.subclass(*args_, **kwargs_)
        else:
            return ObsContType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xTexto(self):
        return self.xTexto
    def set_xTexto(self, xTexto):
        self.xTexto = xTexto
    def get_xCampo(self):
        return self.xCampo
    def set_xCampo(self, xCampo):
        self.xCampo = xCampo
    def validate_xTextoType(self, value):
        result = True
        # Validate type xTextoType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 160:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xTextoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xTextoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xTextoType_patterns_, ))
                result = False
        return result
    validate_xTextoType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCampoType(self, value):
        # Validate type xCampoType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCampoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCampoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCampoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCampoType_patterns_, ))
    validate_xCampoType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsContType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsContType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObsContType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsContType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsContType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsContType'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsContType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            namespaceprefix_ = self.xTexto_nsprefix_ + ':' if (UseCapturedNS_ and self.xTexto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxTexto>%s</%sxTexto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_xCampoType(self.xCampo)    # validate type xCampoType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xTexto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xTexto')
            value_ = self.gds_validate_string(value_, node, 'xTexto')
            self.xTexto = value_
            self.xTexto_nsprefix_ = child_.prefix
            # validate type xTextoType
            self.validate_xTextoType(self.xTexto)
# end class ObsContType


class ObsFiscoType(GeneratedsSuper):
    """ObsFiscoType -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    xCampo -- Identifica
    ç
    ã
    o do campo
    xTexto -- Conte
    ú
    do do campo
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCampo = _cast(None, xCampo)
        self.xCampo_nsprefix_ = None
        self.xTexto = xTexto
        self.validate_xTextoType3(self.xTexto)
        self.xTexto_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsFiscoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsFiscoType.subclass:
            return ObsFiscoType.subclass(*args_, **kwargs_)
        else:
            return ObsFiscoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xTexto(self):
        return self.xTexto
    def set_xTexto(self, xTexto):
        self.xTexto = xTexto
    def get_xCampo(self):
        return self.xCampo
    def set_xCampo(self, xCampo):
        self.xCampo = xCampo
    def validate_xTextoType3(self, value):
        result = True
        # Validate type xTextoType3, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xTextoType3' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xTextoType3' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType3_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xTextoType3_patterns_, ))
                result = False
        return result
    validate_xTextoType3_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCampoType4(self, value):
        # Validate type xCampoType4, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCampoType4' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCampoType4' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCampoType4_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCampoType4_patterns_, ))
    validate_xCampoType4_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsFiscoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsFiscoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObsFiscoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsFiscoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsFiscoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsFiscoType'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsFiscoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            namespaceprefix_ = self.xTexto_nsprefix_ + ':' if (UseCapturedNS_ and self.xTexto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxTexto>%s</%sxTexto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_xCampoType4(self.xCampo)    # validate type xCampoType4
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xTexto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xTexto')
            value_ = self.gds_validate_string(value_, node, 'xTexto')
            self.xTexto = value_
            self.xTexto_nsprefix_ = child_.prefix
            # validate type xTextoType3
            self.validate_xTextoType3(self.xTexto)
# end class ObsFiscoType


class emitType(GeneratedsSuper):
    """emitType -- Identifica
    ç
    ã
    o do Emitente da GTV-e
    CNPJ -- CNPJ do emitente
    Informar zeros n
    ã
    o significativos
    IE -- Inscri
    ç
    ã
    o Estadual do Emitente
    IEST -- Inscri
    ç
    ã
    o Estadual do Substituto Tribut
    á
    rio
    xNome -- Raz
    ã
    o social ou Nome do emitente
    xFant -- Nome fantasia
    enderEmit -- Endere
    ç
    o do emitente
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, IE=None, IEST=None, xNome=None, xFant=None, enderEmit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.IE = IE
        self.validate_IEType5(self.IE)
        self.IE_nsprefix_ = None
        self.IEST = IEST
        self.validate_IESTType(self.IEST)
        self.IEST_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType6(self.xNome)
        self.xNome_nsprefix_ = None
        self.xFant = xFant
        self.validate_xFantType7(self.xFant)
        self.xFant_nsprefix_ = None
        self.enderEmit = enderEmit
        self.enderEmit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emitType.subclass:
            return emitType.subclass(*args_, **kwargs_)
        else:
            return emitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_IEST(self):
        return self.IEST
    def set_IEST(self, IEST):
        self.IEST = IEST
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_enderEmit(self):
        return self.enderEmit
    def set_enderEmit(self, enderEmit):
        self.enderEmit = enderEmit
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_IEType5(self, value):
        result = True
        # Validate type IEType5, a restriction on TIe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType5' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType5_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType5_patterns_, ))
                result = False
        return result
    validate_IEType5_patterns_ = [['^([0-9]{2,14})$']]
    def validate_IESTType(self, value):
        result = True
        # Validate type IESTType, a restriction on TIe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IESTType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IESTType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IESTType_patterns_, ))
                result = False
        return result
    validate_IESTType_patterns_ = [['^([0-9]{2,14})$']]
    def validate_xNomeType6(self, value):
        result = True
        # Validate type xNomeType6, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType6' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType6' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType6_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType6_patterns_, ))
                result = False
        return result
    validate_xNomeType6_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xFantType7(self, value):
        result = True
        # Validate type xFantType7, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xFantType7' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xFantType7' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType7_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xFantType7_patterns_, ))
                result = False
        return result
    validate_xFantType7_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.IE is not None or
            self.IEST is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='emitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'emitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='emitType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='emitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='emitType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='emitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.IEST is not None:
            namespaceprefix_ = self.IEST_nsprefix_ + ':' if (UseCapturedNS_ and self.IEST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIEST>%s</%sIEST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IEST), input_name='IEST')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            namespaceprefix_ = self.xFant_nsprefix_ + ':' if (UseCapturedNS_ and self.xFant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.enderEmit is not None:
            namespaceprefix_ = self.enderEmit_nsprefix_ + ':' if (UseCapturedNS_ and self.enderEmit_nsprefix_) else ''
            self.enderEmit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderEmit', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType5
            self.validate_IEType5(self.IE)
        elif nodeName_ == 'IEST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IEST')
            value_ = self.gds_validate_string(value_, node, 'IEST')
            self.IEST = value_
            self.IEST_nsprefix_ = child_.prefix
            # validate type IESTType
            self.validate_IESTType(self.IEST)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType6
            self.validate_xNomeType6(self.xNome)
        elif nodeName_ == 'xFant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xFant')
            value_ = self.gds_validate_string(value_, node, 'xFant')
            self.xFant = value_
            self.xFant_nsprefix_ = child_.prefix
            # validate type xFantType7
            self.validate_xFantType7(self.xFant)
        elif nodeName_ == 'enderEmit':
            obj_ = TEndeEmi.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
# end class emitType


class remType(GeneratedsSuper):
    """remType -- Informa
    ç
    õ
    es do Remetente
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do remetente ou ISENTO se remetente
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o remetente n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar a tag.
    xNome -- Raz
    ã
    o social ou nome do remetente
    xFant -- Nome fantasia
    fone -- Telefone
    enderReme -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, xFant=None, fone=None, enderReme=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType8(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType9(self.xNome)
        self.xNome_nsprefix_ = None
        self.xFant = xFant
        self.validate_xFantType10(self.xFant)
        self.xFant_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.enderReme = enderReme
        self.enderReme_nsprefix_ = None
        self.email = email
        self.validate_emailType(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remType.subclass:
            return remType.subclass(*args_, **kwargs_)
        else:
            return remType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_enderReme(self):
        return self.enderReme
    def set_enderReme(self, enderReme):
        self.enderReme = enderReme
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType8(self, value):
        result = True
        # Validate type IEType8, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType8' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType8_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType8_patterns_, ))
                result = False
        return result
    validate_IEType8_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType9(self, value):
        result = True
        # Validate type xNomeType9, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType9' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType9' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType9_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType9_patterns_, ))
                result = False
        return result
    validate_xNomeType9_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xFantType10(self, value):
        result = True
        # Validate type xFantType10, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xFantType10' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xFantType10' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType10_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xFantType10_patterns_, ))
                result = False
        return result
    validate_xFantType10_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_emailType(self, value):
        result = True
        # Validate type emailType, a restriction on TEmail.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType_patterns_, ))
                result = False
        return result
    validate_emailType_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.fone is not None or
            self.enderReme is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='remType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'remType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='remType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='remType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='remType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            namespaceprefix_ = self.xFant_nsprefix_ + ':' if (UseCapturedNS_ and self.xFant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.enderReme is not None:
            namespaceprefix_ = self.enderReme_nsprefix_ + ':' if (UseCapturedNS_ and self.enderReme_nsprefix_) else ''
            self.enderReme.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderReme', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType8
            self.validate_IEType8(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType9
            self.validate_xNomeType9(self.xNome)
        elif nodeName_ == 'xFant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xFant')
            value_ = self.gds_validate_string(value_, node, 'xFant')
            self.xFant = value_
            self.xFant_nsprefix_ = child_.prefix
            # validate type xFantType10
            self.validate_xFantType10(self.xFant)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'enderReme':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderReme = obj_
            obj_.original_tagname_ = 'enderReme'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType
            self.validate_emailType(self.email)
# end class remType


class destType(GeneratedsSuper):
    """destType -- Informa
    ç
    õ
    es do Destinat
    á
    rio
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do destinat
    á
    rio ou ISENTO se destinat
    á
    rio
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o destinat
    á
    rio n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar o conte
    ú
    do.
    xNome -- Raz
    ã
    o Social ou Nome do destinat
    á
    rio
    fone -- Telefone
    ISUF -- Inscri
    ç
    ã
    o na SUFRAMA
    (Obrigat
    ó
    rio nas opera
    ç
    õ
    es com as
    á
    reas com benef
    í
    cios de incentivos fiscais sob controle da SUFRAMA)
    enderDest -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, fone=None, ISUF=None, enderDest=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType11(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType12(self.xNome)
        self.xNome_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.ISUF = ISUF
        self.validate_ISUFType(self.ISUF)
        self.ISUF_nsprefix_ = None
        self.enderDest = enderDest
        self.enderDest_nsprefix_ = None
        self.email = email
        self.validate_TEmail(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, destType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if destType.subclass:
            return destType.subclass(*args_, **kwargs_)
        else:
            return destType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_ISUF(self):
        return self.ISUF
    def set_ISUF(self, ISUF):
        self.ISUF = ISUF
    def get_enderDest(self):
        return self.enderDest
    def set_enderDest(self, enderDest):
        self.enderDest = enderDest
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType11(self, value):
        result = True
        # Validate type IEType11, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType11' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType11_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType11_patterns_, ))
                result = False
        return result
    validate_IEType11_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType12(self, value):
        result = True
        # Validate type xNomeType12, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType12' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType12' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType12_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType12_patterns_, ))
                result = False
        return result
    validate_xNomeType12_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_ISUFType(self, value):
        result = True
        # Validate type ISUFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ISUFType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ISUFType_patterns_, ))
                result = False
        return result
    validate_ISUFType_patterns_ = [['^([0-9]{8,9})$']]
    def validate_TEmail(self, value):
        result = True
        # Validate type TEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TEmail_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TEmail_patterns_, ))
                result = False
        return result
    validate_TEmail_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.fone is not None or
            self.ISUF is not None or
            self.enderDest is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='destType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('destType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'destType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='destType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='destType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='destType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='destType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.ISUF is not None:
            namespaceprefix_ = self.ISUF_nsprefix_ + ':' if (UseCapturedNS_ and self.ISUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISUF>%s</%sISUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISUF), input_name='ISUF')), namespaceprefix_ , eol_))
        if self.enderDest is not None:
            namespaceprefix_ = self.enderDest_nsprefix_ + ':' if (UseCapturedNS_ and self.enderDest_nsprefix_) else ''
            self.enderDest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderDest', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType11
            self.validate_IEType11(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType12
            self.validate_xNomeType12(self.xNome)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'ISUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISUF')
            value_ = self.gds_validate_string(value_, node, 'ISUF')
            self.ISUF = value_
            self.ISUF_nsprefix_ = child_.prefix
            # validate type ISUFType
            self.validate_ISUFType(self.ISUF)
        elif nodeName_ == 'enderDest':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderDest = obj_
            obj_.original_tagname_ = 'enderDest'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class destType


class detGTVType(GeneratedsSuper):
    """detGTVType -- Grupo de informa
    ç
    õ
    es detalhadas da GTV-e
    infEspecie -- Informa
    ç
    õ
    es das Esp
    é
    cies transportadas
    qCarga -- Quantidade de volumes/malotes
    infVeiculo -- Grupo de informa
    ç
    õ
    es dos ve
    í
    culos utilizados no transporte de valores
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, infEspecie=None, qCarga=None, infVeiculo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if infEspecie is None:
            self.infEspecie = []
        else:
            self.infEspecie = infEspecie
        self.infEspecie_nsprefix_ = None
        self.qCarga = qCarga
        self.validate_TDec_1104(self.qCarga)
        self.qCarga_nsprefix_ = None
        if infVeiculo is None:
            self.infVeiculo = []
        else:
            self.infVeiculo = infVeiculo
        self.infVeiculo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detGTVType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detGTVType.subclass:
            return detGTVType.subclass(*args_, **kwargs_)
        else:
            return detGTVType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infEspecie(self):
        return self.infEspecie
    def set_infEspecie(self, infEspecie):
        self.infEspecie = infEspecie
    def add_infEspecie(self, value):
        self.infEspecie.append(value)
    def insert_infEspecie_at(self, index, value):
        self.infEspecie.insert(index, value)
    def replace_infEspecie_at(self, index, value):
        self.infEspecie[index] = value
    def get_qCarga(self):
        return self.qCarga
    def set_qCarga(self, qCarga):
        self.qCarga = qCarga
    def get_infVeiculo(self):
        return self.infVeiculo
    def set_infVeiculo(self, infVeiculo):
        self.infVeiculo = infVeiculo
    def add_infVeiculo(self, value):
        self.infVeiculo.append(value)
    def insert_infVeiculo_at(self, index, value):
        self.infVeiculo.insert(index, value)
    def replace_infVeiculo_at(self, index, value):
        self.infVeiculo[index] = value
    def validate_TDec_1104(self, value):
        result = True
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1104_patterns_, ))
                result = False
        return result
    validate_TDec_1104_patterns_ = [['^(0|0\\.[0-9]{4}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?)$']]
    def _hasContent(self):
        if (
            self.infEspecie or
            self.qCarga is not None or
            self.infVeiculo
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='detGTVType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detGTVType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'detGTVType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detGTVType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='detGTVType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detGTVType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='detGTVType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for infEspecie_ in self.infEspecie:
            namespaceprefix_ = self.infEspecie_nsprefix_ + ':' if (UseCapturedNS_ and self.infEspecie_nsprefix_) else ''
            infEspecie_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infEspecie', pretty_print=pretty_print)
        if self.qCarga is not None:
            namespaceprefix_ = self.qCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.qCarga_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqCarga>%s</%sqCarga>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qCarga), input_name='qCarga')), namespaceprefix_ , eol_))
        for infVeiculo_ in self.infVeiculo:
            namespaceprefix_ = self.infVeiculo_nsprefix_ + ':' if (UseCapturedNS_ and self.infVeiculo_nsprefix_) else ''
            infVeiculo_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infVeiculo', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infEspecie':
            obj_ = infEspecieType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infEspecie.append(obj_)
            obj_.original_tagname_ = 'infEspecie'
        elif nodeName_ == 'qCarga':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qCarga')
            value_ = self.gds_validate_string(value_, node, 'qCarga')
            self.qCarga = value_
            self.qCarga_nsprefix_ = child_.prefix
            # validate type TDec_1104
            self.validate_TDec_1104(self.qCarga)
        elif nodeName_ == 'infVeiculo':
            obj_ = infVeiculoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infVeiculo.append(obj_)
            obj_.original_tagname_ = 'infVeiculo'
# end class detGTVType


class infEspecieType(GeneratedsSuper):
    """infEspecieType -- Informa
    ç
    õ
    es das Esp
    é
    cies transportadas
    tpEspecie -- Tipo da Esp
    é
    cie
    1 - C
    é
    dula
    2 - Cheque
    3 - Moeda
    4 - Outros
    vEspecie -- Valor Transportada em Esp
    é
    cie indicada
    tpNumerario -- Nacionalidade do Numer
    á
    rio
    1 - Nacional
    2 - Estrangeiro
    xMoedaEstr -- Nome da Moeda
    Informar somente se tipo de numer
    á
    rio for 2 - Estrangeiro
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpEspecie=None, vEspecie=None, tpNumerario=None, xMoedaEstr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpEspecie = tpEspecie
        self.validate_tpEspecieType(self.tpEspecie)
        self.tpEspecie_nsprefix_ = None
        self.vEspecie = vEspecie
        self.validate_TDec_1302(self.vEspecie)
        self.vEspecie_nsprefix_ = None
        self.tpNumerario = tpNumerario
        self.validate_tpNumerarioType(self.tpNumerario)
        self.tpNumerario_nsprefix_ = None
        self.xMoedaEstr = xMoedaEstr
        self.validate_xMoedaEstrType(self.xMoedaEstr)
        self.xMoedaEstr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infEspecieType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infEspecieType.subclass:
            return infEspecieType.subclass(*args_, **kwargs_)
        else:
            return infEspecieType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpEspecie(self):
        return self.tpEspecie
    def set_tpEspecie(self, tpEspecie):
        self.tpEspecie = tpEspecie
    def get_vEspecie(self):
        return self.vEspecie
    def set_vEspecie(self, vEspecie):
        self.vEspecie = vEspecie
    def get_tpNumerario(self):
        return self.tpNumerario
    def set_tpNumerario(self, tpNumerario):
        self.tpNumerario = tpNumerario
    def get_xMoedaEstr(self):
        return self.xMoedaEstr
    def set_xMoedaEstr(self, xMoedaEstr):
        self.xMoedaEstr = xMoedaEstr
    def validate_tpEspecieType(self, value):
        result = True
        # Validate type tpEspecieType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3', '4']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpEspecieType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_tpNumerarioType(self, value):
        result = True
        # Validate type tpNumerarioType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpNumerarioType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_xMoedaEstrType(self, value):
        result = True
        # Validate type xMoedaEstrType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMoedaEstrType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMoedaEstrType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMoedaEstrType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMoedaEstrType_patterns_, ))
                result = False
        return result
    validate_xMoedaEstrType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.tpEspecie is not None or
            self.vEspecie is not None or
            self.tpNumerario is not None or
            self.xMoedaEstr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infEspecieType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infEspecieType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infEspecieType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infEspecieType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infEspecieType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infEspecieType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infEspecieType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpEspecie is not None:
            namespaceprefix_ = self.tpEspecie_nsprefix_ + ':' if (UseCapturedNS_ and self.tpEspecie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpEspecie>%s</%stpEspecie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpEspecie), input_name='tpEspecie')), namespaceprefix_ , eol_))
        if self.vEspecie is not None:
            namespaceprefix_ = self.vEspecie_nsprefix_ + ':' if (UseCapturedNS_ and self.vEspecie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svEspecie>%s</%svEspecie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vEspecie), input_name='vEspecie')), namespaceprefix_ , eol_))
        if self.tpNumerario is not None:
            namespaceprefix_ = self.tpNumerario_nsprefix_ + ':' if (UseCapturedNS_ and self.tpNumerario_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpNumerario>%s</%stpNumerario>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpNumerario), input_name='tpNumerario')), namespaceprefix_ , eol_))
        if self.xMoedaEstr is not None:
            namespaceprefix_ = self.xMoedaEstr_nsprefix_ + ':' if (UseCapturedNS_ and self.xMoedaEstr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMoedaEstr>%s</%sxMoedaEstr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMoedaEstr), input_name='xMoedaEstr')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpEspecie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpEspecie')
            value_ = self.gds_validate_string(value_, node, 'tpEspecie')
            self.tpEspecie = value_
            self.tpEspecie_nsprefix_ = child_.prefix
            # validate type tpEspecieType
            self.validate_tpEspecieType(self.tpEspecie)
        elif nodeName_ == 'vEspecie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vEspecie')
            value_ = self.gds_validate_string(value_, node, 'vEspecie')
            self.vEspecie = value_
            self.vEspecie_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vEspecie)
        elif nodeName_ == 'tpNumerario':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpNumerario')
            value_ = self.gds_validate_string(value_, node, 'tpNumerario')
            self.tpNumerario = value_
            self.tpNumerario_nsprefix_ = child_.prefix
            # validate type tpNumerarioType
            self.validate_tpNumerarioType(self.tpNumerario)
        elif nodeName_ == 'xMoedaEstr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMoedaEstr')
            value_ = self.gds_validate_string(value_, node, 'xMoedaEstr')
            self.xMoedaEstr = value_
            self.xMoedaEstr_nsprefix_ = child_.prefix
            # validate type xMoedaEstrType
            self.validate_xMoedaEstrType(self.xMoedaEstr)
# end class infEspecieType


class infVeiculoType(GeneratedsSuper):
    """infVeiculoType -- Grupo de informa
    ç
    õ
    es dos ve
    í
    culos utilizados no transporte de valores
    placa -- Placa do ve
    í
    culo
    UF -- UF em que ve
    í
    culo est
    á
    licenciado
    Sigla da UF de licenciamento do ve
    í
    culo.
    RNTRC -- RNTRC do transportador
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, placa=None, UF=None, RNTRC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.placa = placa
        self.validate_TPlaca(self.placa)
        self.placa_nsprefix_ = None
        self.UF = UF
        self.validate_TUf(self.UF)
        self.UF_nsprefix_ = None
        self.RNTRC = RNTRC
        self.validate_RNTRCType(self.RNTRC)
        self.RNTRC_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infVeiculoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infVeiculoType.subclass:
            return infVeiculoType.subclass(*args_, **kwargs_)
        else:
            return infVeiculoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_placa(self):
        return self.placa
    def set_placa(self, placa):
        self.placa = placa
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_RNTRC(self):
        return self.RNTRC
    def set_RNTRC(self, RNTRC):
        self.RNTRC = RNTRC
    def validate_TPlaca(self, value):
        result = True
        # Validate type TPlaca, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TPlaca_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TPlaca_patterns_, ))
                result = False
        return result
    validate_TPlaca_patterns_ = [['^([A-Z]{2,3}[0-9]{4}|[A-Z]{3,4}[0-9]{3}|[A-Z0-9]{7})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_RNTRCType(self, value):
        result = True
        # Validate type RNTRCType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_RNTRCType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_RNTRCType_patterns_, ))
                result = False
        return result
    validate_RNTRCType_patterns_ = [['^([0-9]{8}|ISENTO)$']]
    def _hasContent(self):
        if (
            self.placa is not None or
            self.UF is not None or
            self.RNTRC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infVeiculoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infVeiculoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infVeiculoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infVeiculoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infVeiculoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infVeiculoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infVeiculoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.placa is not None:
            namespaceprefix_ = self.placa_nsprefix_ + ':' if (UseCapturedNS_ and self.placa_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splaca>%s</%splaca>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.placa), input_name='placa')), namespaceprefix_ , eol_))
        if self.UF is not None:
            namespaceprefix_ = self.UF_nsprefix_ + ':' if (UseCapturedNS_ and self.UF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.RNTRC is not None:
            namespaceprefix_ = self.RNTRC_nsprefix_ + ':' if (UseCapturedNS_ and self.RNTRC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRNTRC>%s</%sRNTRC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RNTRC), input_name='RNTRC')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'placa':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'placa')
            value_ = self.gds_validate_string(value_, node, 'placa')
            self.placa = value_
            self.placa_nsprefix_ = child_.prefix
            # validate type TPlaca
            self.validate_TPlaca(self.placa)
        elif nodeName_ == 'UF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UF')
            value_ = self.gds_validate_string(value_, node, 'UF')
            self.UF = value_
            self.UF_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'RNTRC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RNTRC')
            value_ = self.gds_validate_string(value_, node, 'RNTRC')
            self.RNTRC = value_
            self.RNTRC_nsprefix_ = child_.prefix
            # validate type RNTRCType
            self.validate_RNTRCType(self.RNTRC)
# end class infVeiculoType


class autXMLType(GeneratedsSuper):
    """autXMLType -- Autorizados para download do XML do DF-e
    Informar CNPJ ou CPF. Preencher os zeros n
    ã
    o significativos.
    CNPJ -- CNPJ do autorizado
    Informar zeros n
    ã
    o significativos
    CPF -- CPF do autorizado
    Informar zeros n
    ã
    o significativos
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXMLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXMLType.subclass:
            return autXMLType.subclass(*args_, **kwargs_)
        else:
            return autXMLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='autXMLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXMLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'autXMLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='autXMLType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='autXMLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='autXMLType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='autXMLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class autXMLType


class infCTeSuplType(GeneratedsSuper):
    """infCTeSuplType -- Informa
    ç
    õ
    es suplementares da GTV-e
    qrCodCTe -- Texto com o QR-Code impresso no DACTE
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, qrCodCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.qrCodCTe = qrCodCTe
        self.validate_qrCodCTeType(self.qrCodCTe)
        self.qrCodCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeSuplType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeSuplType.subclass:
            return infCTeSuplType.subclass(*args_, **kwargs_)
        else:
            return infCTeSuplType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qrCodCTe(self):
        return self.qrCodCTe
    def set_qrCodCTe(self, qrCodCTe):
        self.qrCodCTe = qrCodCTe
    def validate_qrCodCTeType(self, value):
        result = True
        # Validate type qrCodCTeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on qrCodCTeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on qrCodCTeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_qrCodCTeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_qrCodCTeType_patterns_, ))
                result = False
        return result
    validate_qrCodCTeType_patterns_ = [['^(((HTTPS?|https?)://.*\\?chCTe=[0-9]{44}&tpAmb=[1-2](&sign=[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})?))$']]
    def _hasContent(self):
        if (
            self.qrCodCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeSuplType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeSuplType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCTeSuplType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCTeSuplType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCTeSuplType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCTeSuplType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeSuplType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qrCodCTe is not None:
            namespaceprefix_ = self.qrCodCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.qrCodCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqrCodCTe>%s</%sqrCodCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qrCodCTe), input_name='qrCodCTe')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'qrCodCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qrCodCTe')
            value_ = self.gds_validate_string(value_, node, 'qrCodCTe')
            self.qrCodCTe = value_
            self.qrCodCTe_nsprefix_ = child_.prefix
            # validate type qrCodCTeType
            self.validate_qrCodCTeType(self.qrCodCTe)
# end class infCTeSuplType


class infProtType(GeneratedsSuper):
    """infProtType -- Dados do protocolo de status
    tpAmb -- Identifica
    ç
    ã
    o do Ambiente:
    1 - Produ
    ç
    ã
    o
    2 - Homologa
    ç
    ã
    o
    verAplic -- Vers
    ã
    o do Aplicativo que processou o CT-e
    chCTe -- Chaves de acesso da CT-e,
    dhRecbto -- Data e hora de processamento, no formato AAAA-MM-DDTHH:MM:SS TZD.
    nProt -- N
    ú
    mero do Protocolo de Status do CT-e.
    digVal -- Digest Value da CT-e processado. Utilizado para conferir a integridade do CT-e original.
    cStat -- C
    ó
    digo do status do CT-e.
    xMotivo -- Descri
    ç
    ã
    o literal do status do CT-e.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, tpAmb=None, verAplic=None, chCTe=None, dhRecbto=None, nProt=None, digVal=None, cStat=None, xMotivo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.verAplic_nsprefix_ = None
        self.chCTe = chCTe
        self.validate_TChNFe(self.chCTe)
        self.chCTe_nsprefix_ = None
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.dhRecbto_nsprefix_ = None
        self.nProt = nProt
        self.validate_TProt(self.nProt)
        self.nProt_nsprefix_ = None
        self.digVal = digVal
        self.validate_DigestValueType(self.digVal)
        self.digVal_nsprefix_ = None
        self.cStat = cStat
        self.validate_cStatType(self.cStat)
        self.cStat_nsprefix_ = None
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.xMotivo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infProtType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infProtType.subclass:
            return infProtType.subclass(*args_, **kwargs_)
        else:
            return infProtType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_chCTe(self):
        return self.chCTe
    def set_chCTe(self, chCTe):
        self.chCTe = chCTe
    def get_dhRecbto(self):
        return self.dhRecbto
    def set_dhRecbto(self, dhRecbto):
        self.dhRecbto = dhRecbto
    def get_nProt(self):
        return self.nProt
    def set_nProt(self, nProt):
        self.nProt = nProt
    def get_digVal(self):
        return self.digVal
    def set_digVal(self, digVal):
        self.digVal = digVal
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TVerAplic(self, value):
        result = True
        # Validate type TVerAplic, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TVerAplic' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TVerAplic' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerAplic_patterns_, ))
                result = False
        return result
    validate_TVerAplic_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def validate_TDateTimeUTC(self, value):
        result = True
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDateTimeUTC_patterns_, ))
                result = False
        return result
    validate_TDateTimeUTC_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_TProt(self, value):
        result = True
        # Validate type TProt, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TProt_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TProt_patterns_, ))
                result = False
        return result
    validate_TProt_patterns_ = [['^([0-9]{15})$']]
    def validate_DigestValueType(self, value):
        result = True
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def validate_cStatType(self, value):
        result = True
        # Validate type cStatType, a restriction on TStat.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cStatType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cStatType_patterns_, ))
                result = False
        return result
    validate_cStatType_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.chCTe is not None or
            self.dhRecbto is not None or
            self.nProt is not None or
            self.digVal is not None or
            self.cStat is not None or
            self.xMotivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='infProtType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infProtType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infProtType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infProtType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infProtType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infProtType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='infProtType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            namespaceprefix_ = self.verAplic_nsprefix_ + ':' if (UseCapturedNS_ and self.verAplic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.chCTe is not None:
            namespaceprefix_ = self.chCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.chCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespaceprefix_ , eol_))
        if self.dhRecbto is not None:
            namespaceprefix_ = self.dhRecbto_nsprefix_ + ':' if (UseCapturedNS_ and self.dhRecbto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespaceprefix_ , eol_))
        if self.nProt is not None:
            namespaceprefix_ = self.nProt_nsprefix_ + ':' if (UseCapturedNS_ and self.nProt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snProt>%s</%snProt>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nProt), input_name='nProt')), namespaceprefix_ , eol_))
        if self.digVal is not None:
            namespaceprefix_ = self.digVal_nsprefix_ + ':' if (UseCapturedNS_ and self.digVal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigVal>%s</%sdigVal>%s' % (namespaceprefix_ , self.gds_format_base64(self.digVal, input_name='digVal'), namespaceprefix_ , eol_))
        if self.cStat is not None:
            namespaceprefix_ = self.cStat_nsprefix_ + ':' if (UseCapturedNS_ and self.cStat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            namespaceprefix_ = self.xMotivo_nsprefix_ + ':' if (UseCapturedNS_ and self.xMotivo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verAplic')
            value_ = self.gds_validate_string(value_, node, 'verAplic')
            self.verAplic = value_
            self.verAplic_nsprefix_ = child_.prefix
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'chCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCTe')
            value_ = self.gds_validate_string(value_, node, 'chCTe')
            self.chCTe = value_
            self.chCTe_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.chCTe)
        elif nodeName_ == 'dhRecbto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhRecbto')
            value_ = self.gds_validate_string(value_, node, 'dhRecbto')
            self.dhRecbto = value_
            self.dhRecbto_nsprefix_ = child_.prefix
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'nProt':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nProt')
            value_ = self.gds_validate_string(value_, node, 'nProt')
            self.nProt = value_
            self.nProt_nsprefix_ = child_.prefix
            # validate type TProt
            self.validate_TProt(self.nProt)
        elif nodeName_ == 'digVal':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'digVal')
            else:
                bval_ = None
            self.digVal = bval_
            self.digVal_nsprefix_ = child_.prefix
            # validate type DigestValueType
            self.validate_DigestValueType(self.digVal)
        elif nodeName_ == 'cStat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cStat')
            value_ = self.gds_validate_string(value_, node, 'cStat')
            self.cStat = value_
            self.cStat_nsprefix_ = child_.prefix
            # validate type cStatType
            self.validate_cStatType(self.cStat)
        elif nodeName_ == 'xMotivo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMotivo')
            value_ = self.gds_validate_string(value_, node, 'xMotivo')
            self.xMotivo = value_
            self.xMotivo_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
# end class infProtType


class infFiscoType(GeneratedsSuper):
    """infFiscoType -- Mensagem do Fisco
    cMsg -- C
    ó
    digo do status da mensagem do fisco
    xMsg -- Mensagem do Fisco
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cMsg=None, xMsg=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cMsg = cMsg
        self.validate_cMsgType(self.cMsg)
        self.cMsg_nsprefix_ = None
        self.xMsg = xMsg
        self.validate_TMotivo(self.xMsg)
        self.xMsg_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infFiscoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infFiscoType.subclass:
            return infFiscoType.subclass(*args_, **kwargs_)
        else:
            return infFiscoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cMsg(self):
        return self.cMsg
    def set_cMsg(self, cMsg):
        self.cMsg = cMsg
    def get_xMsg(self):
        return self.xMsg
    def set_xMsg(self, xMsg):
        self.xMsg = xMsg
    def validate_cMsgType(self, value):
        result = True
        # Validate type cMsgType, a restriction on TStat.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cMsgType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cMsgType_patterns_, ))
                result = False
        return result
    validate_cMsgType_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.cMsg is not None or
            self.xMsg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infFiscoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infFiscoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infFiscoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infFiscoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infFiscoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infFiscoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infFiscoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMsg is not None:
            namespaceprefix_ = self.cMsg_nsprefix_ + ':' if (UseCapturedNS_ and self.cMsg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMsg>%s</%scMsg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMsg), input_name='cMsg')), namespaceprefix_ , eol_))
        if self.xMsg is not None:
            namespaceprefix_ = self.xMsg_nsprefix_ + ':' if (UseCapturedNS_ and self.xMsg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMsg>%s</%sxMsg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMsg), input_name='xMsg')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cMsg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMsg')
            value_ = self.gds_validate_string(value_, node, 'cMsg')
            self.cMsg = value_
            self.cMsg_nsprefix_ = child_.prefix
            # validate type cMsgType
            self.validate_cMsgType(self.cMsg)
        elif nodeName_ == 'xMsg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMsg')
            value_ = self.gds_validate_string(value_, node, 'xMsg')
            self.xMsg = value_
            self.xMsg_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMsg)
# end class infFiscoType


class infProtType15(GeneratedsSuper):
    """infProtType15 -- Dados do protocolo de status
    tpAmb -- Identifica
    ç
    ã
    o do Ambiente:
    1 - Produ
    ç
    ã
    o
    2 - Homologa
    ç
    ã
    o
    verAplic -- Vers
    ã
    o do Aplicativo que processou o CT-e
    chCTe -- Chaves de acesso da CT-e
    dhRecbto -- Data e hora de processamento, no formato AAAA-MM-DDTHH:MM:SS TZD.
    nProt -- N
    ú
    mero do Protocolo de Status do CT-e.
    digVal -- Digest Value da CT-e processado. Utilizado para conferir a integridade do CT-e original.
    cStat -- C
    ó
    digo do status do CT-e.
    xMotivo -- Descri
    ç
    ã
    o literal do status do CT-e.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, tpAmb=None, verAplic=None, chCTe=None, dhRecbto=None, nProt=None, digVal=None, cStat=None, xMotivo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.verAplic_nsprefix_ = None
        self.chCTe = chCTe
        self.validate_TChNFe(self.chCTe)
        self.chCTe_nsprefix_ = None
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.dhRecbto_nsprefix_ = None
        self.nProt = nProt
        self.validate_TProt(self.nProt)
        self.nProt_nsprefix_ = None
        self.digVal = digVal
        self.validate_DigestValueType(self.digVal)
        self.digVal_nsprefix_ = None
        self.cStat = cStat
        self.validate_cStatType16(self.cStat)
        self.cStat_nsprefix_ = None
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.xMotivo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infProtType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infProtType15.subclass:
            return infProtType15.subclass(*args_, **kwargs_)
        else:
            return infProtType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_chCTe(self):
        return self.chCTe
    def set_chCTe(self, chCTe):
        self.chCTe = chCTe
    def get_dhRecbto(self):
        return self.dhRecbto
    def set_dhRecbto(self, dhRecbto):
        self.dhRecbto = dhRecbto
    def get_nProt(self):
        return self.nProt
    def set_nProt(self, nProt):
        self.nProt = nProt
    def get_digVal(self):
        return self.digVal
    def set_digVal(self, digVal):
        self.digVal = digVal
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TVerAplic(self, value):
        result = True
        # Validate type TVerAplic, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TVerAplic' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TVerAplic' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerAplic_patterns_, ))
                result = False
        return result
    validate_TVerAplic_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def validate_TDateTimeUTC(self, value):
        result = True
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDateTimeUTC_patterns_, ))
                result = False
        return result
    validate_TDateTimeUTC_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_TProt(self, value):
        result = True
        # Validate type TProt, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TProt_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TProt_patterns_, ))
                result = False
        return result
    validate_TProt_patterns_ = [['^([0-9]{15})$']]
    def validate_DigestValueType(self, value):
        result = True
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def validate_cStatType16(self, value):
        result = True
        # Validate type cStatType16, a restriction on TStat.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cStatType16_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cStatType16_patterns_, ))
                result = False
        return result
    validate_cStatType16_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.chCTe is not None or
            self.dhRecbto is not None or
            self.nProt is not None or
            self.digVal is not None or
            self.cStat is not None or
            self.xMotivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='infProtType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infProtType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infProtType15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infProtType15')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infProtType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infProtType15'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='infProtType15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            namespaceprefix_ = self.verAplic_nsprefix_ + ':' if (UseCapturedNS_ and self.verAplic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.chCTe is not None:
            namespaceprefix_ = self.chCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.chCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespaceprefix_ , eol_))
        if self.dhRecbto is not None:
            namespaceprefix_ = self.dhRecbto_nsprefix_ + ':' if (UseCapturedNS_ and self.dhRecbto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespaceprefix_ , eol_))
        if self.nProt is not None:
            namespaceprefix_ = self.nProt_nsprefix_ + ':' if (UseCapturedNS_ and self.nProt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snProt>%s</%snProt>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nProt), input_name='nProt')), namespaceprefix_ , eol_))
        if self.digVal is not None:
            namespaceprefix_ = self.digVal_nsprefix_ + ':' if (UseCapturedNS_ and self.digVal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigVal>%s</%sdigVal>%s' % (namespaceprefix_ , self.gds_format_base64(self.digVal, input_name='digVal'), namespaceprefix_ , eol_))
        if self.cStat is not None:
            namespaceprefix_ = self.cStat_nsprefix_ + ':' if (UseCapturedNS_ and self.cStat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            namespaceprefix_ = self.xMotivo_nsprefix_ + ':' if (UseCapturedNS_ and self.xMotivo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verAplic')
            value_ = self.gds_validate_string(value_, node, 'verAplic')
            self.verAplic = value_
            self.verAplic_nsprefix_ = child_.prefix
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'chCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCTe')
            value_ = self.gds_validate_string(value_, node, 'chCTe')
            self.chCTe = value_
            self.chCTe_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.chCTe)
        elif nodeName_ == 'dhRecbto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhRecbto')
            value_ = self.gds_validate_string(value_, node, 'dhRecbto')
            self.dhRecbto = value_
            self.dhRecbto_nsprefix_ = child_.prefix
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'nProt':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nProt')
            value_ = self.gds_validate_string(value_, node, 'nProt')
            self.nProt = value_
            self.nProt_nsprefix_ = child_.prefix
            # validate type TProt
            self.validate_TProt(self.nProt)
        elif nodeName_ == 'digVal':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'digVal')
            else:
                bval_ = None
            self.digVal = bval_
            self.digVal_nsprefix_ = child_.prefix
            # validate type DigestValueType
            self.validate_DigestValueType(self.digVal)
        elif nodeName_ == 'cStat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cStat')
            value_ = self.gds_validate_string(value_, node, 'cStat')
            self.cStat = value_
            self.cStat_nsprefix_ = child_.prefix
            # validate type cStatType16
            self.validate_cStatType16(self.cStat)
        elif nodeName_ == 'xMotivo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMotivo')
            value_ = self.gds_validate_string(value_, node, 'xMotivo')
            self.xMotivo = value_
            self.xMotivo_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
# end class infProtType15


class infFiscoType17(GeneratedsSuper):
    """infFiscoType17 -- Mensagem do Fisco
    cMsg -- C
    ó
    digo do status da mensagem do fisco
    xMsg -- Mensagem do Fisco
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cMsg=None, xMsg=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cMsg = cMsg
        self.validate_cMsgType18(self.cMsg)
        self.cMsg_nsprefix_ = None
        self.xMsg = xMsg
        self.validate_TMotivo(self.xMsg)
        self.xMsg_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infFiscoType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infFiscoType17.subclass:
            return infFiscoType17.subclass(*args_, **kwargs_)
        else:
            return infFiscoType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cMsg(self):
        return self.cMsg
    def set_cMsg(self, cMsg):
        self.cMsg = cMsg
    def get_xMsg(self):
        return self.xMsg
    def set_xMsg(self, xMsg):
        self.xMsg = xMsg
    def validate_cMsgType18(self, value):
        result = True
        # Validate type cMsgType18, a restriction on TStat.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cMsgType18_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cMsgType18_patterns_, ))
                result = False
        return result
    validate_cMsgType18_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.cMsg is not None or
            self.xMsg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infFiscoType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infFiscoType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infFiscoType17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infFiscoType17')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infFiscoType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infFiscoType17'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infFiscoType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMsg is not None:
            namespaceprefix_ = self.cMsg_nsprefix_ + ':' if (UseCapturedNS_ and self.cMsg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMsg>%s</%scMsg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMsg), input_name='cMsg')), namespaceprefix_ , eol_))
        if self.xMsg is not None:
            namespaceprefix_ = self.xMsg_nsprefix_ + ':' if (UseCapturedNS_ and self.xMsg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMsg>%s</%sxMsg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMsg), input_name='xMsg')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cMsg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMsg')
            value_ = self.gds_validate_string(value_, node, 'cMsg')
            self.cMsg = value_
            self.cMsg_nsprefix_ = child_.prefix
            # validate type cMsgType18
            self.validate_cMsgType18(self.cMsg)
        elif nodeName_ == 'xMsg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMsg')
            value_ = self.gds_validate_string(value_, node, 'xMsg')
            self.xMsg = value_
            self.xMsg_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMsg)
# end class infFiscoType17


class infProtType20(GeneratedsSuper):
    """infProtType20 -- Dados do protocolo de status
    tpAmb -- Identifica
    ç
    ã
    o do Ambiente:
    1 - Produ
    ç
    ã
    o
    2 - Homologa
    ç
    ã
    o
    verAplic -- Vers
    ã
    o do Aplicativo que processou a GTV-e
    chCTe -- Chaves de acesso da CT-e
    dhRecbto -- Data e hora de processamento, no formato AAAA-MM-DDTHH:MM:SS TZD.
    nProt -- N
    ú
    mero do Protocolo de Status da GTV-e
    digVal -- Digest Value da GTV-e processado. Utilizado para conferir a integridade da GTV-e original.
    cStat -- C
    ó
    digo do status da GTV-e.
    xMotivo -- Descri
    ç
    ã
    o literal do status da GTV-e.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Id=None, tpAmb=None, verAplic=None, chCTe=None, dhRecbto=None, nProt=None, digVal=None, cStat=None, xMotivo=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.verAplic_nsprefix_ = None
        self.chCTe = chCTe
        self.validate_TChNFe(self.chCTe)
        self.chCTe_nsprefix_ = None
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.dhRecbto_nsprefix_ = None
        self.nProt = nProt
        self.validate_TProt(self.nProt)
        self.nProt_nsprefix_ = None
        self.digVal = digVal
        self.validate_DigestValueType(self.digVal)
        self.digVal_nsprefix_ = None
        self.cStat = cStat
        self.validate_cStatType21(self.cStat)
        self.cStat_nsprefix_ = None
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.xMotivo_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infProtType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infProtType20.subclass:
            return infProtType20.subclass(*args_, **kwargs_)
        else:
            return infProtType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_chCTe(self):
        return self.chCTe
    def set_chCTe(self, chCTe):
        self.chCTe = chCTe
    def get_dhRecbto(self):
        return self.dhRecbto
    def set_dhRecbto(self, dhRecbto):
        self.dhRecbto = dhRecbto
    def get_nProt(self):
        return self.nProt
    def set_nProt(self, nProt):
        self.nProt = nProt
    def get_digVal(self):
        return self.digVal
    def set_digVal(self, digVal):
        self.digVal = digVal
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TVerAplic(self, value):
        result = True
        # Validate type TVerAplic, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TVerAplic' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TVerAplic' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TVerAplic_patterns_, ))
                result = False
        return result
    validate_TVerAplic_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def validate_TDateTimeUTC(self, value):
        result = True
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDateTimeUTC_patterns_, ))
                result = False
        return result
    validate_TDateTimeUTC_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_TProt(self, value):
        result = True
        # Validate type TProt, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TProt_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TProt_patterns_, ))
                result = False
        return result
    validate_TProt_patterns_ = [['^([0-9]{15})$']]
    def validate_DigestValueType(self, value):
        result = True
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            pass
        return result
    def validate_cStatType21(self, value):
        result = True
        # Validate type cStatType21, a restriction on TStat.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cStatType21_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cStatType21_patterns_, ))
                result = False
        return result
    validate_cStatType21_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.chCTe is not None or
            self.dhRecbto is not None or
            self.nProt is not None or
            self.digVal is not None or
            self.cStat is not None or
            self.xMotivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='infProtType20', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infProtType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infProtType20':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infProtType20')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infProtType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infProtType20'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema"  xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='infProtType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            namespaceprefix_ = self.verAplic_nsprefix_ + ':' if (UseCapturedNS_ and self.verAplic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.chCTe is not None:
            namespaceprefix_ = self.chCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.chCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespaceprefix_ , eol_))
        if self.dhRecbto is not None:
            namespaceprefix_ = self.dhRecbto_nsprefix_ + ':' if (UseCapturedNS_ and self.dhRecbto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespaceprefix_ , eol_))
        if self.nProt is not None:
            namespaceprefix_ = self.nProt_nsprefix_ + ':' if (UseCapturedNS_ and self.nProt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snProt>%s</%snProt>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nProt), input_name='nProt')), namespaceprefix_ , eol_))
        if self.digVal is not None:
            namespaceprefix_ = self.digVal_nsprefix_ + ':' if (UseCapturedNS_ and self.digVal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigVal>%s</%sdigVal>%s' % (namespaceprefix_ , self.gds_format_base64(self.digVal, input_name='digVal'), namespaceprefix_ , eol_))
        if self.cStat is not None:
            namespaceprefix_ = self.cStat_nsprefix_ + ':' if (UseCapturedNS_ and self.cStat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            namespaceprefix_ = self.xMotivo_nsprefix_ + ':' if (UseCapturedNS_ and self.xMotivo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verAplic')
            value_ = self.gds_validate_string(value_, node, 'verAplic')
            self.verAplic = value_
            self.verAplic_nsprefix_ = child_.prefix
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'chCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCTe')
            value_ = self.gds_validate_string(value_, node, 'chCTe')
            self.chCTe = value_
            self.chCTe_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.chCTe)
        elif nodeName_ == 'dhRecbto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhRecbto')
            value_ = self.gds_validate_string(value_, node, 'dhRecbto')
            self.dhRecbto = value_
            self.dhRecbto_nsprefix_ = child_.prefix
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'nProt':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nProt')
            value_ = self.gds_validate_string(value_, node, 'nProt')
            self.nProt = value_
            self.nProt_nsprefix_ = child_.prefix
            # validate type TProt
            self.validate_TProt(self.nProt)
        elif nodeName_ == 'digVal':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'digVal')
            else:
                bval_ = None
            self.digVal = bval_
            self.digVal_nsprefix_ = child_.prefix
            # validate type DigestValueType
            self.validate_DigestValueType(self.digVal)
        elif nodeName_ == 'cStat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cStat')
            value_ = self.gds_validate_string(value_, node, 'cStat')
            self.cStat = value_
            self.cStat_nsprefix_ = child_.prefix
            # validate type cStatType21
            self.validate_cStatType21(self.cStat)
        elif nodeName_ == 'xMotivo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMotivo')
            value_ = self.gds_validate_string(value_, node, 'xMotivo')
            self.xMotivo = value_
            self.xMotivo_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
# end class infProtType20


class infFiscoType22(GeneratedsSuper):
    """infFiscoType22 -- Mensagem do Fisco
    cMsg -- C
    ó
    digo do status da mensagem do fisco
    xMsg -- Mensagem do Fisco
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cMsg=None, xMsg=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cMsg = cMsg
        self.validate_cMsgType23(self.cMsg)
        self.cMsg_nsprefix_ = None
        self.xMsg = xMsg
        self.validate_TMotivo(self.xMsg)
        self.xMsg_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infFiscoType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infFiscoType22.subclass:
            return infFiscoType22.subclass(*args_, **kwargs_)
        else:
            return infFiscoType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cMsg(self):
        return self.cMsg
    def set_cMsg(self, cMsg):
        self.cMsg = cMsg
    def get_xMsg(self):
        return self.xMsg
    def set_xMsg(self, xMsg):
        self.xMsg = xMsg
    def validate_cMsgType23(self, value):
        result = True
        # Validate type cMsgType23, a restriction on TStat.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cMsgType23_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cMsgType23_patterns_, ))
                result = False
        return result
    validate_cMsgType23_patterns_ = [['^([0-9]{3})$']]
    def validate_TMotivo(self, value):
        result = True
        # Validate type TMotivo, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 255:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TMotivo' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TMotivo' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TMotivo_patterns_, ))
                result = False
        return result
    validate_TMotivo_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.cMsg is not None or
            self.xMsg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infFiscoType22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infFiscoType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infFiscoType22':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infFiscoType22')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infFiscoType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infFiscoType22'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infFiscoType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cMsg is not None:
            namespaceprefix_ = self.cMsg_nsprefix_ + ':' if (UseCapturedNS_ and self.cMsg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMsg>%s</%scMsg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMsg), input_name='cMsg')), namespaceprefix_ , eol_))
        if self.xMsg is not None:
            namespaceprefix_ = self.xMsg_nsprefix_ + ':' if (UseCapturedNS_ and self.xMsg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMsg>%s</%sxMsg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMsg), input_name='xMsg')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cMsg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMsg')
            value_ = self.gds_validate_string(value_, node, 'cMsg')
            self.cMsg = value_
            self.cMsg_nsprefix_ = child_.prefix
            # validate type cMsgType23
            self.validate_cMsgType23(self.cMsg)
        elif nodeName_ == 'xMsg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMsg')
            value_ = self.gds_validate_string(value_, node, 'xMsg')
            self.xMsg = value_
            self.xMsg_nsprefix_ = child_.prefix
            # validate type TMotivo
            self.validate_TMotivo(self.xMsg)
# end class infFiscoType22


class infCteType25(GeneratedsSuper):
    """infCteType25 -- Informa
    ç
    õ
    es do CT-e
    versao -- Vers
    ã
    o do leiaute
    Ex: "3.00"
    Id -- Identificador da tag a ser assinada
    Informar a chave de acesso do CT-e e precedida do literal "CTe"
    ide -- Identifica
    ç
    ã
    o do CT-e
    compl -- Dados complementares do CT-e para fins operacionais ou comerciais
    emit -- Identifica
    ç
    ã
    o do Emitente do CT-e
    rem -- Informa
    ç
    õ
    es do Remetente das mercadorias transportadas pelo CT-e
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    exped -- Informa
    ç
    õ
    es do Expedidor da Carga
    receb -- Informa
    ç
    õ
    es do Recebedor da Carga
    dest -- Informa
    ç
    õ
    es do Destinat
    á
    rio do CT-e
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    vPrest -- Valores da Presta
    ç
    ã
    o de Servi
    ç
    o
    imp -- Informa
    ç
    õ
    es relativas aos Impostos
    infCTeNorm -- Grupo de informa
    ç
    õ
    es do CT-e Normal e Substituto
    infCteComp -- Detalhamento do CT-e complementado
    infCteAnu -- Detalhamento do CT-e do tipo Anula
    ç
    ã
    o
    autXML -- Autorizados para download do XML do DF-e
    Informar CNPJ ou CPF. Preencher os zeros n
    ã
    o significativos.
    infRespTec -- Informa
    ç
    õ
    es do Respons
    á
    vel T
    é
    cnico pela emiss
    ã
    o do DF-e
    infSolicNFF -- Grupo de informa
    ç
    õ
    es do pedido de emiss
    ã
    o da Nota Fiscal F
    á
    cil
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, Id=None, ide=None, compl=None, emit=None, rem=None, exped=None, receb=None, dest=None, vPrest=None, imp=None, infCTeNorm=None, infCteComp=None, infCteAnu=None, autXML=None, infRespTec=None, infSolicNFF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.ide = ide
        self.ide_nsprefix_ = None
        self.compl = compl
        self.compl_nsprefix_ = None
        self.emit = emit
        self.emit_nsprefix_ = None
        self.rem = rem
        self.rem_nsprefix_ = None
        self.exped = exped
        self.exped_nsprefix_ = None
        self.receb = receb
        self.receb_nsprefix_ = None
        self.dest = dest
        self.dest_nsprefix_ = None
        self.vPrest = vPrest
        self.vPrest_nsprefix_ = None
        self.imp = imp
        self.imp_nsprefix_ = None
        self.infCTeNorm = infCTeNorm
        self.infCTeNorm_nsprefix_ = None
        self.infCteComp = infCteComp
        self.infCteComp_nsprefix_ = None
        self.infCteAnu = infCteAnu
        self.infCteAnu_nsprefix_ = None
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
        self.autXML_nsprefix_ = None
        self.infRespTec = infRespTec
        self.infRespTec_nsprefix_ = None
        self.infSolicNFF = infSolicNFF
        self.infSolicNFF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteType25.subclass:
            return infCteType25.subclass(*args_, **kwargs_)
        else:
            return infCteType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ide(self):
        return self.ide
    def set_ide(self, ide):
        self.ide = ide
    def get_compl(self):
        return self.compl
    def set_compl(self, compl):
        self.compl = compl
    def get_emit(self):
        return self.emit
    def set_emit(self, emit):
        self.emit = emit
    def get_rem(self):
        return self.rem
    def set_rem(self, rem):
        self.rem = rem
    def get_exped(self):
        return self.exped
    def set_exped(self, exped):
        self.exped = exped
    def get_receb(self):
        return self.receb
    def set_receb(self, receb):
        self.receb = receb
    def get_dest(self):
        return self.dest
    def set_dest(self, dest):
        self.dest = dest
    def get_vPrest(self):
        return self.vPrest
    def set_vPrest(self, vPrest):
        self.vPrest = vPrest
    def get_imp(self):
        return self.imp
    def set_imp(self, imp):
        self.imp = imp
    def get_infCTeNorm(self):
        return self.infCTeNorm
    def set_infCTeNorm(self, infCTeNorm):
        self.infCTeNorm = infCTeNorm
    def get_infCteComp(self):
        return self.infCteComp
    def set_infCteComp(self, infCteComp):
        self.infCteComp = infCteComp
    def get_infCteAnu(self):
        return self.infCteAnu
    def set_infCteAnu(self, infCteAnu):
        self.infCteAnu = infCteAnu
    def get_autXML(self):
        return self.autXML
    def set_autXML(self, autXML):
        self.autXML = autXML
    def add_autXML(self, value):
        self.autXML.append(value)
    def insert_autXML_at(self, index, value):
        self.autXML.insert(index, value)
    def replace_autXML_at(self, index, value):
        self.autXML[index] = value
    def get_infRespTec(self):
        return self.infRespTec
    def set_infRespTec(self, infRespTec):
        self.infRespTec = infRespTec
    def get_infSolicNFF(self):
        return self.infSolicNFF
    def set_infSolicNFF(self, infSolicNFF):
        self.infSolicNFF = infSolicNFF
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_versaoType88(self, value):
        # Validate type versaoType88, a restriction on TVerCTe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoType88_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoType88_patterns_, ))
    validate_versaoType88_patterns_ = [['^(3\\.00)$']]
    def validate_IdType89(self, value):
        # Validate type IdType89, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType89_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IdType89_patterns_, ))
    validate_IdType89_patterns_ = [['^(CTe[0-9]{44})$']]
    def _hasContent(self):
        if (
            self.ide is not None or
            self.compl is not None or
            self.emit is not None or
            self.rem is not None or
            self.exped is not None or
            self.receb is not None or
            self.dest is not None or
            self.vPrest is not None or
            self.imp is not None or
            self.infCTeNorm is not None or
            self.infCteComp is not None or
            self.infCteAnu is not None or
            self.autXML or
            self.infRespTec is not None or
            self.infSolicNFF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteType25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteType25')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteType25'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteType25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            namespaceprefix_ = self.ide_nsprefix_ + ':' if (UseCapturedNS_ and self.ide_nsprefix_) else ''
            self.ide.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ide', pretty_print=pretty_print)
        if self.compl is not None:
            namespaceprefix_ = self.compl_nsprefix_ + ':' if (UseCapturedNS_ and self.compl_nsprefix_) else ''
            self.compl.export(outfile, level, namespaceprefix_, namespacedef_='', name_='compl', pretty_print=pretty_print)
        if self.emit is not None:
            namespaceprefix_ = self.emit_nsprefix_ + ':' if (UseCapturedNS_ and self.emit_nsprefix_) else ''
            self.emit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emit', pretty_print=pretty_print)
        if self.rem is not None:
            namespaceprefix_ = self.rem_nsprefix_ + ':' if (UseCapturedNS_ and self.rem_nsprefix_) else ''
            self.rem.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rem', pretty_print=pretty_print)
        if self.exped is not None:
            namespaceprefix_ = self.exped_nsprefix_ + ':' if (UseCapturedNS_ and self.exped_nsprefix_) else ''
            self.exped.export(outfile, level, namespaceprefix_, namespacedef_='', name_='exped', pretty_print=pretty_print)
        if self.receb is not None:
            namespaceprefix_ = self.receb_nsprefix_ + ':' if (UseCapturedNS_ and self.receb_nsprefix_) else ''
            self.receb.export(outfile, level, namespaceprefix_, namespacedef_='', name_='receb', pretty_print=pretty_print)
        if self.dest is not None:
            namespaceprefix_ = self.dest_nsprefix_ + ':' if (UseCapturedNS_ and self.dest_nsprefix_) else ''
            self.dest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dest', pretty_print=pretty_print)
        if self.vPrest is not None:
            namespaceprefix_ = self.vPrest_nsprefix_ + ':' if (UseCapturedNS_ and self.vPrest_nsprefix_) else ''
            self.vPrest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vPrest', pretty_print=pretty_print)
        if self.imp is not None:
            namespaceprefix_ = self.imp_nsprefix_ + ':' if (UseCapturedNS_ and self.imp_nsprefix_) else ''
            self.imp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='imp', pretty_print=pretty_print)
        if self.infCTeNorm is not None:
            namespaceprefix_ = self.infCTeNorm_nsprefix_ + ':' if (UseCapturedNS_ and self.infCTeNorm_nsprefix_) else ''
            self.infCTeNorm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCTeNorm', pretty_print=pretty_print)
        if self.infCteComp is not None:
            namespaceprefix_ = self.infCteComp_nsprefix_ + ':' if (UseCapturedNS_ and self.infCteComp_nsprefix_) else ''
            self.infCteComp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCteComp', pretty_print=pretty_print)
        if self.infCteAnu is not None:
            namespaceprefix_ = self.infCteAnu_nsprefix_ + ':' if (UseCapturedNS_ and self.infCteAnu_nsprefix_) else ''
            self.infCteAnu.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCteAnu', pretty_print=pretty_print)
        for autXML_ in self.autXML:
            namespaceprefix_ = self.autXML_nsprefix_ + ':' if (UseCapturedNS_ and self.autXML_nsprefix_) else ''
            autXML_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='autXML', pretty_print=pretty_print)
        if self.infRespTec is not None:
            namespaceprefix_ = self.infRespTec_nsprefix_ + ':' if (UseCapturedNS_ and self.infRespTec_nsprefix_) else ''
            self.infRespTec.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infRespTec', pretty_print=pretty_print)
        if self.infSolicNFF is not None:
            namespaceprefix_ = self.infSolicNFF_nsprefix_ + ':' if (UseCapturedNS_ and self.infSolicNFF_nsprefix_) else ''
            self.infSolicNFF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infSolicNFF', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_versaoType88(self.versao)    # validate type versaoType88
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
            self.validate_IdType89(self.Id)    # validate type IdType89
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ide':
            obj_ = ideType26.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'compl':
            obj_ = complType44.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.compl = obj_
            obj_.original_tagname_ = 'compl'
        elif nodeName_ == 'emit':
            obj_ = emitType59.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'rem':
            obj_ = remType64.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rem = obj_
            obj_.original_tagname_ = 'rem'
        elif nodeName_ == 'exped':
            obj_ = expedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exped = obj_
            obj_.original_tagname_ = 'exped'
        elif nodeName_ == 'receb':
            obj_ = recebType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.receb = obj_
            obj_.original_tagname_ = 'receb'
        elif nodeName_ == 'dest':
            obj_ = destType73.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dest = obj_
            obj_.original_tagname_ = 'dest'
        elif nodeName_ == 'vPrest':
            obj_ = vPrestType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vPrest = obj_
            obj_.original_tagname_ = 'vPrest'
        elif nodeName_ == 'imp':
            obj_ = impType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imp = obj_
            obj_.original_tagname_ = 'imp'
        elif nodeName_ == 'infCTeNorm':
            obj_ = infCTeNormType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCTeNorm = obj_
            obj_.original_tagname_ = 'infCTeNorm'
        elif nodeName_ == 'infCteComp':
            obj_ = infCteCompType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCteComp = obj_
            obj_.original_tagname_ = 'infCteComp'
        elif nodeName_ == 'infCteAnu':
            obj_ = infCteAnuType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCteAnu = obj_
            obj_.original_tagname_ = 'infCteAnu'
        elif nodeName_ == 'autXML':
            obj_ = autXMLType87.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
        elif nodeName_ == 'infRespTec':
            obj_ = TRespTec.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infRespTec = obj_
            obj_.original_tagname_ = 'infRespTec'
        elif nodeName_ == 'infSolicNFF':
            obj_ = infSolicNFFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infSolicNFF = obj_
            obj_.original_tagname_ = 'infSolicNFF'
# end class infCteType25


class ideType26(GeneratedsSuper):
    """ideType26 -- Identifica
    ç
    ã
    o do CT-e
    Informar apenas
    para tpEmis diferente de 1
    cUF -- C
    ó
    digo da UF do emitente do CT-e.
    Utilizar a Tabela do IBGE.
    cCT -- C
    ó
    digo num
    é
    rico que comp
    õ
    e a Chave de Acesso.
    N
    ú
    mero aleat
    ó
    rio gerado pelo emitente para cada CT-e, com o objetivo de evitar acessos indevidos ao documento.
    CFOP -- C
    ó
    digo Fiscal de Opera
    ç
    õ
    es e Presta
    ç
    õ
    es
    natOp -- Natureza da Opera
    ç
    ã
    o
    mod -- Modelo do documento fiscal
    Utilizar o c
    ó
    digo 57 para identifica
    ç
    ã
    o do CT-e, emitido em substitui
    ç
    ã
    o aos modelos de conhecimentos em papel.
    serie -- S
    é
    rie do CT-e
    Preencher com "0" no caso de s
    é
    rie
    ú
    nica
    nCT -- N
    ú
    mero do CT-e
    dhEmi -- Data e hora de emiss
    ã
    o do CT-e
    Formato AAAA-MM-DDTHH:MM:DD TZD
    tpImp -- Formato de impress
    ã
    o do DACTE
    Preencher com: 1 - Retrato; 2 - Paisagem.
    tpEmis -- Forma de emiss
    ã
    o do CT-e
    Preencher com:
    1 - Normal;
    3-Regime Especial NFF;  4-EPEC pela SVC; 5 - Conting
    ê
    ncia FSDA;
    7 - Autoriza
    ç
    ã
    o pela SVC-RS;
    8 - Autoriza
    ç
    ã
    o pela SVC-SP
    cDV -- Digito Verificador da chave de acesso do CT-e
    Informar o d
    í
    gito  de controle da chave de acesso do CT-e, que deve ser calculado com a aplica
    ç
    ã
    o do algoritmo m
    ó
    dulo 11 (base 2,9) da chave de acesso.
    tpAmb -- Tipo do Ambiente
    Preencher com:1 - Produ
    ç
    ã
    o; 2 - Homologa
    ç
    ã
    o.
    tpCTe -- Tipo do CT-e
    Preencher com:
    0 - CT-e Normal;
    1 - CT-e de Complemento de Valores;	2 - CT-e de Anula
    ç
    ã
    o;
    3 - CT-e de Substitui
    ç
    ã
    o
    procEmi -- Identificador do processo de emiss
    ã
    o do CT-e
    Preencher com:
    0 - emiss
    ã
    o de CT-e com aplicativo do contribuinte;
    3- emiss
    ã
    o CT-e pelo contribuinte com aplicativo fornecido pelo SEBRAE.
    verProc -- Vers
    ã
    o do processo de emiss
    ã
    o
    Iinformar a vers
    ã
    o do aplicativo emissor de CT-e.
    indGlobalizado -- Indicador de CT-e Globalizado
    Informar valor 1 quando for Globalizado e n
    ã
    o informar a tag quando n
    ã
    o tratar de CT-e Globalizado
    cMunEnv -- C
    ó
    digo do Munic
    í
    pio de envio do CT-e (de onde o documento foi transmitido)
    Utilizar a tabela do IBGE. Informar 9999999 para as opera
    ç
    õ
    es com o exterior.
    xMunEnv -- Nome do Munic
    í
    pio de envio do CT-e (de onde o documento foi transmitido)
    Informar PAIS/Municipio para as opera
    ç
    õ
    es com o exterior.
    UFEnv -- Sigla da UF de envio do CT-e (de onde o documento foi transmitido)
    Informar 'EX' para opera
    ç
    õ
    es com o exterior.
    modal -- Modal
    Preencher com:01-Rodovi
    á
    rio;
    02-A
    é
    reo;03-Aquavi
    á
    rio;04-Ferrovi
    á
    rio;05-Dutovi
    á
    rio;06-Multimodal;
    tpServ -- Tipo do Servi
    ç
    o
    Preencher com:
    0 - Normal;1 - Subcontrata
    ç
    ã
    o;
    2 - Redespacho;3 - Redespacho Intermedi
    á
    rio; 4 - Servi
    ç
    o Vinculado a Multimodal
    cMunIni -- C
    ó
    digo do Munic
    í
    pio de in
    í
    cio da presta
    ç
    ã
    o
    Utilizar a tabela do IBGE. Informar 9999999 para opera
    ç
    õ
    es com o exterior.
    xMunIni -- Nome do Munic
    í
    pio do in
    í
    cio da presta
    ç
    ã
    o
    Informar 'EXTERIOR' para opera
    ç
    õ
    es com o exterior.
    UFIni -- UF do in
    í
    cio da presta
    ç
    ã
    o
    Informar 'EX' para opera
    ç
    õ
    es com o exterior.
    cMunFim -- C
    ó
    digo do Munic
    í
    pio de t
    é
    rmino da presta
    ç
    ã
    o
    Utilizar a tabela do IBGE. Informar 9999999 para opera
    ç
    õ
    es com o exterior.
    xMunFim -- Nome do Munic
    í
    pio do t
    é
    rmino da presta
    ç
    ã
    o
    Informar 'EXTERIOR' para opera
    ç
    õ
    es com o exterior.
    UFFim -- UF do t
    é
    rmino da presta
    ç
    ã
    o
    Informar 'EX' para opera
    ç
    õ
    es com o exterior.
    retira -- Indicador se o Recebedor retira no Aeroporto, Filial, Porto ou Esta
    ç
    ã
    o de Destino?
    Preencher com: 0 - sim; 1 - n
    ã
    o
    xDetRetira -- Detalhes do retira
    indIEToma -- Indicador do papel do tomador na presta
    ç
    ã
    o do servi
    ç
    o:
    1
    –
    Contribuinte ICMS;
    2
    –
    Contribuinte isento de inscri
    ç
    ã
    o;
    9
    –
    N
    ã
    o Contribuinte
    Aplica-se ao tomador que for indicado no toma3 ou toma4
    toma3 -- Indicador do "papel" do tomador do servi
    ç
    o no CT-e
    toma4 -- Indicador do "papel" do tomador do servi
    ç
    o no CT-e
    dhCont -- Data e Hora da entrada em conting
    ê
    ncia
    Informar a data e hora no formato AAAA-MM-DDTHH:MM:SS
    xJust -- Justificativa da entrada em conting
    ê
    ncia
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cUF=None, cCT=None, CFOP=None, natOp=None, mod=None, serie=None, nCT=None, dhEmi=None, tpImp=None, tpEmis=None, cDV=None, tpAmb=None, tpCTe=None, procEmi=None, verProc=None, indGlobalizado=None, cMunEnv=None, xMunEnv=None, UFEnv=None, modal=None, tpServ=None, cMunIni=None, xMunIni=None, UFIni=None, cMunFim=None, xMunFim=None, UFFim=None, retira=None, xDetRetira=None, indIEToma=None, toma3=None, toma4=None, dhCont=None, xJust=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cUF_nsprefix_ = None
        self.cCT = cCT
        self.validate_cCTType27(self.cCT)
        self.cCT_nsprefix_ = None
        self.CFOP = CFOP
        self.validate_TCfop(self.CFOP)
        self.CFOP_nsprefix_ = None
        self.natOp = natOp
        self.validate_natOpType28(self.natOp)
        self.natOp_nsprefix_ = None
        self.mod = mod
        self.validate_TModCT(self.mod)
        self.mod_nsprefix_ = None
        self.serie = serie
        self.validate_serieType29(self.serie)
        self.serie_nsprefix_ = None
        self.nCT = nCT
        self.validate_TNF(self.nCT)
        self.nCT_nsprefix_ = None
        self.dhEmi = dhEmi
        self.validate_dhEmiType30(self.dhEmi)
        self.dhEmi_nsprefix_ = None
        self.tpImp = tpImp
        self.validate_tpImpType31(self.tpImp)
        self.tpImp_nsprefix_ = None
        self.tpEmis = tpEmis
        self.validate_tpEmisType32(self.tpEmis)
        self.tpEmis_nsprefix_ = None
        self.cDV = cDV
        self.validate_cDVType33(self.cDV)
        self.cDV_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.tpCTe = tpCTe
        self.validate_TFinCTe(self.tpCTe)
        self.tpCTe_nsprefix_ = None
        self.procEmi = procEmi
        self.validate_TProcEmi(self.procEmi)
        self.procEmi_nsprefix_ = None
        self.verProc = verProc
        self.validate_verProcType34(self.verProc)
        self.verProc_nsprefix_ = None
        self.indGlobalizado = indGlobalizado
        self.validate_indGlobalizadoType(self.indGlobalizado)
        self.indGlobalizado_nsprefix_ = None
        self.cMunEnv = cMunEnv
        self.validate_TCodMunIBGE(self.cMunEnv)
        self.cMunEnv_nsprefix_ = None
        self.xMunEnv = xMunEnv
        self.validate_xMunEnvType35(self.xMunEnv)
        self.xMunEnv_nsprefix_ = None
        self.UFEnv = UFEnv
        self.validate_TUf(self.UFEnv)
        self.UFEnv_nsprefix_ = None
        self.modal = modal
        self.validate_TModTransp(self.modal)
        self.modal_nsprefix_ = None
        self.tpServ = tpServ
        self.validate_tpServType36(self.tpServ)
        self.tpServ_nsprefix_ = None
        self.cMunIni = cMunIni
        self.validate_TCodMunIBGE(self.cMunIni)
        self.cMunIni_nsprefix_ = None
        self.xMunIni = xMunIni
        self.validate_xMunIniType(self.xMunIni)
        self.xMunIni_nsprefix_ = None
        self.UFIni = UFIni
        self.validate_TUf(self.UFIni)
        self.UFIni_nsprefix_ = None
        self.cMunFim = cMunFim
        self.validate_TCodMunIBGE(self.cMunFim)
        self.cMunFim_nsprefix_ = None
        self.xMunFim = xMunFim
        self.validate_xMunFimType(self.xMunFim)
        self.xMunFim_nsprefix_ = None
        self.UFFim = UFFim
        self.validate_TUf(self.UFFim)
        self.UFFim_nsprefix_ = None
        self.retira = retira
        self.validate_retiraType(self.retira)
        self.retira_nsprefix_ = None
        self.xDetRetira = xDetRetira
        self.validate_xDetRetiraType(self.xDetRetira)
        self.xDetRetira_nsprefix_ = None
        self.indIEToma = indIEToma
        self.validate_indIETomaType37(self.indIEToma)
        self.indIEToma_nsprefix_ = None
        self.toma3 = toma3
        self.toma3_nsprefix_ = None
        self.toma4 = toma4
        self.toma4_nsprefix_ = None
        self.dhCont = dhCont
        self.validate_TDateTimeUTC(self.dhCont)
        self.dhCont_nsprefix_ = None
        self.xJust = xJust
        self.validate_xJustType43(self.xJust)
        self.xJust_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideType26.subclass:
            return ideType26.subclass(*args_, **kwargs_)
        else:
            return ideType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_cCT(self):
        return self.cCT
    def set_cCT(self, cCT):
        self.cCT = cCT
    def get_CFOP(self):
        return self.CFOP
    def set_CFOP(self, CFOP):
        self.CFOP = CFOP
    def get_natOp(self):
        return self.natOp
    def set_natOp(self, natOp):
        self.natOp = natOp
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_nCT(self):
        return self.nCT
    def set_nCT(self, nCT):
        self.nCT = nCT
    def get_dhEmi(self):
        return self.dhEmi
    def set_dhEmi(self, dhEmi):
        self.dhEmi = dhEmi
    def get_tpImp(self):
        return self.tpImp
    def set_tpImp(self, tpImp):
        self.tpImp = tpImp
    def get_tpEmis(self):
        return self.tpEmis
    def set_tpEmis(self, tpEmis):
        self.tpEmis = tpEmis
    def get_cDV(self):
        return self.cDV
    def set_cDV(self, cDV):
        self.cDV = cDV
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_tpCTe(self):
        return self.tpCTe
    def set_tpCTe(self, tpCTe):
        self.tpCTe = tpCTe
    def get_procEmi(self):
        return self.procEmi
    def set_procEmi(self, procEmi):
        self.procEmi = procEmi
    def get_verProc(self):
        return self.verProc
    def set_verProc(self, verProc):
        self.verProc = verProc
    def get_indGlobalizado(self):
        return self.indGlobalizado
    def set_indGlobalizado(self, indGlobalizado):
        self.indGlobalizado = indGlobalizado
    def get_cMunEnv(self):
        return self.cMunEnv
    def set_cMunEnv(self, cMunEnv):
        self.cMunEnv = cMunEnv
    def get_xMunEnv(self):
        return self.xMunEnv
    def set_xMunEnv(self, xMunEnv):
        self.xMunEnv = xMunEnv
    def get_UFEnv(self):
        return self.UFEnv
    def set_UFEnv(self, UFEnv):
        self.UFEnv = UFEnv
    def get_modal(self):
        return self.modal
    def set_modal(self, modal):
        self.modal = modal
    def get_tpServ(self):
        return self.tpServ
    def set_tpServ(self, tpServ):
        self.tpServ = tpServ
    def get_cMunIni(self):
        return self.cMunIni
    def set_cMunIni(self, cMunIni):
        self.cMunIni = cMunIni
    def get_xMunIni(self):
        return self.xMunIni
    def set_xMunIni(self, xMunIni):
        self.xMunIni = xMunIni
    def get_UFIni(self):
        return self.UFIni
    def set_UFIni(self, UFIni):
        self.UFIni = UFIni
    def get_cMunFim(self):
        return self.cMunFim
    def set_cMunFim(self, cMunFim):
        self.cMunFim = cMunFim
    def get_xMunFim(self):
        return self.xMunFim
    def set_xMunFim(self, xMunFim):
        self.xMunFim = xMunFim
    def get_UFFim(self):
        return self.UFFim
    def set_UFFim(self, UFFim):
        self.UFFim = UFFim
    def get_retira(self):
        return self.retira
    def set_retira(self, retira):
        self.retira = retira
    def get_xDetRetira(self):
        return self.xDetRetira
    def set_xDetRetira(self, xDetRetira):
        self.xDetRetira = xDetRetira
    def get_indIEToma(self):
        return self.indIEToma
    def set_indIEToma(self, indIEToma):
        self.indIEToma = indIEToma
    def get_toma3(self):
        return self.toma3
    def set_toma3(self, toma3):
        self.toma3 = toma3
    def get_toma4(self):
        return self.toma4
    def set_toma4(self, toma4):
        self.toma4 = toma4
    def get_dhCont(self):
        return self.dhCont
    def set_dhCont(self, dhCont):
        self.dhCont = dhCont
    def get_xJust(self):
        return self.xJust
    def set_xJust(self, xJust):
        self.xJust = xJust
    def validate_TCodUfIBGE(self, value):
        result = True
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cCTType27(self, value):
        result = True
        # Validate type cCTType27, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cCTType27_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cCTType27_patterns_, ))
                result = False
        return result
    validate_cCTType27_patterns_ = [['^([0-9]{8})$']]
    def validate_TCfop(self, value):
        result = True
        # Validate type TCfop, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCfop_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCfop_patterns_, ))
                result = False
        return result
    validate_TCfop_patterns_ = [['^([123567][0-9]([0-9][1-9]|[1-9][0-9]))$']]
    def validate_natOpType28(self, value):
        result = True
        # Validate type natOpType28, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on natOpType28' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on natOpType28' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_natOpType28_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_natOpType28_patterns_, ))
                result = False
        return result
    validate_natOpType28_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TModCT(self, value):
        result = True
        # Validate type TModCT, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['57']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TModCT' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_serieType29(self, value):
        result = True
        # Validate type serieType29, a restriction on TSerie.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_serieType29_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_serieType29_patterns_, ))
                result = False
        return result
    validate_serieType29_patterns_ = [['^(0|[1-9]{1}[0-9]{0,2})$']]
    def validate_TNF(self, value):
        result = True
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TNF_patterns_, ))
                result = False
        return result
    validate_TNF_patterns_ = [['^([1-9]{1}[0-9]{0,8})$']]
    def validate_dhEmiType30(self, value):
        result = True
        # Validate type dhEmiType30, a restriction on TDateTimeUTC.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_dhEmiType30_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_dhEmiType30_patterns_, ))
                result = False
        return result
    validate_dhEmiType30_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_tpImpType31(self, value):
        result = True
        # Validate type tpImpType31, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpImpType31' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tpEmisType32(self, value):
        result = True
        # Validate type tpEmisType32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '3', '4', '5', '7', '8']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpEmisType32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cDVType33(self, value):
        result = True
        # Validate type cDVType33, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cDVType33_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cDVType33_patterns_, ))
                result = False
        return result
    validate_cDVType33_patterns_ = [['^([0-9]{1})$']]
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TFinCTe(self, value):
        result = True
        # Validate type TFinCTe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1', '2', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TFinCTe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TProcEmi(self, value):
        result = True
        # Validate type TProcEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TProcEmi' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_verProcType34(self, value):
        result = True
        # Validate type verProcType34, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on verProcType34' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on verProcType34' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_verProcType34_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_verProcType34_patterns_, ))
                result = False
        return result
    validate_verProcType34_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_indGlobalizadoType(self, value):
        result = True
        # Validate type indGlobalizadoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on indGlobalizadoType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunEnvType35(self, value):
        result = True
        # Validate type xMunEnvType35, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunEnvType35' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunEnvType35' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunEnvType35_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunEnvType35_patterns_, ))
                result = False
        return result
    validate_xMunEnvType35_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TModTransp(self, value):
        result = True
        # Validate type TModTransp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['01', '02', '03', '04', '05', '06']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TModTransp' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tpServType36(self, value):
        result = True
        # Validate type tpServType36, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1', '2', '3', '4']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpServType36' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_xMunIniType(self, value):
        result = True
        # Validate type xMunIniType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunIniType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunIniType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunIniType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunIniType_patterns_, ))
                result = False
        return result
    validate_xMunIniType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xMunFimType(self, value):
        result = True
        # Validate type xMunFimType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunFimType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunFimType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunFimType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunFimType_patterns_, ))
                result = False
        return result
    validate_xMunFimType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_retiraType(self, value):
        result = True
        # Validate type retiraType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on retiraType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_xDetRetiraType(self, value):
        result = True
        # Validate type xDetRetiraType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 160:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xDetRetiraType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xDetRetiraType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xDetRetiraType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xDetRetiraType_patterns_, ))
                result = False
        return result
    validate_xDetRetiraType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_indIETomaType37(self, value):
        result = True
        # Validate type indIETomaType37, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '9']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on indIETomaType37' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDateTimeUTC(self, value):
        result = True
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDateTimeUTC_patterns_, ))
                result = False
        return result
    validate_TDateTimeUTC_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_xJustType43(self, value):
        result = True
        # Validate type xJustType43, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xJustType43' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xJustType43' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xJustType43_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xJustType43_patterns_, ))
                result = False
        return result
    validate_xJustType43_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.cUF is not None or
            self.cCT is not None or
            self.CFOP is not None or
            self.natOp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nCT is not None or
            self.dhEmi is not None or
            self.tpImp is not None or
            self.tpEmis is not None or
            self.cDV is not None or
            self.tpAmb is not None or
            self.tpCTe is not None or
            self.procEmi is not None or
            self.verProc is not None or
            self.indGlobalizado is not None or
            self.cMunEnv is not None or
            self.xMunEnv is not None or
            self.UFEnv is not None or
            self.modal is not None or
            self.tpServ is not None or
            self.cMunIni is not None or
            self.xMunIni is not None or
            self.UFIni is not None or
            self.cMunFim is not None or
            self.xMunFim is not None or
            self.UFFim is not None or
            self.retira is not None or
            self.xDetRetira is not None or
            self.indIEToma is not None or
            self.toma3 is not None or
            self.toma4 is not None or
            self.dhCont is not None or
            self.xJust is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ideType26', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ideType26':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ideType26')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ideType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ideType26'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ideType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            namespaceprefix_ = self.cUF_nsprefix_ + ':' if (UseCapturedNS_ and self.cUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.cCT is not None:
            namespaceprefix_ = self.cCT_nsprefix_ + ':' if (UseCapturedNS_ and self.cCT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scCT>%s</%scCT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cCT), input_name='cCT')), namespaceprefix_ , eol_))
        if self.CFOP is not None:
            namespaceprefix_ = self.CFOP_nsprefix_ + ':' if (UseCapturedNS_ and self.CFOP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCFOP>%s</%sCFOP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CFOP), input_name='CFOP')), namespaceprefix_ , eol_))
        if self.natOp is not None:
            namespaceprefix_ = self.natOp_nsprefix_ + ':' if (UseCapturedNS_ and self.natOp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snatOp>%s</%snatOp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.natOp), input_name='natOp')), namespaceprefix_ , eol_))
        if self.mod is not None:
            namespaceprefix_ = self.mod_nsprefix_ + ':' if (UseCapturedNS_ and self.mod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            namespaceprefix_ = self.serie_nsprefix_ + ':' if (UseCapturedNS_ and self.serie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.nCT is not None:
            namespaceprefix_ = self.nCT_nsprefix_ + ':' if (UseCapturedNS_ and self.nCT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snCT>%s</%snCT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nCT), input_name='nCT')), namespaceprefix_ , eol_))
        if self.dhEmi is not None:
            namespaceprefix_ = self.dhEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dhEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhEmi>%s</%sdhEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhEmi), input_name='dhEmi')), namespaceprefix_ , eol_))
        if self.tpImp is not None:
            namespaceprefix_ = self.tpImp_nsprefix_ + ':' if (UseCapturedNS_ and self.tpImp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpImp>%s</%stpImp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpImp), input_name='tpImp')), namespaceprefix_ , eol_))
        if self.tpEmis is not None:
            namespaceprefix_ = self.tpEmis_nsprefix_ + ':' if (UseCapturedNS_ and self.tpEmis_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpEmis>%s</%stpEmis>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpEmis), input_name='tpEmis')), namespaceprefix_ , eol_))
        if self.cDV is not None:
            namespaceprefix_ = self.cDV_nsprefix_ + ':' if (UseCapturedNS_ and self.cDV_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scDV>%s</%scDV>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cDV), input_name='cDV')), namespaceprefix_ , eol_))
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.tpCTe is not None:
            namespaceprefix_ = self.tpCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.tpCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpCTe>%s</%stpCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpCTe), input_name='tpCTe')), namespaceprefix_ , eol_))
        if self.procEmi is not None:
            namespaceprefix_ = self.procEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.procEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocEmi>%s</%sprocEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.procEmi), input_name='procEmi')), namespaceprefix_ , eol_))
        if self.verProc is not None:
            namespaceprefix_ = self.verProc_nsprefix_ + ':' if (UseCapturedNS_ and self.verProc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverProc>%s</%sverProc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), namespaceprefix_ , eol_))
        if self.indGlobalizado is not None:
            namespaceprefix_ = self.indGlobalizado_nsprefix_ + ':' if (UseCapturedNS_ and self.indGlobalizado_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindGlobalizado>%s</%sindGlobalizado>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indGlobalizado), input_name='indGlobalizado')), namespaceprefix_ , eol_))
        if self.cMunEnv is not None:
            namespaceprefix_ = self.cMunEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.cMunEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunEnv>%s</%scMunEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunEnv), input_name='cMunEnv')), namespaceprefix_ , eol_))
        if self.xMunEnv is not None:
            namespaceprefix_ = self.xMunEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.xMunEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMunEnv>%s</%sxMunEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMunEnv), input_name='xMunEnv')), namespaceprefix_ , eol_))
        if self.UFEnv is not None:
            namespaceprefix_ = self.UFEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.UFEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFEnv>%s</%sUFEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFEnv), input_name='UFEnv')), namespaceprefix_ , eol_))
        if self.modal is not None:
            namespaceprefix_ = self.modal_nsprefix_ + ':' if (UseCapturedNS_ and self.modal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodal>%s</%smodal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modal), input_name='modal')), namespaceprefix_ , eol_))
        if self.tpServ is not None:
            namespaceprefix_ = self.tpServ_nsprefix_ + ':' if (UseCapturedNS_ and self.tpServ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpServ>%s</%stpServ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpServ), input_name='tpServ')), namespaceprefix_ , eol_))
        if self.cMunIni is not None:
            namespaceprefix_ = self.cMunIni_nsprefix_ + ':' if (UseCapturedNS_ and self.cMunIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunIni>%s</%scMunIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunIni), input_name='cMunIni')), namespaceprefix_ , eol_))
        if self.xMunIni is not None:
            namespaceprefix_ = self.xMunIni_nsprefix_ + ':' if (UseCapturedNS_ and self.xMunIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMunIni>%s</%sxMunIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMunIni), input_name='xMunIni')), namespaceprefix_ , eol_))
        if self.UFIni is not None:
            namespaceprefix_ = self.UFIni_nsprefix_ + ':' if (UseCapturedNS_ and self.UFIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFIni>%s</%sUFIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFIni), input_name='UFIni')), namespaceprefix_ , eol_))
        if self.cMunFim is not None:
            namespaceprefix_ = self.cMunFim_nsprefix_ + ':' if (UseCapturedNS_ and self.cMunFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunFim>%s</%scMunFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunFim), input_name='cMunFim')), namespaceprefix_ , eol_))
        if self.xMunFim is not None:
            namespaceprefix_ = self.xMunFim_nsprefix_ + ':' if (UseCapturedNS_ and self.xMunFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMunFim>%s</%sxMunFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMunFim), input_name='xMunFim')), namespaceprefix_ , eol_))
        if self.UFFim is not None:
            namespaceprefix_ = self.UFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.UFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFFim>%s</%sUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFFim), input_name='UFFim')), namespaceprefix_ , eol_))
        if self.retira is not None:
            namespaceprefix_ = self.retira_nsprefix_ + ':' if (UseCapturedNS_ and self.retira_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sretira>%s</%sretira>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.retira), input_name='retira')), namespaceprefix_ , eol_))
        if self.xDetRetira is not None:
            namespaceprefix_ = self.xDetRetira_nsprefix_ + ':' if (UseCapturedNS_ and self.xDetRetira_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxDetRetira>%s</%sxDetRetira>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xDetRetira), input_name='xDetRetira')), namespaceprefix_ , eol_))
        if self.indIEToma is not None:
            namespaceprefix_ = self.indIEToma_nsprefix_ + ':' if (UseCapturedNS_ and self.indIEToma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindIEToma>%s</%sindIEToma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indIEToma), input_name='indIEToma')), namespaceprefix_ , eol_))
        if self.toma3 is not None:
            namespaceprefix_ = self.toma3_nsprefix_ + ':' if (UseCapturedNS_ and self.toma3_nsprefix_) else ''
            self.toma3.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toma3', pretty_print=pretty_print)
        if self.toma4 is not None:
            namespaceprefix_ = self.toma4_nsprefix_ + ':' if (UseCapturedNS_ and self.toma4_nsprefix_) else ''
            self.toma4.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toma4', pretty_print=pretty_print)
        if self.dhCont is not None:
            namespaceprefix_ = self.dhCont_nsprefix_ + ':' if (UseCapturedNS_ and self.dhCont_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhCont>%s</%sdhCont>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhCont), input_name='dhCont')), namespaceprefix_ , eol_))
        if self.xJust is not None:
            namespaceprefix_ = self.xJust_nsprefix_ + ':' if (UseCapturedNS_ and self.xJust_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxJust>%s</%sxJust>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xJust), input_name='xJust')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cUF')
            value_ = self.gds_validate_string(value_, node, 'cUF')
            self.cUF = value_
            self.cUF_nsprefix_ = child_.prefix
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'cCT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cCT')
            value_ = self.gds_validate_string(value_, node, 'cCT')
            self.cCT = value_
            self.cCT_nsprefix_ = child_.prefix
            # validate type cCTType27
            self.validate_cCTType27(self.cCT)
        elif nodeName_ == 'CFOP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CFOP')
            value_ = self.gds_validate_string(value_, node, 'CFOP')
            self.CFOP = value_
            self.CFOP_nsprefix_ = child_.prefix
            # validate type TCfop
            self.validate_TCfop(self.CFOP)
        elif nodeName_ == 'natOp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'natOp')
            value_ = self.gds_validate_string(value_, node, 'natOp')
            self.natOp = value_
            self.natOp_nsprefix_ = child_.prefix
            # validate type natOpType28
            self.validate_natOpType28(self.natOp)
        elif nodeName_ == 'mod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mod')
            value_ = self.gds_validate_string(value_, node, 'mod')
            self.mod = value_
            self.mod_nsprefix_ = child_.prefix
            # validate type TModCT
            self.validate_TModCT(self.mod)
        elif nodeName_ == 'serie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serie')
            value_ = self.gds_validate_string(value_, node, 'serie')
            self.serie = value_
            self.serie_nsprefix_ = child_.prefix
            # validate type serieType29
            self.validate_serieType29(self.serie)
        elif nodeName_ == 'nCT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nCT')
            value_ = self.gds_validate_string(value_, node, 'nCT')
            self.nCT = value_
            self.nCT_nsprefix_ = child_.prefix
            # validate type TNF
            self.validate_TNF(self.nCT)
        elif nodeName_ == 'dhEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhEmi')
            value_ = self.gds_validate_string(value_, node, 'dhEmi')
            self.dhEmi = value_
            self.dhEmi_nsprefix_ = child_.prefix
            # validate type dhEmiType30
            self.validate_dhEmiType30(self.dhEmi)
        elif nodeName_ == 'tpImp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpImp')
            value_ = self.gds_validate_string(value_, node, 'tpImp')
            self.tpImp = value_
            self.tpImp_nsprefix_ = child_.prefix
            # validate type tpImpType31
            self.validate_tpImpType31(self.tpImp)
        elif nodeName_ == 'tpEmis':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpEmis')
            value_ = self.gds_validate_string(value_, node, 'tpEmis')
            self.tpEmis = value_
            self.tpEmis_nsprefix_ = child_.prefix
            # validate type tpEmisType32
            self.validate_tpEmisType32(self.tpEmis)
        elif nodeName_ == 'cDV':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cDV')
            value_ = self.gds_validate_string(value_, node, 'cDV')
            self.cDV = value_
            self.cDV_nsprefix_ = child_.prefix
            # validate type cDVType33
            self.validate_cDVType33(self.cDV)
        elif nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'tpCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpCTe')
            value_ = self.gds_validate_string(value_, node, 'tpCTe')
            self.tpCTe = value_
            self.tpCTe_nsprefix_ = child_.prefix
            # validate type TFinCTe
            self.validate_TFinCTe(self.tpCTe)
        elif nodeName_ == 'procEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'procEmi')
            value_ = self.gds_validate_string(value_, node, 'procEmi')
            self.procEmi = value_
            self.procEmi_nsprefix_ = child_.prefix
            # validate type TProcEmi
            self.validate_TProcEmi(self.procEmi)
        elif nodeName_ == 'verProc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verProc')
            value_ = self.gds_validate_string(value_, node, 'verProc')
            self.verProc = value_
            self.verProc_nsprefix_ = child_.prefix
            # validate type verProcType34
            self.validate_verProcType34(self.verProc)
        elif nodeName_ == 'indGlobalizado':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indGlobalizado')
            value_ = self.gds_validate_string(value_, node, 'indGlobalizado')
            self.indGlobalizado = value_
            self.indGlobalizado_nsprefix_ = child_.prefix
            # validate type indGlobalizadoType
            self.validate_indGlobalizadoType(self.indGlobalizado)
        elif nodeName_ == 'cMunEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMunEnv')
            value_ = self.gds_validate_string(value_, node, 'cMunEnv')
            self.cMunEnv = value_
            self.cMunEnv_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunEnv)
        elif nodeName_ == 'xMunEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMunEnv')
            value_ = self.gds_validate_string(value_, node, 'xMunEnv')
            self.xMunEnv = value_
            self.xMunEnv_nsprefix_ = child_.prefix
            # validate type xMunEnvType35
            self.validate_xMunEnvType35(self.xMunEnv)
        elif nodeName_ == 'UFEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UFEnv')
            value_ = self.gds_validate_string(value_, node, 'UFEnv')
            self.UFEnv = value_
            self.UFEnv_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UFEnv)
        elif nodeName_ == 'modal':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'modal')
            value_ = self.gds_validate_string(value_, node, 'modal')
            self.modal = value_
            self.modal_nsprefix_ = child_.prefix
            # validate type TModTransp
            self.validate_TModTransp(self.modal)
        elif nodeName_ == 'tpServ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpServ')
            value_ = self.gds_validate_string(value_, node, 'tpServ')
            self.tpServ = value_
            self.tpServ_nsprefix_ = child_.prefix
            # validate type tpServType36
            self.validate_tpServType36(self.tpServ)
        elif nodeName_ == 'cMunIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMunIni')
            value_ = self.gds_validate_string(value_, node, 'cMunIni')
            self.cMunIni = value_
            self.cMunIni_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunIni)
        elif nodeName_ == 'xMunIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMunIni')
            value_ = self.gds_validate_string(value_, node, 'xMunIni')
            self.xMunIni = value_
            self.xMunIni_nsprefix_ = child_.prefix
            # validate type xMunIniType
            self.validate_xMunIniType(self.xMunIni)
        elif nodeName_ == 'UFIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UFIni')
            value_ = self.gds_validate_string(value_, node, 'UFIni')
            self.UFIni = value_
            self.UFIni_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UFIni)
        elif nodeName_ == 'cMunFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMunFim')
            value_ = self.gds_validate_string(value_, node, 'cMunFim')
            self.cMunFim = value_
            self.cMunFim_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFim)
        elif nodeName_ == 'xMunFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMunFim')
            value_ = self.gds_validate_string(value_, node, 'xMunFim')
            self.xMunFim = value_
            self.xMunFim_nsprefix_ = child_.prefix
            # validate type xMunFimType
            self.validate_xMunFimType(self.xMunFim)
        elif nodeName_ == 'UFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UFFim')
            value_ = self.gds_validate_string(value_, node, 'UFFim')
            self.UFFim = value_
            self.UFFim_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UFFim)
        elif nodeName_ == 'retira':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'retira')
            value_ = self.gds_validate_string(value_, node, 'retira')
            self.retira = value_
            self.retira_nsprefix_ = child_.prefix
            # validate type retiraType
            self.validate_retiraType(self.retira)
        elif nodeName_ == 'xDetRetira':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xDetRetira')
            value_ = self.gds_validate_string(value_, node, 'xDetRetira')
            self.xDetRetira = value_
            self.xDetRetira_nsprefix_ = child_.prefix
            # validate type xDetRetiraType
            self.validate_xDetRetiraType(self.xDetRetira)
        elif nodeName_ == 'indIEToma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indIEToma')
            value_ = self.gds_validate_string(value_, node, 'indIEToma')
            self.indIEToma = value_
            self.indIEToma_nsprefix_ = child_.prefix
            # validate type indIETomaType37
            self.validate_indIETomaType37(self.indIEToma)
        elif nodeName_ == 'toma3':
            obj_ = toma3Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toma3 = obj_
            obj_.original_tagname_ = 'toma3'
        elif nodeName_ == 'toma4':
            obj_ = toma4Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toma4 = obj_
            obj_.original_tagname_ = 'toma4'
        elif nodeName_ == 'dhCont':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhCont')
            value_ = self.gds_validate_string(value_, node, 'dhCont')
            self.dhCont = value_
            self.dhCont_nsprefix_ = child_.prefix
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhCont)
        elif nodeName_ == 'xJust':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xJust')
            value_ = self.gds_validate_string(value_, node, 'xJust')
            self.xJust = value_
            self.xJust_nsprefix_ = child_.prefix
            # validate type xJustType43
            self.validate_xJustType43(self.xJust)
# end class ideType26


class toma3Type(GeneratedsSuper):
    """toma3Type -- Indicador do "papel" do tomador do servi
    ç
    o no CT-e
    toma -- Tomador do Servi
    ç
    o
    Preencher com:
    0-Remetente;
    1-Expedidor;
    2-Recebedor;
    3-Destinat
    á
    rio
    Ser
    ã
    o utilizadas as informa
    ç
    õ
    es contidas no respectivo grupo, conforme indicado pelo conte
    ú
    do deste campo
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, toma=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.toma = toma
        self.validate_tomaType38(self.toma)
        self.toma_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, toma3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if toma3Type.subclass:
            return toma3Type.subclass(*args_, **kwargs_)
        else:
            return toma3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_toma(self):
        return self.toma
    def set_toma(self, toma):
        self.toma = toma
    def validate_tomaType38(self, value):
        result = True
        # Validate type tomaType38, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1', '2', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tomaType38' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.toma is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='toma3Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('toma3Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'toma3Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='toma3Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='toma3Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='toma3Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='toma3Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.toma is not None:
            namespaceprefix_ = self.toma_nsprefix_ + ':' if (UseCapturedNS_ and self.toma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoma>%s</%stoma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.toma), input_name='toma')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'toma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'toma')
            value_ = self.gds_validate_string(value_, node, 'toma')
            self.toma = value_
            self.toma_nsprefix_ = child_.prefix
            # validate type tomaType38
            self.validate_tomaType38(self.toma)
# end class toma3Type


class toma4Type(GeneratedsSuper):
    """toma4Type -- Indicador do "papel" do tomador do servi
    ç
    o no CT-e
    toma -- Tomador do Servi
    ç
    o
    Preencher com:
    4 - Outros
    Obs: Informar os dados cadastrais do tomador do servi
    ç
    o
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do tomador ou ISENTO se tomador
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o tomador n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar o conte
    ú
    do.
    xNome -- Raz
    ã
    o Social ou Nome
    xFant -- Nome Fantasia
    fone -- Telefone
    enderToma -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, toma=None, CNPJ=None, CPF=None, IE=None, xNome=None, xFant=None, fone=None, enderToma=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.toma = toma
        self.validate_tomaType39(self.toma)
        self.toma_nsprefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType40(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType41(self.xNome)
        self.xNome_nsprefix_ = None
        self.xFant = xFant
        self.validate_xFantType42(self.xFant)
        self.xFant_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.enderToma = enderToma
        self.enderToma_nsprefix_ = None
        self.email = email
        self.validate_TEmail(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, toma4Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if toma4Type.subclass:
            return toma4Type.subclass(*args_, **kwargs_)
        else:
            return toma4Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_toma(self):
        return self.toma
    def set_toma(self, toma):
        self.toma = toma
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_enderToma(self):
        return self.enderToma
    def set_enderToma(self, enderToma):
        self.enderToma = enderToma
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_tomaType39(self, value):
        result = True
        # Validate type tomaType39, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['4']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tomaType39' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType40(self, value):
        result = True
        # Validate type IEType40, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType40' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType40_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType40_patterns_, ))
                result = False
        return result
    validate_IEType40_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType41(self, value):
        result = True
        # Validate type xNomeType41, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType41' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType41' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType41_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType41_patterns_, ))
                result = False
        return result
    validate_xNomeType41_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xFantType42(self, value):
        result = True
        # Validate type xFantType42, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xFantType42' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xFantType42' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType42_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xFantType42_patterns_, ))
                result = False
        return result
    validate_xFantType42_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_TEmail(self, value):
        result = True
        # Validate type TEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TEmail_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TEmail_patterns_, ))
                result = False
        return result
    validate_TEmail_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.toma is not None or
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.fone is not None or
            self.enderToma is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='toma4Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('toma4Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'toma4Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='toma4Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='toma4Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='toma4Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='toma4Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.toma is not None:
            namespaceprefix_ = self.toma_nsprefix_ + ':' if (UseCapturedNS_ and self.toma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoma>%s</%stoma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.toma), input_name='toma')), namespaceprefix_ , eol_))
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            namespaceprefix_ = self.xFant_nsprefix_ + ':' if (UseCapturedNS_ and self.xFant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.enderToma is not None:
            namespaceprefix_ = self.enderToma_nsprefix_ + ':' if (UseCapturedNS_ and self.enderToma_nsprefix_) else ''
            self.enderToma.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderToma', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'toma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'toma')
            value_ = self.gds_validate_string(value_, node, 'toma')
            self.toma = value_
            self.toma_nsprefix_ = child_.prefix
            # validate type tomaType39
            self.validate_tomaType39(self.toma)
        elif nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType40
            self.validate_IEType40(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType41
            self.validate_xNomeType41(self.xNome)
        elif nodeName_ == 'xFant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xFant')
            value_ = self.gds_validate_string(value_, node, 'xFant')
            self.xFant = value_
            self.xFant_nsprefix_ = child_.prefix
            # validate type xFantType42
            self.validate_xFantType42(self.xFant)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'enderToma':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderToma = obj_
            obj_.original_tagname_ = 'enderToma'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class toma4Type


class complType44(GeneratedsSuper):
    """complType44 -- Dados complementares do CT-e para fins operacionais ou comerciais
    xCaracAd -- Caracter
    í
    stica adicional do transporte
    Texto livre:
    REENTREGA; DEVOLU
    Ç
    Ã
    O; REFATURAMENTO; etc
    xCaracSer -- Caracter
    í
    stica adicional do servi
    ç
    o
    Texto livre:
    ENTREGA EXPRESSA; LOG
    Í
    STICA REVERSA; CONVENCIONAL; EMERGENCIAL; etc
    xEmi -- Funcion
    á
    rio emissor do CTe
    fluxo -- Previs
    ã
    o do fluxo da carga
    Preenchimento obrigat
    ó
    rio para o modal a
    é
    reo.
    Entrega -- Informa
    ç
    õ
    es ref. a previs
    ã
    o de entrega
    origCalc -- Munic
    í
    pio de origem para efeito de c
    á
    lculo do frete
    destCalc -- Munic
    í
    pio de destino para efeito de c
    á
    lculo do frete
    xObs -- Observa
    ç
    õ
    es Gerais
    ObsCont -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    ObsFisco -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCaracAd=None, xCaracSer=None, xEmi=None, fluxo=None, Entrega=None, origCalc=None, destCalc=None, xObs=None, ObsCont=None, ObsFisco=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCaracAd = xCaracAd
        self.validate_xCaracAdType45(self.xCaracAd)
        self.xCaracAd_nsprefix_ = None
        self.xCaracSer = xCaracSer
        self.validate_xCaracSerType46(self.xCaracSer)
        self.xCaracSer_nsprefix_ = None
        self.xEmi = xEmi
        self.validate_xEmiType47(self.xEmi)
        self.xEmi_nsprefix_ = None
        self.fluxo = fluxo
        self.fluxo_nsprefix_ = None
        self.Entrega = Entrega
        self.Entrega_nsprefix_ = None
        self.origCalc = origCalc
        self.validate_origCalcType(self.origCalc)
        self.origCalc_nsprefix_ = None
        self.destCalc = destCalc
        self.validate_destCalcType(self.destCalc)
        self.destCalc_nsprefix_ = None
        self.xObs = xObs
        self.validate_xObsType52(self.xObs)
        self.xObs_nsprefix_ = None
        if ObsCont is None:
            self.ObsCont = []
        else:
            self.ObsCont = ObsCont
        self.ObsCont_nsprefix_ = None
        if ObsFisco is None:
            self.ObsFisco = []
        else:
            self.ObsFisco = ObsFisco
        self.ObsFisco_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complType44)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complType44.subclass:
            return complType44.subclass(*args_, **kwargs_)
        else:
            return complType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xCaracAd(self):
        return self.xCaracAd
    def set_xCaracAd(self, xCaracAd):
        self.xCaracAd = xCaracAd
    def get_xCaracSer(self):
        return self.xCaracSer
    def set_xCaracSer(self, xCaracSer):
        self.xCaracSer = xCaracSer
    def get_xEmi(self):
        return self.xEmi
    def set_xEmi(self, xEmi):
        self.xEmi = xEmi
    def get_fluxo(self):
        return self.fluxo
    def set_fluxo(self, fluxo):
        self.fluxo = fluxo
    def get_Entrega(self):
        return self.Entrega
    def set_Entrega(self, Entrega):
        self.Entrega = Entrega
    def get_origCalc(self):
        return self.origCalc
    def set_origCalc(self, origCalc):
        self.origCalc = origCalc
    def get_destCalc(self):
        return self.destCalc
    def set_destCalc(self, destCalc):
        self.destCalc = destCalc
    def get_xObs(self):
        return self.xObs
    def set_xObs(self, xObs):
        self.xObs = xObs
    def get_ObsCont(self):
        return self.ObsCont
    def set_ObsCont(self, ObsCont):
        self.ObsCont = ObsCont
    def add_ObsCont(self, value):
        self.ObsCont.append(value)
    def insert_ObsCont_at(self, index, value):
        self.ObsCont.insert(index, value)
    def replace_ObsCont_at(self, index, value):
        self.ObsCont[index] = value
    def get_ObsFisco(self):
        return self.ObsFisco
    def set_ObsFisco(self, ObsFisco):
        self.ObsFisco = ObsFisco
    def add_ObsFisco(self, value):
        self.ObsFisco.append(value)
    def insert_ObsFisco_at(self, index, value):
        self.ObsFisco.insert(index, value)
    def replace_ObsFisco_at(self, index, value):
        self.ObsFisco[index] = value
    def validate_xCaracAdType45(self, value):
        result = True
        # Validate type xCaracAdType45, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCaracAdType45' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCaracAdType45' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCaracAdType45_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCaracAdType45_patterns_, ))
                result = False
        return result
    validate_xCaracAdType45_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCaracSerType46(self, value):
        result = True
        # Validate type xCaracSerType46, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCaracSerType46' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCaracSerType46' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCaracSerType46_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCaracSerType46_patterns_, ))
                result = False
        return result
    validate_xCaracSerType46_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xEmiType47(self, value):
        result = True
        # Validate type xEmiType47, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xEmiType47' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xEmiType47' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xEmiType47_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xEmiType47_patterns_, ))
                result = False
        return result
    validate_xEmiType47_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_origCalcType(self, value):
        result = True
        # Validate type origCalcType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on origCalcType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on origCalcType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_origCalcType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_origCalcType_patterns_, ))
                result = False
        return result
    validate_origCalcType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_destCalcType(self, value):
        result = True
        # Validate type destCalcType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on destCalcType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on destCalcType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_destCalcType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_destCalcType_patterns_, ))
                result = False
        return result
    validate_destCalcType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xObsType52(self, value):
        result = True
        # Validate type xObsType52, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xObsType52' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xObsType52' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xObsType52_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xObsType52_patterns_, ))
                result = False
        return result
    validate_xObsType52_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xCaracAd is not None or
            self.xCaracSer is not None or
            self.xEmi is not None or
            self.fluxo is not None or
            self.Entrega is not None or
            self.origCalc is not None or
            self.destCalc is not None or
            self.xObs is not None or
            self.ObsCont or
            self.ObsFisco
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='complType44', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complType44')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complType44':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complType44')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complType44', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='complType44'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='complType44', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xCaracAd is not None:
            namespaceprefix_ = self.xCaracAd_nsprefix_ + ':' if (UseCapturedNS_ and self.xCaracAd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCaracAd>%s</%sxCaracAd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCaracAd), input_name='xCaracAd')), namespaceprefix_ , eol_))
        if self.xCaracSer is not None:
            namespaceprefix_ = self.xCaracSer_nsprefix_ + ':' if (UseCapturedNS_ and self.xCaracSer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCaracSer>%s</%sxCaracSer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCaracSer), input_name='xCaracSer')), namespaceprefix_ , eol_))
        if self.xEmi is not None:
            namespaceprefix_ = self.xEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.xEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxEmi>%s</%sxEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xEmi), input_name='xEmi')), namespaceprefix_ , eol_))
        if self.fluxo is not None:
            namespaceprefix_ = self.fluxo_nsprefix_ + ':' if (UseCapturedNS_ and self.fluxo_nsprefix_) else ''
            self.fluxo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fluxo', pretty_print=pretty_print)
        if self.Entrega is not None:
            namespaceprefix_ = self.Entrega_nsprefix_ + ':' if (UseCapturedNS_ and self.Entrega_nsprefix_) else ''
            self.Entrega.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Entrega', pretty_print=pretty_print)
        if self.origCalc is not None:
            namespaceprefix_ = self.origCalc_nsprefix_ + ':' if (UseCapturedNS_ and self.origCalc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorigCalc>%s</%sorigCalc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.origCalc), input_name='origCalc')), namespaceprefix_ , eol_))
        if self.destCalc is not None:
            namespaceprefix_ = self.destCalc_nsprefix_ + ':' if (UseCapturedNS_ and self.destCalc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdestCalc>%s</%sdestCalc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.destCalc), input_name='destCalc')), namespaceprefix_ , eol_))
        if self.xObs is not None:
            namespaceprefix_ = self.xObs_nsprefix_ + ':' if (UseCapturedNS_ and self.xObs_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxObs>%s</%sxObs>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xObs), input_name='xObs')), namespaceprefix_ , eol_))
        for ObsCont_ in self.ObsCont:
            namespaceprefix_ = self.ObsCont_nsprefix_ + ':' if (UseCapturedNS_ and self.ObsCont_nsprefix_) else ''
            ObsCont_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObsCont', pretty_print=pretty_print)
        for ObsFisco_ in self.ObsFisco:
            namespaceprefix_ = self.ObsFisco_nsprefix_ + ':' if (UseCapturedNS_ and self.ObsFisco_nsprefix_) else ''
            ObsFisco_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObsFisco', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xCaracAd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCaracAd')
            value_ = self.gds_validate_string(value_, node, 'xCaracAd')
            self.xCaracAd = value_
            self.xCaracAd_nsprefix_ = child_.prefix
            # validate type xCaracAdType45
            self.validate_xCaracAdType45(self.xCaracAd)
        elif nodeName_ == 'xCaracSer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCaracSer')
            value_ = self.gds_validate_string(value_, node, 'xCaracSer')
            self.xCaracSer = value_
            self.xCaracSer_nsprefix_ = child_.prefix
            # validate type xCaracSerType46
            self.validate_xCaracSerType46(self.xCaracSer)
        elif nodeName_ == 'xEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xEmi')
            value_ = self.gds_validate_string(value_, node, 'xEmi')
            self.xEmi = value_
            self.xEmi_nsprefix_ = child_.prefix
            # validate type xEmiType47
            self.validate_xEmiType47(self.xEmi)
        elif nodeName_ == 'fluxo':
            obj_ = fluxoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fluxo = obj_
            obj_.original_tagname_ = 'fluxo'
        elif nodeName_ == 'Entrega':
            obj_ = EntregaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Entrega = obj_
            obj_.original_tagname_ = 'Entrega'
        elif nodeName_ == 'origCalc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'origCalc')
            value_ = self.gds_validate_string(value_, node, 'origCalc')
            self.origCalc = value_
            self.origCalc_nsprefix_ = child_.prefix
            # validate type origCalcType
            self.validate_origCalcType(self.origCalc)
        elif nodeName_ == 'destCalc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'destCalc')
            value_ = self.gds_validate_string(value_, node, 'destCalc')
            self.destCalc = value_
            self.destCalc_nsprefix_ = child_.prefix
            # validate type destCalcType
            self.validate_destCalcType(self.destCalc)
        elif nodeName_ == 'xObs':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xObs')
            value_ = self.gds_validate_string(value_, node, 'xObs')
            self.xObs = value_
            self.xObs_nsprefix_ = child_.prefix
            # validate type xObsType52
            self.validate_xObsType52(self.xObs)
        elif nodeName_ == 'ObsCont':
            obj_ = ObsContType53.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsCont.append(obj_)
            obj_.original_tagname_ = 'ObsCont'
        elif nodeName_ == 'ObsFisco':
            obj_ = ObsFiscoType56.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsFisco.append(obj_)
            obj_.original_tagname_ = 'ObsFisco'
# end class complType44


class fluxoType(GeneratedsSuper):
    """fluxoType -- Previs
    ã
    o do fluxo da carga
    Preenchimento obrigat
    ó
    rio para o modal a
    é
    reo.
    xOrig -- Sigla ou c
    ó
    digo interno da Filial/Porto/Esta
    ç
    ã
    o/ Aeroporto de Origem
    Observa
    ç
    õ
    es para o modal a
    é
    reo:
    - Preenchimento obrigat
    ó
    rio para o modal a
    é
    reo.
    - O c
    ó
    digo de tr
    ê
    s letras IATA do aeroporto de partida dever
    á
    ser inclu
    í
    do como primeira anota
    ç
    ã
    o. Quando n
    ã
    o for poss
    í
    vel, utilizar a sigla OACI.
    xDest -- Sigla ou c
    ó
    digo interno da Filial/Porto/Esta
    ç
    ã
    o/Aeroporto de Destino
    Observa
    ç
    õ
    es para o modal a
    é
    reo:
    - Preenchimento obrigat
    ó
    rio para o modal a
    é
    reo.
    - Dever
    á
    ser inclu
    í
    do o c
    ó
    digo de tr
    ê
    s letras IATA do aeroporto de destino. Quando n
    ã
    o for poss
    í
    vel, utilizar a sigla OACI.
    xRota -- C
    ó
    digo da Rota de Entrega
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xOrig=None, pass_=None, xDest=None, xRota=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xOrig = xOrig
        self.validate_xOrigType(self.xOrig)
        self.xOrig_nsprefix_ = None
        if pass_ is None:
            self.pass_ = []
        else:
            self.pass_ = pass_
        self.pass__nsprefix_ = None
        self.xDest = xDest
        self.validate_xDestType(self.xDest)
        self.xDest_nsprefix_ = None
        self.xRota = xRota
        self.validate_xRotaType(self.xRota)
        self.xRota_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fluxoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fluxoType.subclass:
            return fluxoType.subclass(*args_, **kwargs_)
        else:
            return fluxoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xOrig(self):
        return self.xOrig
    def set_xOrig(self, xOrig):
        self.xOrig = xOrig
    def get_pass(self):
        return self.pass_
    def set_pass(self, pass_):
        self.pass_ = pass_
    def add_pass(self, value):
        self.pass_.append(value)
    def insert_pass_at(self, index, value):
        self.pass_.insert(index, value)
    def replace_pass_at(self, index, value):
        self.pass_[index] = value
    def get_xDest(self):
        return self.xDest
    def set_xDest(self, xDest):
        self.xDest = xDest
    def get_xRota(self):
        return self.xRota
    def set_xRota(self, xRota):
        self.xRota = xRota
    def validate_xOrigType(self, value):
        result = True
        # Validate type xOrigType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xOrigType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xOrigType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xOrigType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xOrigType_patterns_, ))
                result = False
        return result
    validate_xOrigType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xDestType(self, value):
        result = True
        # Validate type xDestType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xDestType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xDestType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xDestType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xDestType_patterns_, ))
                result = False
        return result
    validate_xDestType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xRotaType(self, value):
        result = True
        # Validate type xRotaType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 10:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xRotaType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xRotaType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xRotaType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xRotaType_patterns_, ))
                result = False
        return result
    validate_xRotaType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xOrig is not None or
            self.pass_ or
            self.xDest is not None or
            self.xRota is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fluxoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fluxoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fluxoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fluxoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fluxoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fluxoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fluxoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xOrig is not None:
            namespaceprefix_ = self.xOrig_nsprefix_ + ':' if (UseCapturedNS_ and self.xOrig_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxOrig>%s</%sxOrig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xOrig), input_name='xOrig')), namespaceprefix_ , eol_))
        for pass_ in self.pass_:
            namespaceprefix_ = self.pass__nsprefix_ + ':' if (UseCapturedNS_ and self.pass__nsprefix_) else ''
            pass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pass', pretty_print=pretty_print)
        if self.xDest is not None:
            namespaceprefix_ = self.xDest_nsprefix_ + ':' if (UseCapturedNS_ and self.xDest_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxDest>%s</%sxDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xDest), input_name='xDest')), namespaceprefix_ , eol_))
        if self.xRota is not None:
            namespaceprefix_ = self.xRota_nsprefix_ + ':' if (UseCapturedNS_ and self.xRota_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxRota>%s</%sxRota>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xRota), input_name='xRota')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xOrig':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xOrig')
            value_ = self.gds_validate_string(value_, node, 'xOrig')
            self.xOrig = value_
            self.xOrig_nsprefix_ = child_.prefix
            # validate type xOrigType
            self.validate_xOrigType(self.xOrig)
        elif nodeName_ == 'pass':
            obj_ = passType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pass_.append(obj_)
            obj_.original_tagname_ = 'pass'
        elif nodeName_ == 'xDest':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xDest')
            value_ = self.gds_validate_string(value_, node, 'xDest')
            self.xDest = value_
            self.xDest_nsprefix_ = child_.prefix
            # validate type xDestType
            self.validate_xDestType(self.xDest)
        elif nodeName_ == 'xRota':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xRota')
            value_ = self.gds_validate_string(value_, node, 'xRota')
            self.xRota = value_
            self.xRota_nsprefix_ = child_.prefix
            # validate type xRotaType
            self.validate_xRotaType(self.xRota)
# end class fluxoType


class passType(GeneratedsSuper):
    """xPass -- Sigla ou c
    ó
    digo interno da Filial/Porto/Esta
    ç
    ã
    o/Aeroporto de Passagem
    Observa
    ç
    ã
    o para o modal a
    é
    reo:
    - O c
    ó
    digo de tr
    ê
    s letras IATA, referente ao aeroporto de transfer
    ê
    ncia, dever
    á
    ser inclu
    í
    do, quando for o caso. Quando n
    ã
    o for poss
    í
    vel,  utilizar a sigla OACI. Qualquer solicita
    ç
    ã
    o de itiner
    á
    rio dever
    á
    ser inclu
    í
    da.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xPass=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xPass = xPass
        self.validate_xPassType(self.xPass)
        self.xPass_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, passType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if passType.subclass:
            return passType.subclass(*args_, **kwargs_)
        else:
            return passType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xPass(self):
        return self.xPass
    def set_xPass(self, xPass):
        self.xPass = xPass
    def validate_xPassType(self, value):
        result = True
        # Validate type xPassType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xPassType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xPassType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xPassType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xPassType_patterns_, ))
                result = False
        return result
    validate_xPassType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xPass is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='passType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('passType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'passType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='passType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='passType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='passType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='passType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xPass is not None:
            namespaceprefix_ = self.xPass_nsprefix_ + ':' if (UseCapturedNS_ and self.xPass_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxPass>%s</%sxPass>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xPass), input_name='xPass')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xPass':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xPass')
            value_ = self.gds_validate_string(value_, node, 'xPass')
            self.xPass = value_
            self.xPass_nsprefix_ = child_.prefix
            # validate type xPassType
            self.validate_xPassType(self.xPass)
# end class passType


class EntregaType(GeneratedsSuper):
    """EntregaType -- Informa
    ç
    õ
    es ref. a previs
    ã
    o de entrega
    semData -- Entrega sem data definida
    Esta op
    ç
    ã
    o
    é
    proibida para o modal a
    é
    reo.
    comData -- Entrega com data definida
    noPeriodo -- Entrega no per
    í
    odo definido
    semHora -- Entrega sem hora definida
    comHora -- Entrega com hora definida
    noInter -- Entrega no intervalo de hor
    á
    rio definido
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, semData=None, comData=None, noPeriodo=None, semHora=None, comHora=None, noInter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.semData = semData
        self.semData_nsprefix_ = None
        self.comData = comData
        self.comData_nsprefix_ = None
        self.noPeriodo = noPeriodo
        self.noPeriodo_nsprefix_ = None
        self.semHora = semHora
        self.semHora_nsprefix_ = None
        self.comHora = comHora
        self.comHora_nsprefix_ = None
        self.noInter = noInter
        self.noInter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntregaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntregaType.subclass:
            return EntregaType.subclass(*args_, **kwargs_)
        else:
            return EntregaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_semData(self):
        return self.semData
    def set_semData(self, semData):
        self.semData = semData
    def get_comData(self):
        return self.comData
    def set_comData(self, comData):
        self.comData = comData
    def get_noPeriodo(self):
        return self.noPeriodo
    def set_noPeriodo(self, noPeriodo):
        self.noPeriodo = noPeriodo
    def get_semHora(self):
        return self.semHora
    def set_semHora(self, semHora):
        self.semHora = semHora
    def get_comHora(self):
        return self.comHora
    def set_comHora(self, comHora):
        self.comHora = comHora
    def get_noInter(self):
        return self.noInter
    def set_noInter(self, noInter):
        self.noInter = noInter
    def _hasContent(self):
        if (
            self.semData is not None or
            self.comData is not None or
            self.noPeriodo is not None or
            self.semHora is not None or
            self.comHora is not None or
            self.noInter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='EntregaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntregaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EntregaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EntregaType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EntregaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EntregaType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='EntregaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.semData is not None:
            namespaceprefix_ = self.semData_nsprefix_ + ':' if (UseCapturedNS_ and self.semData_nsprefix_) else ''
            self.semData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='semData', pretty_print=pretty_print)
        if self.comData is not None:
            namespaceprefix_ = self.comData_nsprefix_ + ':' if (UseCapturedNS_ and self.comData_nsprefix_) else ''
            self.comData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comData', pretty_print=pretty_print)
        if self.noPeriodo is not None:
            namespaceprefix_ = self.noPeriodo_nsprefix_ + ':' if (UseCapturedNS_ and self.noPeriodo_nsprefix_) else ''
            self.noPeriodo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='noPeriodo', pretty_print=pretty_print)
        if self.semHora is not None:
            namespaceprefix_ = self.semHora_nsprefix_ + ':' if (UseCapturedNS_ and self.semHora_nsprefix_) else ''
            self.semHora.export(outfile, level, namespaceprefix_, namespacedef_='', name_='semHora', pretty_print=pretty_print)
        if self.comHora is not None:
            namespaceprefix_ = self.comHora_nsprefix_ + ':' if (UseCapturedNS_ and self.comHora_nsprefix_) else ''
            self.comHora.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comHora', pretty_print=pretty_print)
        if self.noInter is not None:
            namespaceprefix_ = self.noInter_nsprefix_ + ':' if (UseCapturedNS_ and self.noInter_nsprefix_) else ''
            self.noInter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='noInter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'semData':
            obj_ = semDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semData = obj_
            obj_.original_tagname_ = 'semData'
        elif nodeName_ == 'comData':
            obj_ = comDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comData = obj_
            obj_.original_tagname_ = 'comData'
        elif nodeName_ == 'noPeriodo':
            obj_ = noPeriodoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.noPeriodo = obj_
            obj_.original_tagname_ = 'noPeriodo'
        elif nodeName_ == 'semHora':
            obj_ = semHoraType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.semHora = obj_
            obj_.original_tagname_ = 'semHora'
        elif nodeName_ == 'comHora':
            obj_ = comHoraType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comHora = obj_
            obj_.original_tagname_ = 'comHora'
        elif nodeName_ == 'noInter':
            obj_ = noInterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.noInter = obj_
            obj_.original_tagname_ = 'noInter'
# end class EntregaType


class semDataType(GeneratedsSuper):
    """semDataType -- Entrega sem data definida
    Esta op
    ç
    ã
    o
    é
    proibida para o modal a
    é
    reo.
    tpPer -- Tipo de data/per
    í
    odo programado para entrega
    0- Sem data definida
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpPer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpPer = tpPer
        self.validate_tpPerType(self.tpPer)
        self.tpPer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, semDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if semDataType.subclass:
            return semDataType.subclass(*args_, **kwargs_)
        else:
            return semDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpPer(self):
        return self.tpPer
    def set_tpPer(self, tpPer):
        self.tpPer = tpPer
    def validate_tpPerType(self, value):
        result = True
        # Validate type tpPerType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpPerType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.tpPer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='semDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('semDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'semDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='semDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='semDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='semDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='semDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpPer is not None:
            namespaceprefix_ = self.tpPer_nsprefix_ + ':' if (UseCapturedNS_ and self.tpPer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpPer>%s</%stpPer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpPer), input_name='tpPer')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpPer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpPer')
            value_ = self.gds_validate_string(value_, node, 'tpPer')
            self.tpPer = value_
            self.tpPer_nsprefix_ = child_.prefix
            # validate type tpPerType
            self.validate_tpPerType(self.tpPer)
# end class semDataType


class comDataType(GeneratedsSuper):
    """comDataType -- Entrega com data definida
    tpPer -- Tipo de data/per
    í
    odo programado para entrega
    Preencher com:
    1-Na data;
    2-At
    é
    a data;
    3-A partir da data
    dProg -- Data programada
    Formato AAAA-MM-DD
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpPer=None, dProg=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpPer = tpPer
        self.validate_tpPerType48(self.tpPer)
        self.tpPer_nsprefix_ = None
        self.dProg = dProg
        self.validate_TData(self.dProg)
        self.dProg_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, comDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if comDataType.subclass:
            return comDataType.subclass(*args_, **kwargs_)
        else:
            return comDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpPer(self):
        return self.tpPer
    def set_tpPer(self, tpPer):
        self.tpPer = tpPer
    def get_dProg(self):
        return self.dProg
    def set_dProg(self, dProg):
        self.dProg = dProg
    def validate_tpPerType48(self, value):
        result = True
        # Validate type tpPerType48, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpPerType48' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def _hasContent(self):
        if (
            self.tpPer is not None or
            self.dProg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='comDataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('comDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'comDataType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='comDataType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='comDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='comDataType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='comDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpPer is not None:
            namespaceprefix_ = self.tpPer_nsprefix_ + ':' if (UseCapturedNS_ and self.tpPer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpPer>%s</%stpPer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpPer), input_name='tpPer')), namespaceprefix_ , eol_))
        if self.dProg is not None:
            namespaceprefix_ = self.dProg_nsprefix_ + ':' if (UseCapturedNS_ and self.dProg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdProg>%s</%sdProg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dProg), input_name='dProg')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpPer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpPer')
            value_ = self.gds_validate_string(value_, node, 'tpPer')
            self.tpPer = value_
            self.tpPer_nsprefix_ = child_.prefix
            # validate type tpPerType48
            self.validate_tpPerType48(self.tpPer)
        elif nodeName_ == 'dProg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dProg')
            value_ = self.gds_validate_string(value_, node, 'dProg')
            self.dProg = value_
            self.dProg_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dProg)
# end class comDataType


class noPeriodoType(GeneratedsSuper):
    """noPeriodoType -- Entrega no per
    í
    odo definido
    tpPer -- Tipo per
    í
    odo
    4-no per
    í
    odo
    dIni -- Data inicial
    Formato AAAA-MM-DD
    dFim -- Data final
    Formato AAAA-MM-DD
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpPer=None, dIni=None, dFim=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpPer = tpPer
        self.validate_tpPerType49(self.tpPer)
        self.tpPer_nsprefix_ = None
        self.dIni = dIni
        self.validate_TData(self.dIni)
        self.dIni_nsprefix_ = None
        self.dFim = dFim
        self.validate_TData(self.dFim)
        self.dFim_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noPeriodoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noPeriodoType.subclass:
            return noPeriodoType.subclass(*args_, **kwargs_)
        else:
            return noPeriodoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpPer(self):
        return self.tpPer
    def set_tpPer(self, tpPer):
        self.tpPer = tpPer
    def get_dIni(self):
        return self.dIni
    def set_dIni(self, dIni):
        self.dIni = dIni
    def get_dFim(self):
        return self.dFim
    def set_dFim(self, dFim):
        self.dFim = dFim
    def validate_tpPerType49(self, value):
        result = True
        # Validate type tpPerType49, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['4']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpPerType49' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def _hasContent(self):
        if (
            self.tpPer is not None or
            self.dIni is not None or
            self.dFim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='noPeriodoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('noPeriodoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'noPeriodoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='noPeriodoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='noPeriodoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='noPeriodoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='noPeriodoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpPer is not None:
            namespaceprefix_ = self.tpPer_nsprefix_ + ':' if (UseCapturedNS_ and self.tpPer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpPer>%s</%stpPer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpPer), input_name='tpPer')), namespaceprefix_ , eol_))
        if self.dIni is not None:
            namespaceprefix_ = self.dIni_nsprefix_ + ':' if (UseCapturedNS_ and self.dIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdIni>%s</%sdIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dIni), input_name='dIni')), namespaceprefix_ , eol_))
        if self.dFim is not None:
            namespaceprefix_ = self.dFim_nsprefix_ + ':' if (UseCapturedNS_ and self.dFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdFim>%s</%sdFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dFim), input_name='dFim')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpPer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpPer')
            value_ = self.gds_validate_string(value_, node, 'tpPer')
            self.tpPer = value_
            self.tpPer_nsprefix_ = child_.prefix
            # validate type tpPerType49
            self.validate_tpPerType49(self.tpPer)
        elif nodeName_ == 'dIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dIni')
            value_ = self.gds_validate_string(value_, node, 'dIni')
            self.dIni = value_
            self.dIni_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dIni)
        elif nodeName_ == 'dFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dFim')
            value_ = self.gds_validate_string(value_, node, 'dFim')
            self.dFim = value_
            self.dFim_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dFim)
# end class noPeriodoType


class semHoraType(GeneratedsSuper):
    """semHoraType -- Entrega sem hora definida
    tpHor -- Tipo de hora
    0- Sem hora definida
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpHor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpHor = tpHor
        self.validate_tpHorType(self.tpHor)
        self.tpHor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, semHoraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if semHoraType.subclass:
            return semHoraType.subclass(*args_, **kwargs_)
        else:
            return semHoraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpHor(self):
        return self.tpHor
    def set_tpHor(self, tpHor):
        self.tpHor = tpHor
    def validate_tpHorType(self, value):
        result = True
        # Validate type tpHorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpHorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.tpHor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='semHoraType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('semHoraType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'semHoraType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='semHoraType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='semHoraType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='semHoraType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='semHoraType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpHor is not None:
            namespaceprefix_ = self.tpHor_nsprefix_ + ':' if (UseCapturedNS_ and self.tpHor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpHor>%s</%stpHor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpHor), input_name='tpHor')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpHor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpHor')
            value_ = self.gds_validate_string(value_, node, 'tpHor')
            self.tpHor = value_
            self.tpHor_nsprefix_ = child_.prefix
            # validate type tpHorType
            self.validate_tpHorType(self.tpHor)
# end class semHoraType


class comHoraType(GeneratedsSuper):
    """comHoraType -- Entrega com hora definida
    tpHor -- Tipo de hora
    Preencher com:
    1 - No hor
    á
    rio;
    2 - At
    é
    o hor
    á
    rio;
    3 - A partir do hor
    á
    rio.
    hProg -- Hora programada
    Formato HH:MM:SS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpHor=None, hProg=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpHor = tpHor
        self.validate_tpHorType50(self.tpHor)
        self.tpHor_nsprefix_ = None
        self.hProg = hProg
        self.validate_TTime(self.hProg)
        self.hProg_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, comHoraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if comHoraType.subclass:
            return comHoraType.subclass(*args_, **kwargs_)
        else:
            return comHoraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpHor(self):
        return self.tpHor
    def set_tpHor(self, tpHor):
        self.tpHor = tpHor
    def get_hProg(self):
        return self.hProg
    def set_hProg(self, hProg):
        self.hProg = hProg
    def validate_tpHorType50(self, value):
        result = True
        # Validate type tpHorType50, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpHorType50' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TTime(self, value):
        result = True
        # Validate type TTime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TTime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TTime_patterns_, ))
                result = False
        return result
    validate_TTime_patterns_ = [['^((([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9]))$']]
    def _hasContent(self):
        if (
            self.tpHor is not None or
            self.hProg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='comHoraType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('comHoraType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'comHoraType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='comHoraType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='comHoraType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='comHoraType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='comHoraType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpHor is not None:
            namespaceprefix_ = self.tpHor_nsprefix_ + ':' if (UseCapturedNS_ and self.tpHor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpHor>%s</%stpHor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpHor), input_name='tpHor')), namespaceprefix_ , eol_))
        if self.hProg is not None:
            namespaceprefix_ = self.hProg_nsprefix_ + ':' if (UseCapturedNS_ and self.hProg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shProg>%s</%shProg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.hProg), input_name='hProg')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpHor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpHor')
            value_ = self.gds_validate_string(value_, node, 'tpHor')
            self.tpHor = value_
            self.tpHor_nsprefix_ = child_.prefix
            # validate type tpHorType50
            self.validate_tpHorType50(self.tpHor)
        elif nodeName_ == 'hProg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'hProg')
            value_ = self.gds_validate_string(value_, node, 'hProg')
            self.hProg = value_
            self.hProg_nsprefix_ = child_.prefix
            # validate type TTime
            self.validate_TTime(self.hProg)
# end class comHoraType


class noInterType(GeneratedsSuper):
    """noInterType -- Entrega no intervalo de hor
    á
    rio definido
    tpHor --  Tipo de hora
    4 - No intervalo de tempo
    hIni -- Hora inicial
    Formato HH:MM:SS
    hFim -- Hora final
    Formato HH:MM:SS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpHor=None, hIni=None, hFim=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpHor = tpHor
        self.validate_tpHorType51(self.tpHor)
        self.tpHor_nsprefix_ = None
        self.hIni = hIni
        self.validate_TTime(self.hIni)
        self.hIni_nsprefix_ = None
        self.hFim = hFim
        self.validate_TTime(self.hFim)
        self.hFim_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, noInterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if noInterType.subclass:
            return noInterType.subclass(*args_, **kwargs_)
        else:
            return noInterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpHor(self):
        return self.tpHor
    def set_tpHor(self, tpHor):
        self.tpHor = tpHor
    def get_hIni(self):
        return self.hIni
    def set_hIni(self, hIni):
        self.hIni = hIni
    def get_hFim(self):
        return self.hFim
    def set_hFim(self, hFim):
        self.hFim = hFim
    def validate_tpHorType51(self, value):
        result = True
        # Validate type tpHorType51, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['4']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpHorType51' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TTime(self, value):
        result = True
        # Validate type TTime, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TTime_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TTime_patterns_, ))
                result = False
        return result
    validate_TTime_patterns_ = [['^((([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9]))$']]
    def _hasContent(self):
        if (
            self.tpHor is not None or
            self.hIni is not None or
            self.hFim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='noInterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('noInterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'noInterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='noInterType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='noInterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='noInterType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='noInterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpHor is not None:
            namespaceprefix_ = self.tpHor_nsprefix_ + ':' if (UseCapturedNS_ and self.tpHor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpHor>%s</%stpHor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpHor), input_name='tpHor')), namespaceprefix_ , eol_))
        if self.hIni is not None:
            namespaceprefix_ = self.hIni_nsprefix_ + ':' if (UseCapturedNS_ and self.hIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shIni>%s</%shIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.hIni), input_name='hIni')), namespaceprefix_ , eol_))
        if self.hFim is not None:
            namespaceprefix_ = self.hFim_nsprefix_ + ':' if (UseCapturedNS_ and self.hFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shFim>%s</%shFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.hFim), input_name='hFim')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpHor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpHor')
            value_ = self.gds_validate_string(value_, node, 'tpHor')
            self.tpHor = value_
            self.tpHor_nsprefix_ = child_.prefix
            # validate type tpHorType51
            self.validate_tpHorType51(self.tpHor)
        elif nodeName_ == 'hIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'hIni')
            value_ = self.gds_validate_string(value_, node, 'hIni')
            self.hIni = value_
            self.hIni_nsprefix_ = child_.prefix
            # validate type TTime
            self.validate_TTime(self.hIni)
        elif nodeName_ == 'hFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'hFim')
            value_ = self.gds_validate_string(value_, node, 'hFim')
            self.hFim = value_
            self.hFim_nsprefix_ = child_.prefix
            # validate type TTime
            self.validate_TTime(self.hFim)
# end class noInterType


class ObsContType53(GeneratedsSuper):
    """ObsContType53 -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    xCampo -- Identifica
    ç
    ã
    o do campo
    xTexto -- Conte
    ú
    do do campo
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCampo = _cast(None, xCampo)
        self.xCampo_nsprefix_ = None
        self.xTexto = xTexto
        self.validate_xTextoType54(self.xTexto)
        self.xTexto_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsContType53)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsContType53.subclass:
            return ObsContType53.subclass(*args_, **kwargs_)
        else:
            return ObsContType53(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xTexto(self):
        return self.xTexto
    def set_xTexto(self, xTexto):
        self.xTexto = xTexto
    def get_xCampo(self):
        return self.xCampo
    def set_xCampo(self, xCampo):
        self.xCampo = xCampo
    def validate_xTextoType54(self, value):
        result = True
        # Validate type xTextoType54, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 160:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xTextoType54' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xTextoType54' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType54_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xTextoType54_patterns_, ))
                result = False
        return result
    validate_xTextoType54_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCampoType55(self, value):
        # Validate type xCampoType55, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCampoType55' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCampoType55' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCampoType55_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCampoType55_patterns_, ))
    validate_xCampoType55_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsContType53', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsContType53')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObsContType53':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsContType53')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsContType53', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsContType53'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsContType53', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            namespaceprefix_ = self.xTexto_nsprefix_ + ':' if (UseCapturedNS_ and self.xTexto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxTexto>%s</%sxTexto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_xCampoType55(self.xCampo)    # validate type xCampoType55
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xTexto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xTexto')
            value_ = self.gds_validate_string(value_, node, 'xTexto')
            self.xTexto = value_
            self.xTexto_nsprefix_ = child_.prefix
            # validate type xTextoType54
            self.validate_xTextoType54(self.xTexto)
# end class ObsContType53


class ObsFiscoType56(GeneratedsSuper):
    """ObsFiscoType56 -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    xCampo -- Identifica
    ç
    ã
    o do campo
    xTexto -- Conte
    ú
    do do campo
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCampo = _cast(None, xCampo)
        self.xCampo_nsprefix_ = None
        self.xTexto = xTexto
        self.validate_xTextoType57(self.xTexto)
        self.xTexto_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsFiscoType56)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsFiscoType56.subclass:
            return ObsFiscoType56.subclass(*args_, **kwargs_)
        else:
            return ObsFiscoType56(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xTexto(self):
        return self.xTexto
    def set_xTexto(self, xTexto):
        self.xTexto = xTexto
    def get_xCampo(self):
        return self.xCampo
    def set_xCampo(self, xCampo):
        self.xCampo = xCampo
    def validate_xTextoType57(self, value):
        result = True
        # Validate type xTextoType57, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xTextoType57' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xTextoType57' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType57_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xTextoType57_patterns_, ))
                result = False
        return result
    validate_xTextoType57_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCampoType58(self, value):
        # Validate type xCampoType58, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCampoType58' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCampoType58' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCampoType58_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCampoType58_patterns_, ))
    validate_xCampoType58_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsFiscoType56', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsFiscoType56')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObsFiscoType56':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsFiscoType56')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsFiscoType56', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsFiscoType56'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsFiscoType56', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            namespaceprefix_ = self.xTexto_nsprefix_ + ':' if (UseCapturedNS_ and self.xTexto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxTexto>%s</%sxTexto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_xCampoType58(self.xCampo)    # validate type xCampoType58
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xTexto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xTexto')
            value_ = self.gds_validate_string(value_, node, 'xTexto')
            self.xTexto = value_
            self.xTexto_nsprefix_ = child_.prefix
            # validate type xTextoType57
            self.validate_xTextoType57(self.xTexto)
# end class ObsFiscoType56


class emitType59(GeneratedsSuper):
    """emitType59 -- Identifica
    ç
    ã
    o do Emitente do CT-e
    CNPJ -- CNPJ do emitente
    Informar zeros n
    ã
    o significativos
    CPF -- CPF do emitente
    Informar zeros n
    ã
    o significativos.
    Usar com s
    é
    rie espec
    í
    fica 920-969 para emitente pessoa f
    í
    sica com inscri
    ç
    ã
    o estadual
    IE -- Inscri
    ç
    ã
    o Estadual do Emitente
    A IE do emitente somente ficar
    á
    sem informa
    ç
    ã
    o para o caso do Regime Especial da NFF (tpEmis=3)
    IEST -- Inscri
    ç
    ã
    o Estadual do Substituto Tribut
    á
    rio
    xNome -- Raz
    ã
    o social ou Nome do emitente
    xFant -- Nome fantasia
    enderEmit -- Endere
    ç
    o do emitente
    CRT -- C
    ó
    digo do Regime Tribut
    á
    rio
    Informar: 1=Simples Nacional;
    2=Simples Nacional, excesso sublimite de receita bruta;
    3=Regime Normal.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, IEST=None, xNome=None, xFant=None, enderEmit=None, CRT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType60(self.IE)
        self.IE_nsprefix_ = None
        self.IEST = IEST
        self.validate_IESTType61(self.IEST)
        self.IEST_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType62(self.xNome)
        self.xNome_nsprefix_ = None
        self.xFant = xFant
        self.validate_xFantType63(self.xFant)
        self.xFant_nsprefix_ = None
        self.enderEmit = enderEmit
        self.enderEmit_nsprefix_ = None
        self.CRT = CRT
        self.validate_TCRT(self.CRT)
        self.CRT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emitType59)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emitType59.subclass:
            return emitType59.subclass(*args_, **kwargs_)
        else:
            return emitType59(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_IEST(self):
        return self.IEST
    def set_IEST(self, IEST):
        self.IEST = IEST
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_enderEmit(self):
        return self.enderEmit
    def set_enderEmit(self, enderEmit):
        self.enderEmit = enderEmit
    def get_CRT(self):
        return self.CRT
    def set_CRT(self, CRT):
        self.CRT = CRT
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType60(self, value):
        result = True
        # Validate type IEType60, a restriction on TIe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType60' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType60_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType60_patterns_, ))
                result = False
        return result
    validate_IEType60_patterns_ = [['^([0-9]{2,14})$']]
    def validate_IESTType61(self, value):
        result = True
        # Validate type IESTType61, a restriction on TIe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IESTType61' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IESTType61_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IESTType61_patterns_, ))
                result = False
        return result
    validate_IESTType61_patterns_ = [['^([0-9]{2,14})$']]
    def validate_xNomeType62(self, value):
        result = True
        # Validate type xNomeType62, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType62' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType62' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType62_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType62_patterns_, ))
                result = False
        return result
    validate_xNomeType62_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xFantType63(self, value):
        result = True
        # Validate type xFantType63, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xFantType63' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xFantType63' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType63_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xFantType63_patterns_, ))
                result = False
        return result
    validate_xFantType63_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCRT(self, value):
        result = True
        # Validate type TCRT, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCRT' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TCRT' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TCRT' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.IEST is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None or
            self.CRT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='emitType59', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emitType59')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'emitType59':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='emitType59')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='emitType59', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='emitType59'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='emitType59', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.IEST is not None:
            namespaceprefix_ = self.IEST_nsprefix_ + ':' if (UseCapturedNS_ and self.IEST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIEST>%s</%sIEST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IEST), input_name='IEST')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            namespaceprefix_ = self.xFant_nsprefix_ + ':' if (UseCapturedNS_ and self.xFant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.enderEmit is not None:
            namespaceprefix_ = self.enderEmit_nsprefix_ + ':' if (UseCapturedNS_ and self.enderEmit_nsprefix_) else ''
            self.enderEmit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderEmit', pretty_print=pretty_print)
        if self.CRT is not None:
            namespaceprefix_ = self.CRT_nsprefix_ + ':' if (UseCapturedNS_ and self.CRT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCRT>%s</%sCRT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CRT), input_name='CRT')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType60
            self.validate_IEType60(self.IE)
        elif nodeName_ == 'IEST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IEST')
            value_ = self.gds_validate_string(value_, node, 'IEST')
            self.IEST = value_
            self.IEST_nsprefix_ = child_.prefix
            # validate type IESTType61
            self.validate_IESTType61(self.IEST)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType62
            self.validate_xNomeType62(self.xNome)
        elif nodeName_ == 'xFant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xFant')
            value_ = self.gds_validate_string(value_, node, 'xFant')
            self.xFant = value_
            self.xFant_nsprefix_ = child_.prefix
            # validate type xFantType63
            self.validate_xFantType63(self.xFant)
        elif nodeName_ == 'enderEmit':
            obj_ = TEndeEmi.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
        elif nodeName_ == 'CRT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CRT')
            value_ = self.gds_validate_string(value_, node, 'CRT')
            self.CRT = value_
            self.CRT_nsprefix_ = child_.prefix
            # validate type TCRT
            self.validate_TCRT(self.CRT)
# end class emitType59


class remType64(GeneratedsSuper):
    """remType64 -- Informa
    ç
    õ
    es do Remetente das mercadorias transportadas pelo CT-e
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do remetente ou ISENTO se remetente
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o remetente n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar a tag.
    xNome -- Raz
    ã
    o social ou nome do remetente
    xFant -- Nome fantasia
    fone -- Telefone
    enderReme -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, xFant=None, fone=None, enderReme=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType65(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType66(self.xNome)
        self.xNome_nsprefix_ = None
        self.xFant = xFant
        self.validate_xFantType67(self.xFant)
        self.xFant_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.enderReme = enderReme
        self.enderReme_nsprefix_ = None
        self.email = email
        self.validate_emailType68(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remType64)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remType64.subclass:
            return remType64.subclass(*args_, **kwargs_)
        else:
            return remType64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_enderReme(self):
        return self.enderReme
    def set_enderReme(self, enderReme):
        self.enderReme = enderReme
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType65(self, value):
        result = True
        # Validate type IEType65, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType65' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType65_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType65_patterns_, ))
                result = False
        return result
    validate_IEType65_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType66(self, value):
        result = True
        # Validate type xNomeType66, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType66' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType66' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType66_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType66_patterns_, ))
                result = False
        return result
    validate_xNomeType66_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xFantType67(self, value):
        result = True
        # Validate type xFantType67, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xFantType67' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xFantType67' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType67_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xFantType67_patterns_, ))
                result = False
        return result
    validate_xFantType67_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_emailType68(self, value):
        result = True
        # Validate type emailType68, a restriction on TEmail.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType68' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType68' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType68_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType68_patterns_, ))
                result = False
        return result
    validate_emailType68_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.fone is not None or
            self.enderReme is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='remType64', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remType64')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'remType64':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remType64')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='remType64', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='remType64'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='remType64', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            namespaceprefix_ = self.xFant_nsprefix_ + ':' if (UseCapturedNS_ and self.xFant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.enderReme is not None:
            namespaceprefix_ = self.enderReme_nsprefix_ + ':' if (UseCapturedNS_ and self.enderReme_nsprefix_) else ''
            self.enderReme.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderReme', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType65
            self.validate_IEType65(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType66
            self.validate_xNomeType66(self.xNome)
        elif nodeName_ == 'xFant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xFant')
            value_ = self.gds_validate_string(value_, node, 'xFant')
            self.xFant = value_
            self.xFant_nsprefix_ = child_.prefix
            # validate type xFantType67
            self.validate_xFantType67(self.xFant)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'enderReme':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderReme = obj_
            obj_.original_tagname_ = 'enderReme'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType68
            self.validate_emailType68(self.email)
# end class remType64


class expedType(GeneratedsSuper):
    """expedType -- Informa
    ç
    õ
    es do Expedidor da Carga
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do expedidor ou ISENTO se expedidor
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o expedidor n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar a tag.
    xNome -- Raz
    ã
    o Social ou Nome
    fone -- Telefone
    enderExped -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, fone=None, enderExped=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType69(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType70(self.xNome)
        self.xNome_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.enderExped = enderExped
        self.enderExped_nsprefix_ = None
        self.email = email
        self.validate_TEmail(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, expedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if expedType.subclass:
            return expedType.subclass(*args_, **kwargs_)
        else:
            return expedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_enderExped(self):
        return self.enderExped
    def set_enderExped(self, enderExped):
        self.enderExped = enderExped
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType69(self, value):
        result = True
        # Validate type IEType69, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType69' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType69_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType69_patterns_, ))
                result = False
        return result
    validate_IEType69_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType70(self, value):
        result = True
        # Validate type xNomeType70, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType70' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType70' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType70_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType70_patterns_, ))
                result = False
        return result
    validate_xNomeType70_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_TEmail(self, value):
        result = True
        # Validate type TEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TEmail_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TEmail_patterns_, ))
                result = False
        return result
    validate_TEmail_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.fone is not None or
            self.enderExped is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='expedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('expedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'expedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='expedType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='expedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='expedType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='expedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.enderExped is not None:
            namespaceprefix_ = self.enderExped_nsprefix_ + ':' if (UseCapturedNS_ and self.enderExped_nsprefix_) else ''
            self.enderExped.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderExped', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType69
            self.validate_IEType69(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType70
            self.validate_xNomeType70(self.xNome)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'enderExped':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderExped = obj_
            obj_.original_tagname_ = 'enderExped'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class expedType


class recebType(GeneratedsSuper):
    """recebType -- Informa
    ç
    õ
    es do Recebedor da Carga
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do recebedor ou ISENTO se recebedor
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o recebedor n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar o conte
    ú
    do.
    xNome -- Raz
    ã
    o Social ou Nome
    fone -- Telefone
    enderReceb -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, fone=None, enderReceb=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType71(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType72(self.xNome)
        self.xNome_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.enderReceb = enderReceb
        self.enderReceb_nsprefix_ = None
        self.email = email
        self.validate_TEmail(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recebType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recebType.subclass:
            return recebType.subclass(*args_, **kwargs_)
        else:
            return recebType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_enderReceb(self):
        return self.enderReceb
    def set_enderReceb(self, enderReceb):
        self.enderReceb = enderReceb
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType71(self, value):
        result = True
        # Validate type IEType71, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType71' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType71_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType71_patterns_, ))
                result = False
        return result
    validate_IEType71_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType72(self, value):
        result = True
        # Validate type xNomeType72, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType72' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType72' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType72_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType72_patterns_, ))
                result = False
        return result
    validate_xNomeType72_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_TEmail(self, value):
        result = True
        # Validate type TEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TEmail_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TEmail_patterns_, ))
                result = False
        return result
    validate_TEmail_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.fone is not None or
            self.enderReceb is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='recebType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('recebType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'recebType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='recebType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='recebType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='recebType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='recebType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.enderReceb is not None:
            namespaceprefix_ = self.enderReceb_nsprefix_ + ':' if (UseCapturedNS_ and self.enderReceb_nsprefix_) else ''
            self.enderReceb.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderReceb', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType71
            self.validate_IEType71(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType72
            self.validate_xNomeType72(self.xNome)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'enderReceb':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderReceb = obj_
            obj_.original_tagname_ = 'enderReceb'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class recebType


class destType73(GeneratedsSuper):
    """destType73 -- Informa
    ç
    õ
    es do Destinat
    á
    rio do CT-e
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do destinat
    á
    rio ou ISENTO se destinat
    á
    rio
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o destinat
    á
    rio n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar o conte
    ú
    do.
    xNome -- Raz
    ã
    o Social ou Nome do destinat
    á
    rio
    fone -- Telefone
    ISUF -- Inscri
    ç
    ã
    o na SUFRAMA
    (Obrigat
    ó
    rio nas opera
    ç
    õ
    es com as
    á
    reas com benef
    í
    cios de incentivos fiscais sob controle da SUFRAMA)
    enderDest -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, fone=None, ISUF=None, enderDest=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType74(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType75(self.xNome)
        self.xNome_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.ISUF = ISUF
        self.validate_ISUFType76(self.ISUF)
        self.ISUF_nsprefix_ = None
        self.enderDest = enderDest
        self.enderDest_nsprefix_ = None
        self.email = email
        self.validate_TEmail(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, destType73)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if destType73.subclass:
            return destType73.subclass(*args_, **kwargs_)
        else:
            return destType73(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_ISUF(self):
        return self.ISUF
    def set_ISUF(self, ISUF):
        self.ISUF = ISUF
    def get_enderDest(self):
        return self.enderDest
    def set_enderDest(self, enderDest):
        self.enderDest = enderDest
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType74(self, value):
        result = True
        # Validate type IEType74, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType74' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType74_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType74_patterns_, ))
                result = False
        return result
    validate_IEType74_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType75(self, value):
        result = True
        # Validate type xNomeType75, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType75' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType75' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType75_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType75_patterns_, ))
                result = False
        return result
    validate_xNomeType75_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_ISUFType76(self, value):
        result = True
        # Validate type ISUFType76, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_ISUFType76_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_ISUFType76_patterns_, ))
                result = False
        return result
    validate_ISUFType76_patterns_ = [['^([0-9]{8,9})$']]
    def validate_TEmail(self, value):
        result = True
        # Validate type TEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TEmail' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TEmail_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TEmail_patterns_, ))
                result = False
        return result
    validate_TEmail_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.fone is not None or
            self.ISUF is not None or
            self.enderDest is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='destType73', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('destType73')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'destType73':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='destType73')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='destType73', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='destType73'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='destType73', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.ISUF is not None:
            namespaceprefix_ = self.ISUF_nsprefix_ + ':' if (UseCapturedNS_ and self.ISUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISUF>%s</%sISUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISUF), input_name='ISUF')), namespaceprefix_ , eol_))
        if self.enderDest is not None:
            namespaceprefix_ = self.enderDest_nsprefix_ + ':' if (UseCapturedNS_ and self.enderDest_nsprefix_) else ''
            self.enderDest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderDest', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType74
            self.validate_IEType74(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType75
            self.validate_xNomeType75(self.xNome)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'ISUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISUF')
            value_ = self.gds_validate_string(value_, node, 'ISUF')
            self.ISUF = value_
            self.ISUF_nsprefix_ = child_.prefix
            # validate type ISUFType76
            self.validate_ISUFType76(self.ISUF)
        elif nodeName_ == 'enderDest':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderDest = obj_
            obj_.original_tagname_ = 'enderDest'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type TEmail
            self.validate_TEmail(self.email)
# end class destType73


class vPrestType(GeneratedsSuper):
    """vPrestType -- Valores da Presta
    ç
    ã
    o de Servi
    ç
    o
    vTPrest -- Valor Total da Presta
    ç
    ã
    o do Servi
    ç
    o
    Pode conter zeros quando o CT-e for de complemento de ICMS
    vRec -- Valor a Receber
    Comp -- Componentes do Valor da Presta
    ç
    ã
    o
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vTPrest=None, vRec=None, Comp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vTPrest = vTPrest
        self.validate_TDec_1302(self.vTPrest)
        self.vTPrest_nsprefix_ = None
        self.vRec = vRec
        self.validate_TDec_1302(self.vRec)
        self.vRec_nsprefix_ = None
        if Comp is None:
            self.Comp = []
        else:
            self.Comp = Comp
        self.Comp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vPrestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vPrestType.subclass:
            return vPrestType.subclass(*args_, **kwargs_)
        else:
            return vPrestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vTPrest(self):
        return self.vTPrest
    def set_vTPrest(self, vTPrest):
        self.vTPrest = vTPrest
    def get_vRec(self):
        return self.vRec
    def set_vRec(self, vRec):
        self.vRec = vRec
    def get_Comp(self):
        return self.Comp
    def set_Comp(self, Comp):
        self.Comp = Comp
    def add_Comp(self, value):
        self.Comp.append(value)
    def insert_Comp_at(self, index, value):
        self.Comp.insert(index, value)
    def replace_Comp_at(self, index, value):
        self.Comp[index] = value
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.vTPrest is not None or
            self.vRec is not None or
            self.Comp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='vPrestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vPrestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'vPrestType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vPrestType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='vPrestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vPrestType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='vPrestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vTPrest is not None:
            namespaceprefix_ = self.vTPrest_nsprefix_ + ':' if (UseCapturedNS_ and self.vTPrest_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTPrest>%s</%svTPrest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vTPrest), input_name='vTPrest')), namespaceprefix_ , eol_))
        if self.vRec is not None:
            namespaceprefix_ = self.vRec_nsprefix_ + ':' if (UseCapturedNS_ and self.vRec_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svRec>%s</%svRec>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vRec), input_name='vRec')), namespaceprefix_ , eol_))
        for Comp_ in self.Comp:
            namespaceprefix_ = self.Comp_nsprefix_ + ':' if (UseCapturedNS_ and self.Comp_nsprefix_) else ''
            Comp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vTPrest':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vTPrest')
            value_ = self.gds_validate_string(value_, node, 'vTPrest')
            self.vTPrest = value_
            self.vTPrest_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTPrest)
        elif nodeName_ == 'vRec':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vRec')
            value_ = self.gds_validate_string(value_, node, 'vRec')
            self.vRec = value_
            self.vRec_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vRec)
        elif nodeName_ == 'Comp':
            obj_ = CompType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comp.append(obj_)
            obj_.original_tagname_ = 'Comp'
# end class vPrestType


class CompType(GeneratedsSuper):
    """CompType -- Componentes do Valor da Presta
    ç
    ã
    o
    xNome -- Nome do componente
    Exxemplos: FRETE PESO, FRETE VALOR, SEC/CAT, ADEME, AGENDAMENTO, etc
    vComp -- Valor do componente
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xNome=None, vComp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xNome = xNome
        self.validate_xNomeType77(self.xNome)
        self.xNome_nsprefix_ = None
        self.vComp = vComp
        self.validate_TDec_1302(self.vComp)
        self.vComp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompType.subclass:
            return CompType.subclass(*args_, **kwargs_)
        else:
            return CompType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_vComp(self):
        return self.vComp
    def set_vComp(self, vComp):
        self.vComp = vComp
    def validate_xNomeType77(self, value):
        result = True
        # Validate type xNomeType77, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType77' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType77' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType77_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType77_patterns_, ))
                result = False
        return result
    validate_xNomeType77_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.xNome is not None or
            self.vComp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='CompType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CompType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='CompType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.vComp is not None:
            namespaceprefix_ = self.vComp_nsprefix_ + ':' if (UseCapturedNS_ and self.vComp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svComp>%s</%svComp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vComp), input_name='vComp')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType77
            self.validate_xNomeType77(self.xNome)
        elif nodeName_ == 'vComp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vComp')
            value_ = self.gds_validate_string(value_, node, 'vComp')
            self.vComp = value_
            self.vComp_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vComp)
# end class CompType


class impType(GeneratedsSuper):
    """impType -- Informa
    ç
    õ
    es relativas aos Impostos
    ICMS -- Informa
    ç
    õ
    es relativas ao ICMS
    vTotTrib -- Valor Total dos Tributos
    infAdFisco -- Informa
    ç
    õ
    es adicionais de interesse do Fisco
    Norma referenciada, informa
    ç
    õ
    es complementares, etc
    ICMSUFFim -- Informa
    ç
    õ
    es do ICMS de partilha com a UF de t
    é
    rmino do servi
    ç
    o de transporte na opera
    ç
    ã
    o interestadual
    Grupo a ser informado nas presta
    ç
    õ
    es interestaduais para consumidor final, n
    ã
    o contribuinte do ICMS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ICMS=None, vTotTrib=None, infAdFisco=None, ICMSUFFim=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ICMS = ICMS
        self.ICMS_nsprefix_ = None
        self.vTotTrib = vTotTrib
        self.validate_TDec_1302(self.vTotTrib)
        self.vTotTrib_nsprefix_ = None
        self.infAdFisco = infAdFisco
        self.validate_infAdFiscoType(self.infAdFisco)
        self.infAdFisco_nsprefix_ = None
        self.ICMSUFFim = ICMSUFFim
        self.ICMSUFFim_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, impType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if impType.subclass:
            return impType.subclass(*args_, **kwargs_)
        else:
            return impType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ICMS(self):
        return self.ICMS
    def set_ICMS(self, ICMS):
        self.ICMS = ICMS
    def get_vTotTrib(self):
        return self.vTotTrib
    def set_vTotTrib(self, vTotTrib):
        self.vTotTrib = vTotTrib
    def get_infAdFisco(self):
        return self.infAdFisco
    def set_infAdFisco(self, infAdFisco):
        self.infAdFisco = infAdFisco
    def get_ICMSUFFim(self):
        return self.ICMSUFFim
    def set_ICMSUFFim(self, ICMSUFFim):
        self.ICMSUFFim = ICMSUFFim
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_infAdFiscoType(self, value):
        result = True
        # Validate type infAdFiscoType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on infAdFiscoType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on infAdFiscoType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdFiscoType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_infAdFiscoType_patterns_, ))
                result = False
        return result
    validate_infAdFiscoType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.ICMS is not None or
            self.vTotTrib is not None or
            self.infAdFisco is not None or
            self.ICMSUFFim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='impType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('impType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'impType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='impType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='impType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='impType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='impType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS is not None:
            namespaceprefix_ = self.ICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS_nsprefix_) else ''
            self.ICMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS', pretty_print=pretty_print)
        if self.vTotTrib is not None:
            namespaceprefix_ = self.vTotTrib_nsprefix_ + ':' if (UseCapturedNS_ and self.vTotTrib_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTotTrib>%s</%svTotTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vTotTrib), input_name='vTotTrib')), namespaceprefix_ , eol_))
        if self.infAdFisco is not None:
            namespaceprefix_ = self.infAdFisco_nsprefix_ + ':' if (UseCapturedNS_ and self.infAdFisco_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinfAdFisco>%s</%sinfAdFisco>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.infAdFisco), input_name='infAdFisco')), namespaceprefix_ , eol_))
        if self.ICMSUFFim is not None:
            namespaceprefix_ = self.ICMSUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMSUFFim_nsprefix_) else ''
            self.ICMSUFFim.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSUFFim', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ICMS':
            obj_ = TImp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS = obj_
            obj_.original_tagname_ = 'ICMS'
        elif nodeName_ == 'vTotTrib':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vTotTrib')
            value_ = self.gds_validate_string(value_, node, 'vTotTrib')
            self.vTotTrib = value_
            self.vTotTrib_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotTrib)
        elif nodeName_ == 'infAdFisco':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'infAdFisco')
            value_ = self.gds_validate_string(value_, node, 'infAdFisco')
            self.infAdFisco = value_
            self.infAdFisco_nsprefix_ = child_.prefix
            # validate type infAdFiscoType
            self.validate_infAdFiscoType(self.infAdFisco)
        elif nodeName_ == 'ICMSUFFim':
            obj_ = ICMSUFFimType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMSUFFim = obj_
            obj_.original_tagname_ = 'ICMSUFFim'
# end class impType


class ICMSUFFimType(GeneratedsSuper):
    """ICMSUFFimType -- Informa
    ç
    õ
    es do ICMS de partilha com a UF de t
    é
    rmino do servi
    ç
    o de transporte na opera
    ç
    ã
    o interestadual
    Grupo a ser informado nas presta
    ç
    õ
    es interestaduais para consumidor final, n
    ã
    o contribuinte do ICMS
    vBCUFFim -- Valor da BC do ICMS na UF de t
    é
    rmino da presta
    ç
    ã
    o do servi
    ç
    o de transporte
    pFCPUFFim -- Percentual do ICMS relativo ao Fundo de Combate
    à
    pobreza (FCP) na UF de t
    é
    rmino da presta
    ç
    ã
    o do servi
    ç
    o de transporte
    Al
    í
    quota adotada nas opera
    ç
    õ
    es internas na UF do destinat
    á
    rio
    pICMSUFFim -- Al
    í
    quota interna da UF de t
    é
    rmino da presta
    ç
    ã
    o do servi
    ç
    o de transporte
    Al
    í
    quota adotada nas opera
    ç
    õ
    es internas na UF do destinat
    á
    rio
    pICMSInter -- Al
    í
    quota interestadual das UF envolvidas
    Al
    í
    quota interestadual das UF envolvidas
      
    * vFCPUFFim -- Valor do ICMS relativo ao Fundo de Combate
      á
      Pobreza (FCP) da UF de t
      é
      rmino da presta
      ç
      ã
      o
    * vICMSUFFim -- Valor do ICMS de partilha para a UF de t
      é
      rmino da presta
      ç
      ã
      o do servi
      ç
      o de transporte
    * vICMSUFIni -- Valor do ICMS de partilha para a UF de in
      í
      cio da presta
      ç
      ã
      o do servi
      ç
      o de transporte
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vBCUFFim=None, pFCPUFFim=None, pICMSUFFim=None, pICMSInter=None, vFCPUFFim=None, vICMSUFFim=None, vICMSUFIni=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vBCUFFim = vBCUFFim
        self.validate_TDec_1302(self.vBCUFFim)
        self.vBCUFFim_nsprefix_ = None
        self.pFCPUFFim = pFCPUFFim
        self.validate_TDec_0302(self.pFCPUFFim)
        self.pFCPUFFim_nsprefix_ = None
        self.pICMSUFFim = pICMSUFFim
        self.validate_TDec_0302(self.pICMSUFFim)
        self.pICMSUFFim_nsprefix_ = None
        self.pICMSInter = pICMSInter
        self.validate_TDec_0302(self.pICMSInter)
        self.pICMSInter_nsprefix_ = None
        self.vFCPUFFim = vFCPUFFim
        self.validate_TDec_1302(self.vFCPUFFim)
        self.vFCPUFFim_nsprefix_ = None
        self.vICMSUFFim = vICMSUFFim
        self.validate_TDec_1302(self.vICMSUFFim)
        self.vICMSUFFim_nsprefix_ = None
        self.vICMSUFIni = vICMSUFIni
        self.validate_TDec_1302(self.vICMSUFIni)
        self.vICMSUFIni_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSUFFimType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSUFFimType.subclass:
            return ICMSUFFimType.subclass(*args_, **kwargs_)
        else:
            return ICMSUFFimType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vBCUFFim(self):
        return self.vBCUFFim
    def set_vBCUFFim(self, vBCUFFim):
        self.vBCUFFim = vBCUFFim
    def get_pFCPUFFim(self):
        return self.pFCPUFFim
    def set_pFCPUFFim(self, pFCPUFFim):
        self.pFCPUFFim = pFCPUFFim
    def get_pICMSUFFim(self):
        return self.pICMSUFFim
    def set_pICMSUFFim(self, pICMSUFFim):
        self.pICMSUFFim = pICMSUFFim
    def get_pICMSInter(self):
        return self.pICMSInter
    def set_pICMSInter(self, pICMSInter):
        self.pICMSInter = pICMSInter
    def get_vFCPUFFim(self):
        return self.vFCPUFFim
    def set_vFCPUFFim(self, vFCPUFFim):
        self.vFCPUFFim = vFCPUFFim
    def get_vICMSUFFim(self):
        return self.vICMSUFFim
    def set_vICMSUFFim(self, vICMSUFFim):
        self.vICMSUFFim = vICMSUFFim
    def get_vICMSUFIni(self):
        return self.vICMSUFIni
    def set_vICMSUFIni(self, vICMSUFIni):
        self.vICMSUFIni = vICMSUFIni
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.vBCUFFim is not None or
            self.pFCPUFFim is not None or
            self.pICMSUFFim is not None or
            self.pICMSInter is not None or
            self.vFCPUFFim is not None or
            self.vICMSUFFim is not None or
            self.vICMSUFIni is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSUFFimType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSUFFimType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMSUFFimType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSUFFimType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSUFFimType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSUFFimType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSUFFimType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBCUFFim is not None:
            namespaceprefix_ = self.vBCUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.vBCUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCUFFim>%s</%svBCUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCUFFim), input_name='vBCUFFim')), namespaceprefix_ , eol_))
        if self.pFCPUFFim is not None:
            namespaceprefix_ = self.pFCPUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.pFCPUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPUFFim>%s</%spFCPUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPUFFim), input_name='pFCPUFFim')), namespaceprefix_ , eol_))
        if self.pICMSUFFim is not None:
            namespaceprefix_ = self.pICMSUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMSUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSUFFim>%s</%spICMSUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSUFFim), input_name='pICMSUFFim')), namespaceprefix_ , eol_))
        if self.pICMSInter is not None:
            namespaceprefix_ = self.pICMSInter_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMSInter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSInter>%s</%spICMSInter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSInter), input_name='pICMSInter')), namespaceprefix_ , eol_))
        if self.vFCPUFFim is not None:
            namespaceprefix_ = self.vFCPUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.vFCPUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPUFFim>%s</%svFCPUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPUFFim), input_name='vFCPUFFim')), namespaceprefix_ , eol_))
        if self.vICMSUFFim is not None:
            namespaceprefix_ = self.vICMSUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMSUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFFim>%s</%svICMSUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFFim), input_name='vICMSUFFim')), namespaceprefix_ , eol_))
        if self.vICMSUFIni is not None:
            namespaceprefix_ = self.vICMSUFIni_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMSUFIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFIni>%s</%svICMSUFIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFIni), input_name='vICMSUFIni')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vBCUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBCUFFim')
            value_ = self.gds_validate_string(value_, node, 'vBCUFFim')
            self.vBCUFFim = value_
            self.vBCUFFim_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCUFFim)
        elif nodeName_ == 'pFCPUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pFCPUFFim')
            value_ = self.gds_validate_string(value_, node, 'pFCPUFFim')
            self.pFCPUFFim = value_
            self.pFCPUFFim_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pFCPUFFim)
        elif nodeName_ == 'pICMSUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMSUFFim')
            value_ = self.gds_validate_string(value_, node, 'pICMSUFFim')
            self.pICMSUFFim = value_
            self.pICMSUFFim_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMSUFFim)
        elif nodeName_ == 'pICMSInter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMSInter')
            value_ = self.gds_validate_string(value_, node, 'pICMSInter')
            self.pICMSInter = value_
            self.pICMSInter_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMSInter)
        elif nodeName_ == 'vFCPUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vFCPUFFim')
            value_ = self.gds_validate_string(value_, node, 'vFCPUFFim')
            self.vFCPUFFim = value_
            self.vFCPUFFim_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPUFFim)
        elif nodeName_ == 'vICMSUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMSUFFim')
            value_ = self.gds_validate_string(value_, node, 'vICMSUFFim')
            self.vICMSUFFim = value_
            self.vICMSUFFim_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFFim)
        elif nodeName_ == 'vICMSUFIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMSUFIni')
            value_ = self.gds_validate_string(value_, node, 'vICMSUFIni')
            self.vICMSUFIni = value_
            self.vICMSUFIni_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFIni)
# end class ICMSUFFimType


class infCTeNormType(GeneratedsSuper):
    """infCTeNormType -- Grupo de informa
    ç
    õ
    es do CT-e Normal e Substituto
    infCarga -- Informa
    ç
    õ
    es da Carga do CT-e
    infDoc -- Informa
    ç
    õ
    es dos documentos transportados pelo CT-e
    Opcional para Redespacho Intermediario e Servi
    ç
    o vinculado a multimodal.
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    docAnt -- Documentos de Transporte Anterior
    infModal -- Informa
    ç
    õ
    es do modal
    veicNovos -- informa
    ç
    õ
    es dos ve
    í
    culos transportados
    cobr -- Dados da cobran
    ç
    a do CT-e
    infCteSub -- Informa
    ç
    õ
    es do CT-e de substitui
    ç
    ã
    o
    infGlobalizado -- Informa
    ç
    õ
    es do CT-e Globalizado
    infServVinc -- Informa
    ç
    õ
    es do Servi
    ç
    o Vinculado a Multimodal
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, infCarga=None, infDoc=None, docAnt=None, infModal=None, veicNovos=None, cobr=None, infCteSub=None, infGlobalizado=None, infServVinc=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.infCarga = infCarga
        self.infCarga_nsprefix_ = None
        self.infDoc = infDoc
        self.infDoc_nsprefix_ = None
        self.docAnt = docAnt
        self.docAnt_nsprefix_ = None
        self.infModal = infModal
        self.infModal_nsprefix_ = None
        if veicNovos is None:
            self.veicNovos = []
        else:
            self.veicNovos = veicNovos
        self.veicNovos_nsprefix_ = None
        self.cobr = cobr
        self.cobr_nsprefix_ = None
        self.infCteSub = infCteSub
        self.infCteSub_nsprefix_ = None
        self.infGlobalizado = infGlobalizado
        self.infGlobalizado_nsprefix_ = None
        self.infServVinc = infServVinc
        self.infServVinc_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeNormType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeNormType.subclass:
            return infCTeNormType.subclass(*args_, **kwargs_)
        else:
            return infCTeNormType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infCarga(self):
        return self.infCarga
    def set_infCarga(self, infCarga):
        self.infCarga = infCarga
    def get_infDoc(self):
        return self.infDoc
    def set_infDoc(self, infDoc):
        self.infDoc = infDoc
    def get_docAnt(self):
        return self.docAnt
    def set_docAnt(self, docAnt):
        self.docAnt = docAnt
    def get_infModal(self):
        return self.infModal
    def set_infModal(self, infModal):
        self.infModal = infModal
    def get_veicNovos(self):
        return self.veicNovos
    def set_veicNovos(self, veicNovos):
        self.veicNovos = veicNovos
    def add_veicNovos(self, value):
        self.veicNovos.append(value)
    def insert_veicNovos_at(self, index, value):
        self.veicNovos.insert(index, value)
    def replace_veicNovos_at(self, index, value):
        self.veicNovos[index] = value
    def get_cobr(self):
        return self.cobr
    def set_cobr(self, cobr):
        self.cobr = cobr
    def get_infCteSub(self):
        return self.infCteSub
    def set_infCteSub(self, infCteSub):
        self.infCteSub = infCteSub
    def get_infGlobalizado(self):
        return self.infGlobalizado
    def set_infGlobalizado(self, infGlobalizado):
        self.infGlobalizado = infGlobalizado
    def get_infServVinc(self):
        return self.infServVinc
    def set_infServVinc(self, infServVinc):
        self.infServVinc = infServVinc
    def _hasContent(self):
        if (
            self.infCarga is not None or
            self.infDoc is not None or
            self.docAnt is not None or
            self.infModal is not None or
            self.veicNovos or
            self.cobr is not None or
            self.infCteSub is not None or
            self.infGlobalizado is not None or
            self.infServVinc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeNormType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeNormType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCTeNormType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCTeNormType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCTeNormType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCTeNormType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeNormType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infCarga is not None:
            namespaceprefix_ = self.infCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.infCarga_nsprefix_) else ''
            self.infCarga.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCarga', pretty_print=pretty_print)
        if self.infDoc is not None:
            namespaceprefix_ = self.infDoc_nsprefix_ + ':' if (UseCapturedNS_ and self.infDoc_nsprefix_) else ''
            self.infDoc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infDoc', pretty_print=pretty_print)
        if self.docAnt is not None:
            namespaceprefix_ = self.docAnt_nsprefix_ + ':' if (UseCapturedNS_ and self.docAnt_nsprefix_) else ''
            self.docAnt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='docAnt', pretty_print=pretty_print)
        if self.infModal is not None:
            namespaceprefix_ = self.infModal_nsprefix_ + ':' if (UseCapturedNS_ and self.infModal_nsprefix_) else ''
            self.infModal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infModal', pretty_print=pretty_print)
        for veicNovos_ in self.veicNovos:
            namespaceprefix_ = self.veicNovos_nsprefix_ + ':' if (UseCapturedNS_ and self.veicNovos_nsprefix_) else ''
            veicNovos_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='veicNovos', pretty_print=pretty_print)
        if self.cobr is not None:
            namespaceprefix_ = self.cobr_nsprefix_ + ':' if (UseCapturedNS_ and self.cobr_nsprefix_) else ''
            self.cobr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cobr', pretty_print=pretty_print)
        if self.infCteSub is not None:
            namespaceprefix_ = self.infCteSub_nsprefix_ + ':' if (UseCapturedNS_ and self.infCteSub_nsprefix_) else ''
            self.infCteSub.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCteSub', pretty_print=pretty_print)
        if self.infGlobalizado is not None:
            namespaceprefix_ = self.infGlobalizado_nsprefix_ + ':' if (UseCapturedNS_ and self.infGlobalizado_nsprefix_) else ''
            self.infGlobalizado.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infGlobalizado', pretty_print=pretty_print)
        if self.infServVinc is not None:
            namespaceprefix_ = self.infServVinc_nsprefix_ + ':' if (UseCapturedNS_ and self.infServVinc_nsprefix_) else ''
            self.infServVinc.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infServVinc', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infCarga':
            obj_ = infCargaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCarga = obj_
            obj_.original_tagname_ = 'infCarga'
        elif nodeName_ == 'infDoc':
            obj_ = infDocType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infDoc = obj_
            obj_.original_tagname_ = 'infDoc'
        elif nodeName_ == 'docAnt':
            obj_ = docAntType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.docAnt = obj_
            obj_.original_tagname_ = 'docAnt'
        elif nodeName_ == 'infModal':
            obj_ = infModalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infModal = obj_
            obj_.original_tagname_ = 'infModal'
        elif nodeName_ == 'veicNovos':
            obj_ = veicNovosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.veicNovos.append(obj_)
            obj_.original_tagname_ = 'veicNovos'
        elif nodeName_ == 'cobr':
            obj_ = cobrType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cobr = obj_
            obj_.original_tagname_ = 'cobr'
        elif nodeName_ == 'infCteSub':
            obj_ = infCteSubType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCteSub = obj_
            obj_.original_tagname_ = 'infCteSub'
        elif nodeName_ == 'infGlobalizado':
            obj_ = infGlobalizadoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infGlobalizado = obj_
            obj_.original_tagname_ = 'infGlobalizado'
        elif nodeName_ == 'infServVinc':
            obj_ = infServVincType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infServVinc = obj_
            obj_.original_tagname_ = 'infServVinc'
# end class infCTeNormType


class infCargaType(GeneratedsSuper):
    """infCargaType -- Informa
    ç
    õ
    es da Carga do CT-e
    vCarga -- Valor total da carga
    Dever ser informado para todos os modais, com exce
    ç
    ã
    o para o Dutovi
    á
    rio.
    proPred -- Produto predominante
    Informar a descri
    ç
    ã
    o do produto predominante
    xOutCat -- Outras caracter
    í
    sticas da carga
    "FRIA", "GRANEL", "REFRIGERADA", "Medidas: 12X12X12"
    infQ -- Informa
    ç
    õ
    es de quantidades da Carga do CT-e
    Para o A
    é
    reo
    é
    obrigat
    ó
    rio o preenchimento desse campo da seguinte forma.
    1 - Peso Bruto, sempre em quilogramas (obrigat
    ó
    rio);
    2 - Peso Cubado; sempre em quilogramas;
    3 - Quantidade de volumes, sempre em unidades (obrigat
    ó
    rio);
    4 - Cubagem, sempre em metros c
    ú
    bicos (obrigat
    ó
    rio apenas quando for imposs
    í
    vel preencher as dimens
    õ
    es da(s) embalagem(ens) na tag xDime do leiaute do A
    é
    reo).
    vCargaAverb -- Valor da Carga para efeito de averba
    ç
    ã
    o
    Normalmente igual ao valor declarado da mercadoria, diferente por exemplo, quando a mercadoria transportada
    é
    isenta de tributos nacionais para exporta
    ç
    ã
    o, onde
    é
    preciso averbar um valor maior, pois no caso de indeniza
    ç
    ã
    o, o valor a ser pago ser
    á
    maior
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vCarga=None, proPred=None, xOutCat=None, infQ=None, vCargaAverb=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vCarga = vCarga
        self.validate_TDec_1302(self.vCarga)
        self.vCarga_nsprefix_ = None
        self.proPred = proPred
        self.validate_proPredType(self.proPred)
        self.proPred_nsprefix_ = None
        self.xOutCat = xOutCat
        self.validate_xOutCatType(self.xOutCat)
        self.xOutCat_nsprefix_ = None
        if infQ is None:
            self.infQ = []
        else:
            self.infQ = infQ
        self.infQ_nsprefix_ = None
        self.vCargaAverb = vCargaAverb
        self.validate_TDec_1302Opc(self.vCargaAverb)
        self.vCargaAverb_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCargaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCargaType.subclass:
            return infCargaType.subclass(*args_, **kwargs_)
        else:
            return infCargaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vCarga(self):
        return self.vCarga
    def set_vCarga(self, vCarga):
        self.vCarga = vCarga
    def get_proPred(self):
        return self.proPred
    def set_proPred(self, proPred):
        self.proPred = proPred
    def get_xOutCat(self):
        return self.xOutCat
    def set_xOutCat(self, xOutCat):
        self.xOutCat = xOutCat
    def get_infQ(self):
        return self.infQ
    def set_infQ(self, infQ):
        self.infQ = infQ
    def add_infQ(self, value):
        self.infQ.append(value)
    def insert_infQ_at(self, index, value):
        self.infQ.insert(index, value)
    def replace_infQ_at(self, index, value):
        self.infQ[index] = value
    def get_vCargaAverb(self):
        return self.vCargaAverb
    def set_vCargaAverb(self, vCargaAverb):
        self.vCargaAverb = vCargaAverb
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_proPredType(self, value):
        result = True
        # Validate type proPredType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on proPredType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on proPredType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_proPredType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_proPredType_patterns_, ))
                result = False
        return result
    validate_proPredType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xOutCatType(self, value):
        result = True
        # Validate type xOutCatType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xOutCatType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xOutCatType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xOutCatType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xOutCatType_patterns_, ))
                result = False
        return result
    validate_xOutCatType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TDec_1302Opc(self, value):
        result = True
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_1302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.vCarga is not None or
            self.proPred is not None or
            self.xOutCat is not None or
            self.infQ or
            self.vCargaAverb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCargaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCargaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCargaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCargaType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCargaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCargaType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCargaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vCarga is not None:
            namespaceprefix_ = self.vCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.vCarga_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCarga>%s</%svCarga>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCarga), input_name='vCarga')), namespaceprefix_ , eol_))
        if self.proPred is not None:
            namespaceprefix_ = self.proPred_nsprefix_ + ':' if (UseCapturedNS_ and self.proPred_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproPred>%s</%sproPred>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.proPred), input_name='proPred')), namespaceprefix_ , eol_))
        if self.xOutCat is not None:
            namespaceprefix_ = self.xOutCat_nsprefix_ + ':' if (UseCapturedNS_ and self.xOutCat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxOutCat>%s</%sxOutCat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xOutCat), input_name='xOutCat')), namespaceprefix_ , eol_))
        for infQ_ in self.infQ:
            namespaceprefix_ = self.infQ_nsprefix_ + ':' if (UseCapturedNS_ and self.infQ_nsprefix_) else ''
            infQ_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infQ', pretty_print=pretty_print)
        if self.vCargaAverb is not None:
            namespaceprefix_ = self.vCargaAverb_nsprefix_ + ':' if (UseCapturedNS_ and self.vCargaAverb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCargaAverb>%s</%svCargaAverb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCargaAverb), input_name='vCargaAverb')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vCarga':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vCarga')
            value_ = self.gds_validate_string(value_, node, 'vCarga')
            self.vCarga = value_
            self.vCarga_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCarga)
        elif nodeName_ == 'proPred':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'proPred')
            value_ = self.gds_validate_string(value_, node, 'proPred')
            self.proPred = value_
            self.proPred_nsprefix_ = child_.prefix
            # validate type proPredType
            self.validate_proPredType(self.proPred)
        elif nodeName_ == 'xOutCat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xOutCat')
            value_ = self.gds_validate_string(value_, node, 'xOutCat')
            self.xOutCat = value_
            self.xOutCat_nsprefix_ = child_.prefix
            # validate type xOutCatType
            self.validate_xOutCatType(self.xOutCat)
        elif nodeName_ == 'infQ':
            obj_ = infQType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infQ.append(obj_)
            obj_.original_tagname_ = 'infQ'
        elif nodeName_ == 'vCargaAverb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vCargaAverb')
            value_ = self.gds_validate_string(value_, node, 'vCargaAverb')
            self.vCargaAverb = value_
            self.vCargaAverb_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vCargaAverb)
# end class infCargaType


class infQType(GeneratedsSuper):
    """infQType -- Informa
    ç
    õ
    es de quantidades da Carga do CT-e
    Para o A
    é
    reo
    é
    obrigat
    ó
    rio o preenchimento desse campo da seguinte forma.
    1 - Peso Bruto, sempre em quilogramas (obrigat
    ó
    rio);
    2 - Peso Cubado; sempre em quilogramas;
    3 - Quantidade de volumes, sempre em unidades (obrigat
    ó
    rio);
    4 - Cubagem, sempre em metros c
    ú
    bicos (obrigat
    ó
    rio apenas quando for imposs
    í
    vel preencher as dimens
    õ
    es da(s) embalagem(ens) na tag xDime do leiaute do A
    é
    reo).
    cUnid -- C
    ó
    digo da Unidade de Medida
    Preencher com:
    00-M3;
    01-KG;
    02-TON;
    03-UNIDADE;
    04-LITROS;
    05-MMBTU
    tpMed -- Tipo da Medida
    Exemplos:
    PESO BRUTO, PESO DECLARADO, PESO CUBADO, PESO AFORADO, PESO AFERIDO, PESO BASE DE C
    Á
    LCULO, LITRAGEM, CAIXAS e etc
    qCarga -- Quantidade
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cUnid=None, tpMed=None, qCarga=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cUnid = cUnid
        self.validate_cUnidType(self.cUnid)
        self.cUnid_nsprefix_ = None
        self.tpMed = tpMed
        self.validate_tpMedType(self.tpMed)
        self.tpMed_nsprefix_ = None
        self.qCarga = qCarga
        self.validate_TDec_1104(self.qCarga)
        self.qCarga_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infQType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infQType.subclass:
            return infQType.subclass(*args_, **kwargs_)
        else:
            return infQType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cUnid(self):
        return self.cUnid
    def set_cUnid(self, cUnid):
        self.cUnid = cUnid
    def get_tpMed(self):
        return self.tpMed
    def set_tpMed(self, tpMed):
        self.tpMed = tpMed
    def get_qCarga(self):
        return self.qCarga
    def set_qCarga(self, qCarga):
        self.qCarga = qCarga
    def validate_cUnidType(self, value):
        result = True
        # Validate type cUnidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['00', '01', '02', '03', '04', '05']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on cUnidType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tpMedType(self, value):
        result = True
        # Validate type tpMedType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on tpMedType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on tpMedType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_tpMedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_tpMedType_patterns_, ))
                result = False
        return result
    validate_tpMedType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TDec_1104(self, value):
        result = True
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1104_patterns_, ))
                result = False
        return result
    validate_TDec_1104_patterns_ = [['^(0|0\\.[0-9]{4}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?)$']]
    def _hasContent(self):
        if (
            self.cUnid is not None or
            self.tpMed is not None or
            self.qCarga is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infQType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infQType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infQType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infQType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infQType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infQType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infQType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUnid is not None:
            namespaceprefix_ = self.cUnid_nsprefix_ + ':' if (UseCapturedNS_ and self.cUnid_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUnid>%s</%scUnid>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUnid), input_name='cUnid')), namespaceprefix_ , eol_))
        if self.tpMed is not None:
            namespaceprefix_ = self.tpMed_nsprefix_ + ':' if (UseCapturedNS_ and self.tpMed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpMed>%s</%stpMed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpMed), input_name='tpMed')), namespaceprefix_ , eol_))
        if self.qCarga is not None:
            namespaceprefix_ = self.qCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.qCarga_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqCarga>%s</%sqCarga>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qCarga), input_name='qCarga')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cUnid':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cUnid')
            value_ = self.gds_validate_string(value_, node, 'cUnid')
            self.cUnid = value_
            self.cUnid_nsprefix_ = child_.prefix
            # validate type cUnidType
            self.validate_cUnidType(self.cUnid)
        elif nodeName_ == 'tpMed':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpMed')
            value_ = self.gds_validate_string(value_, node, 'tpMed')
            self.tpMed = value_
            self.tpMed_nsprefix_ = child_.prefix
            # validate type tpMedType
            self.validate_tpMedType(self.tpMed)
        elif nodeName_ == 'qCarga':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qCarga')
            value_ = self.gds_validate_string(value_, node, 'qCarga')
            self.qCarga = value_
            self.qCarga_nsprefix_ = child_.prefix
            # validate type TDec_1104
            self.validate_TDec_1104(self.qCarga)
# end class infQType


class infDocType(GeneratedsSuper):
    """infDocType -- Informa
    ç
    õ
    es dos documentos transportados pelo CT-e
    Opcional para Redespacho Intermediario e Servi
    ç
    o vinculado a multimodal.
    Poder
    á
    n
    ã
    o ser informado para os CT-e de redespacho intermedi
    á
    rio e servi
    ç
    o vinculado a multimodal. Nos demais casos dever
    á
    sempre ser informado.
    infNF -- Informa
    ç
    õ
    es das NF
    Este grupo deve ser informado quando o documento origin
    á
    rio for NF
    infNFe -- Informa
    ç
    õ
    es das NF-e
    infOutros -- Informa
    ç
    õ
    es dos demais documentos
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, infNF=None, infNFe=None, infOutros=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if infNF is None:
            self.infNF = []
        else:
            self.infNF = infNF
        self.infNF_nsprefix_ = None
        if infNFe is None:
            self.infNFe = []
        else:
            self.infNFe = infNFe
        self.infNFe_nsprefix_ = None
        if infOutros is None:
            self.infOutros = []
        else:
            self.infOutros = infOutros
        self.infOutros_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infDocType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infDocType.subclass:
            return infDocType.subclass(*args_, **kwargs_)
        else:
            return infDocType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infNF(self):
        return self.infNF
    def set_infNF(self, infNF):
        self.infNF = infNF
    def add_infNF(self, value):
        self.infNF.append(value)
    def insert_infNF_at(self, index, value):
        self.infNF.insert(index, value)
    def replace_infNF_at(self, index, value):
        self.infNF[index] = value
    def get_infNFe(self):
        return self.infNFe
    def set_infNFe(self, infNFe):
        self.infNFe = infNFe
    def add_infNFe(self, value):
        self.infNFe.append(value)
    def insert_infNFe_at(self, index, value):
        self.infNFe.insert(index, value)
    def replace_infNFe_at(self, index, value):
        self.infNFe[index] = value
    def get_infOutros(self):
        return self.infOutros
    def set_infOutros(self, infOutros):
        self.infOutros = infOutros
    def add_infOutros(self, value):
        self.infOutros.append(value)
    def insert_infOutros_at(self, index, value):
        self.infOutros.insert(index, value)
    def replace_infOutros_at(self, index, value):
        self.infOutros[index] = value
    def _hasContent(self):
        if (
            self.infNF or
            self.infNFe or
            self.infOutros
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infDocType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infDocType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infDocType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infDocType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infDocType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infDocType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infDocType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for infNF_ in self.infNF:
            namespaceprefix_ = self.infNF_nsprefix_ + ':' if (UseCapturedNS_ and self.infNF_nsprefix_) else ''
            infNF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infNF', pretty_print=pretty_print)
        for infNFe_ in self.infNFe:
            namespaceprefix_ = self.infNFe_nsprefix_ + ':' if (UseCapturedNS_ and self.infNFe_nsprefix_) else ''
            infNFe_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infNFe', pretty_print=pretty_print)
        for infOutros_ in self.infOutros:
            namespaceprefix_ = self.infOutros_nsprefix_ + ':' if (UseCapturedNS_ and self.infOutros_nsprefix_) else ''
            infOutros_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infOutros', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infNF':
            obj_ = infNFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infNF.append(obj_)
            obj_.original_tagname_ = 'infNF'
        elif nodeName_ == 'infNFe':
            obj_ = infNFeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infNFe.append(obj_)
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infOutros':
            obj_ = infOutrosType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infOutros.append(obj_)
            obj_.original_tagname_ = 'infOutros'
# end class infDocType


class infNFType(GeneratedsSuper):
    """infNFType -- Informa
    ç
    õ
    es das NF
    Este grupo deve ser informado quando o documento origin
    á
    rio for NF
    nRoma -- N
    ú
    mero do Romaneio da NF
    nPed -- N
    ú
    mero do Pedido da NF
    mod -- Modelo da Nota Fiscal
    Preencher com:
    01 - NF Modelo 01/1A e Avulsa;
    04 - NF de Produtor
    serie -- S
    é
    rie
    nDoc -- N
    ú
    mero
    dEmi -- Data de Emiss
    ã
    o
    Formato AAAA-MM-DD
    vBC -- Valor da Base de C
    á
    lculo do ICMS
    vICMS -- Valor Total do ICMS
    vBCST -- Valor da Base de C
    á
    lculo do ICMS ST
    vST -- Valor Total do ICMS ST
    vProd -- Valor Total dos Produtos
    vNF -- Valor Total da NF
    nCFOP -- CFOP Predominante
    CFOP da NF ou, na exist
    ê
    ncia de mais de um, predomin
    â
    ncia pelo crit
    é
    rio de valor econ
    ô
    mico.
    nPeso -- Peso total em Kg
    PIN -- PIN SUFRAMA
    PIN atribu
    í
    do pela SUFRAMA para a opera
    ç
    ã
    o.
    dPrev -- Data prevista de entrega
    Formato AAAA-MM-DD
    infUnidCarga -- Informa
    ç
    õ
    es das Unidades de Carga (Containeres/ULD/Outros)
    Dispositivo de carga utilizada (Unit Load Device - ULD) significa todo tipo de cont
    ê
    iner de carga, vag
    ã
    o, cont
    ê
    iner de avi
    ã
    o, palete de aeronave com rede ou palete de aeronave com rede sobre um iglu.
    infUnidTransp -- Informa
    ç
    õ
    es das Unidades de Transporte (Carreta/Reboque/Vag
    ã
    o)
    Deve ser preenchido com as informa
    ç
    õ
    es das unidades de transporte utilizadas.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nRoma=None, nPed=None, mod=None, serie=None, nDoc=None, dEmi=None, vBC=None, vICMS=None, vBCST=None, vST=None, vProd=None, vNF=None, nCFOP=None, nPeso=None, PIN=None, dPrev=None, infUnidCarga=None, infUnidTransp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nRoma = nRoma
        self.validate_nRomaType(self.nRoma)
        self.nRoma_nsprefix_ = None
        self.nPed = nPed
        self.validate_nPedType(self.nPed)
        self.nPed_nsprefix_ = None
        self.mod = mod
        self.validate_TModNF(self.mod)
        self.mod_nsprefix_ = None
        self.serie = serie
        self.validate_serieType78(self.serie)
        self.serie_nsprefix_ = None
        self.nDoc = nDoc
        self.validate_nDocType(self.nDoc)
        self.nDoc_nsprefix_ = None
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.dEmi_nsprefix_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vBC_nsprefix_ = None
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMS_nsprefix_ = None
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.vBCST_nsprefix_ = None
        self.vST = vST
        self.validate_TDec_1302(self.vST)
        self.vST_nsprefix_ = None
        self.vProd = vProd
        self.validate_TDec_1302(self.vProd)
        self.vProd_nsprefix_ = None
        self.vNF = vNF
        self.validate_TDec_1302(self.vNF)
        self.vNF_nsprefix_ = None
        self.nCFOP = nCFOP
        self.validate_TCfop(self.nCFOP)
        self.nCFOP_nsprefix_ = None
        self.nPeso = nPeso
        self.validate_TDec_1203Opc(self.nPeso)
        self.nPeso_nsprefix_ = None
        self.PIN = PIN
        self.validate_PINType(self.PIN)
        self.PIN_nsprefix_ = None
        self.dPrev = dPrev
        self.validate_TData(self.dPrev)
        self.dPrev_nsprefix_ = None
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        self.infUnidCarga_nsprefix_ = None
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        self.infUnidTransp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFType.subclass:
            return infNFType.subclass(*args_, **kwargs_)
        else:
            return infNFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nRoma(self):
        return self.nRoma
    def set_nRoma(self, nRoma):
        self.nRoma = nRoma
    def get_nPed(self):
        return self.nPed
    def set_nPed(self, nPed):
        self.nPed = nPed
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_nDoc(self):
        return self.nDoc
    def set_nDoc(self, nDoc):
        self.nDoc = nDoc
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_vST(self):
        return self.vST
    def set_vST(self, vST):
        self.vST = vST
    def get_vProd(self):
        return self.vProd
    def set_vProd(self, vProd):
        self.vProd = vProd
    def get_vNF(self):
        return self.vNF
    def set_vNF(self, vNF):
        self.vNF = vNF
    def get_nCFOP(self):
        return self.nCFOP
    def set_nCFOP(self, nCFOP):
        self.nCFOP = nCFOP
    def get_nPeso(self):
        return self.nPeso
    def set_nPeso(self, nPeso):
        self.nPeso = nPeso
    def get_PIN(self):
        return self.PIN
    def set_PIN(self, PIN):
        self.PIN = PIN
    def get_dPrev(self):
        return self.dPrev
    def set_dPrev(self, dPrev):
        self.dPrev = dPrev
    def get_infUnidCarga(self):
        return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga):
        self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value):
        self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value):
        self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value):
        self.infUnidCarga[index] = value
    def get_infUnidTransp(self):
        return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp):
        self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value):
        self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value):
        self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value):
        self.infUnidTransp[index] = value
    def validate_nRomaType(self, value):
        result = True
        # Validate type nRomaType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nRomaType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nRomaType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nRomaType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nRomaType_patterns_, ))
                result = False
        return result
    validate_nRomaType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nPedType(self, value):
        result = True
        # Validate type nPedType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nPedType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nPedType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nPedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nPedType_patterns_, ))
                result = False
        return result
    validate_nPedType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TModNF(self, value):
        result = True
        # Validate type TModNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['01', '04']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TModNF' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_serieType78(self, value):
        result = True
        # Validate type serieType78, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on serieType78' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on serieType78' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_serieType78_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_serieType78_patterns_, ))
                result = False
        return result
    validate_serieType78_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nDocType(self, value):
        result = True
        # Validate type nDocType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nDocType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nDocType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nDocType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nDocType_patterns_, ))
                result = False
        return result
    validate_nDocType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TCfop(self, value):
        result = True
        # Validate type TCfop, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCfop_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCfop_patterns_, ))
                result = False
        return result
    validate_TCfop_patterns_ = [['^([123567][0-9]([0-9][1-9]|[1-9][0-9]))$']]
    def validate_TDec_1203Opc(self, value):
        result = True
        # Validate type TDec_1203Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1203Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1203Opc_patterns_, ))
                result = False
        return result
    validate_TDec_1203Opc_patterns_ = [['^(0\\.[1-9]{1}[0-9]{2}|0\\.[0-9]{2}[1-9]{1}|0\\.[0-9]{1}[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{3})?)$']]
    def validate_PINType(self, value):
        result = True
        # Validate type PINType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PINType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PINType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_PINType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PINType_patterns_, ))
                result = False
        return result
    validate_PINType_patterns_ = [['^([1-9]{1}[0-9]{1,8})$']]
    def _hasContent(self):
        if (
            self.nRoma is not None or
            self.nPed is not None or
            self.mod is not None or
            self.serie is not None or
            self.nDoc is not None or
            self.dEmi is not None or
            self.vBC is not None or
            self.vICMS is not None or
            self.vBCST is not None or
            self.vST is not None or
            self.vProd is not None or
            self.vNF is not None or
            self.nCFOP is not None or
            self.nPeso is not None or
            self.PIN is not None or
            self.dPrev is not None or
            self.infUnidCarga or
            self.infUnidTransp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infNFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infNFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infNFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infNFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infNFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infNFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRoma is not None:
            namespaceprefix_ = self.nRoma_nsprefix_ + ':' if (UseCapturedNS_ and self.nRoma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRoma>%s</%snRoma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nRoma), input_name='nRoma')), namespaceprefix_ , eol_))
        if self.nPed is not None:
            namespaceprefix_ = self.nPed_nsprefix_ + ':' if (UseCapturedNS_ and self.nPed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snPed>%s</%snPed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nPed), input_name='nPed')), namespaceprefix_ , eol_))
        if self.mod is not None:
            namespaceprefix_ = self.mod_nsprefix_ + ':' if (UseCapturedNS_ and self.mod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            namespaceprefix_ = self.serie_nsprefix_ + ':' if (UseCapturedNS_ and self.serie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.nDoc is not None:
            namespaceprefix_ = self.nDoc_nsprefix_ + ':' if (UseCapturedNS_ and self.nDoc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDoc>%s</%snDoc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDoc), input_name='nDoc')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            namespaceprefix_ = self.dEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            namespaceprefix_ = self.vBC_nsprefix_ + ':' if (UseCapturedNS_ and self.vBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            namespaceprefix_ = self.vICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            namespaceprefix_ = self.vBCST_nsprefix_ + ':' if (UseCapturedNS_ and self.vBCST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.vST is not None:
            namespaceprefix_ = self.vST_nsprefix_ + ':' if (UseCapturedNS_ and self.vST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svST>%s</%svST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vST), input_name='vST')), namespaceprefix_ , eol_))
        if self.vProd is not None:
            namespaceprefix_ = self.vProd_nsprefix_ + ':' if (UseCapturedNS_ and self.vProd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svProd>%s</%svProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vProd), input_name='vProd')), namespaceprefix_ , eol_))
        if self.vNF is not None:
            namespaceprefix_ = self.vNF_nsprefix_ + ':' if (UseCapturedNS_ and self.vNF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svNF>%s</%svNF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vNF), input_name='vNF')), namespaceprefix_ , eol_))
        if self.nCFOP is not None:
            namespaceprefix_ = self.nCFOP_nsprefix_ + ':' if (UseCapturedNS_ and self.nCFOP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snCFOP>%s</%snCFOP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nCFOP), input_name='nCFOP')), namespaceprefix_ , eol_))
        if self.nPeso is not None:
            namespaceprefix_ = self.nPeso_nsprefix_ + ':' if (UseCapturedNS_ and self.nPeso_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snPeso>%s</%snPeso>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nPeso), input_name='nPeso')), namespaceprefix_ , eol_))
        if self.PIN is not None:
            namespaceprefix_ = self.PIN_nsprefix_ + ':' if (UseCapturedNS_ and self.PIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPIN>%s</%sPIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PIN), input_name='PIN')), namespaceprefix_ , eol_))
        if self.dPrev is not None:
            namespaceprefix_ = self.dPrev_nsprefix_ + ':' if (UseCapturedNS_ and self.dPrev_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdPrev>%s</%sdPrev>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dPrev), input_name='dPrev')), namespaceprefix_ , eol_))
        for infUnidCarga_ in self.infUnidCarga:
            namespaceprefix_ = self.infUnidCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.infUnidCarga_nsprefix_) else ''
            infUnidCarga_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infUnidCarga', pretty_print=pretty_print)
        for infUnidTransp_ in self.infUnidTransp:
            namespaceprefix_ = self.infUnidTransp_nsprefix_ + ':' if (UseCapturedNS_ and self.infUnidTransp_nsprefix_) else ''
            infUnidTransp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infUnidTransp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nRoma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nRoma')
            value_ = self.gds_validate_string(value_, node, 'nRoma')
            self.nRoma = value_
            self.nRoma_nsprefix_ = child_.prefix
            # validate type nRomaType
            self.validate_nRomaType(self.nRoma)
        elif nodeName_ == 'nPed':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nPed')
            value_ = self.gds_validate_string(value_, node, 'nPed')
            self.nPed = value_
            self.nPed_nsprefix_ = child_.prefix
            # validate type nPedType
            self.validate_nPedType(self.nPed)
        elif nodeName_ == 'mod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mod')
            value_ = self.gds_validate_string(value_, node, 'mod')
            self.mod = value_
            self.mod_nsprefix_ = child_.prefix
            # validate type TModNF
            self.validate_TModNF(self.mod)
        elif nodeName_ == 'serie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serie')
            value_ = self.gds_validate_string(value_, node, 'serie')
            self.serie = value_
            self.serie_nsprefix_ = child_.prefix
            # validate type serieType78
            self.validate_serieType78(self.serie)
        elif nodeName_ == 'nDoc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nDoc')
            value_ = self.gds_validate_string(value_, node, 'nDoc')
            self.nDoc = value_
            self.nDoc_nsprefix_ = child_.prefix
            # validate type nDocType
            self.validate_nDocType(self.nDoc)
        elif nodeName_ == 'dEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dEmi')
            value_ = self.gds_validate_string(value_, node, 'dEmi')
            self.dEmi = value_
            self.dEmi_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dEmi)
        elif nodeName_ == 'vBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBC')
            value_ = self.gds_validate_string(value_, node, 'vBC')
            self.vBC = value_
            self.vBC_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMS')
            value_ = self.gds_validate_string(value_, node, 'vICMS')
            self.vICMS = value_
            self.vICMS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBCST')
            value_ = self.gds_validate_string(value_, node, 'vBCST')
            self.vBCST = value_
            self.vBCST_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'vST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vST')
            value_ = self.gds_validate_string(value_, node, 'vST')
            self.vST = value_
            self.vST_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vST)
        elif nodeName_ == 'vProd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vProd')
            value_ = self.gds_validate_string(value_, node, 'vProd')
            self.vProd = value_
            self.vProd_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vProd)
        elif nodeName_ == 'vNF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vNF')
            value_ = self.gds_validate_string(value_, node, 'vNF')
            self.vNF = value_
            self.vNF_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vNF)
        elif nodeName_ == 'nCFOP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nCFOP')
            value_ = self.gds_validate_string(value_, node, 'nCFOP')
            self.nCFOP = value_
            self.nCFOP_nsprefix_ = child_.prefix
            # validate type TCfop
            self.validate_TCfop(self.nCFOP)
        elif nodeName_ == 'nPeso':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nPeso')
            value_ = self.gds_validate_string(value_, node, 'nPeso')
            self.nPeso = value_
            self.nPeso_nsprefix_ = child_.prefix
            # validate type TDec_1203Opc
            self.validate_TDec_1203Opc(self.nPeso)
        elif nodeName_ == 'PIN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PIN')
            value_ = self.gds_validate_string(value_, node, 'PIN')
            self.PIN = value_
            self.PIN_nsprefix_ = child_.prefix
            # validate type PINType
            self.validate_PINType(self.PIN)
        elif nodeName_ == 'dPrev':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dPrev')
            value_ = self.gds_validate_string(value_, node, 'dPrev')
            self.dPrev = value_
            self.dPrev_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dPrev)
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
# end class infNFType


class infNFeType(GeneratedsSuper):
    """infNFeType -- Informa
    ç
    õ
    es das NF-e
    chave -- Chave de acesso da NF-e
    PIN -- PIN SUFRAMA
    PIN atribu
    í
    do pela SUFRAMA para a opera
    ç
    ã
    o.
    dPrev -- Data prevista de entrega
    Formato AAAA-MM-DD
    infUnidCarga -- Informa
    ç
    õ
    es das Unidades de Carga (Containeres/ULD/Outros)
    Dispositivo de carga utilizada (Unit Load Device - ULD) significa todo tipo de cont
    ê
    iner de carga, vag
    ã
    o, cont
    ê
    iner de avi
    ã
    o, palete de aeronave com rede ou palete de aeronave com rede sobre um iglu.
    infUnidTransp -- Informa
    ç
    õ
    es das Unidades de Transporte (Carreta/Reboque/Vag
    ã
    o)
    Deve ser preenchido com as informa
    ç
    õ
    es das unidades de transporte utilizadas.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chave=None, PIN=None, dPrev=None, infUnidCarga=None, infUnidTransp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chave = chave
        self.validate_TChNFe(self.chave)
        self.chave_nsprefix_ = None
        self.PIN = PIN
        self.validate_PINType79(self.PIN)
        self.PIN_nsprefix_ = None
        self.dPrev = dPrev
        self.validate_TData(self.dPrev)
        self.dPrev_nsprefix_ = None
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        self.infUnidCarga_nsprefix_ = None
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        self.infUnidTransp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeType.subclass:
            return infNFeType.subclass(*args_, **kwargs_)
        else:
            return infNFeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chave(self):
        return self.chave
    def set_chave(self, chave):
        self.chave = chave
    def get_PIN(self):
        return self.PIN
    def set_PIN(self, PIN):
        self.PIN = PIN
    def get_dPrev(self):
        return self.dPrev
    def set_dPrev(self, dPrev):
        self.dPrev = dPrev
    def get_infUnidCarga(self):
        return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga):
        self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value):
        self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value):
        self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value):
        self.infUnidCarga[index] = value
    def get_infUnidTransp(self):
        return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp):
        self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value):
        self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value):
        self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value):
        self.infUnidTransp[index] = value
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def validate_PINType79(self, value):
        result = True
        # Validate type PINType79, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 9:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on PINType79' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on PINType79' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_PINType79_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_PINType79_patterns_, ))
                result = False
        return result
    validate_PINType79_patterns_ = [['^([1-9]{1}[0-9]{1,8})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def _hasContent(self):
        if (
            self.chave is not None or
            self.PIN is not None or
            self.dPrev is not None or
            self.infUnidCarga or
            self.infUnidTransp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infNFeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infNFeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infNFeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infNFeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infNFeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infNFeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chave is not None:
            namespaceprefix_ = self.chave_nsprefix_ + ':' if (UseCapturedNS_ and self.chave_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schave>%s</%schave>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chave), input_name='chave')), namespaceprefix_ , eol_))
        if self.PIN is not None:
            namespaceprefix_ = self.PIN_nsprefix_ + ':' if (UseCapturedNS_ and self.PIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPIN>%s</%sPIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PIN), input_name='PIN')), namespaceprefix_ , eol_))
        if self.dPrev is not None:
            namespaceprefix_ = self.dPrev_nsprefix_ + ':' if (UseCapturedNS_ and self.dPrev_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdPrev>%s</%sdPrev>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dPrev), input_name='dPrev')), namespaceprefix_ , eol_))
        for infUnidCarga_ in self.infUnidCarga:
            namespaceprefix_ = self.infUnidCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.infUnidCarga_nsprefix_) else ''
            infUnidCarga_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infUnidCarga', pretty_print=pretty_print)
        for infUnidTransp_ in self.infUnidTransp:
            namespaceprefix_ = self.infUnidTransp_nsprefix_ + ':' if (UseCapturedNS_ and self.infUnidTransp_nsprefix_) else ''
            infUnidTransp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infUnidTransp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chave':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chave')
            value_ = self.gds_validate_string(value_, node, 'chave')
            self.chave = value_
            self.chave_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.chave)
        elif nodeName_ == 'PIN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PIN')
            value_ = self.gds_validate_string(value_, node, 'PIN')
            self.PIN = value_
            self.PIN_nsprefix_ = child_.prefix
            # validate type PINType79
            self.validate_PINType79(self.PIN)
        elif nodeName_ == 'dPrev':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dPrev')
            value_ = self.gds_validate_string(value_, node, 'dPrev')
            self.dPrev = value_
            self.dPrev_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dPrev)
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
# end class infNFeType


class infOutrosType(GeneratedsSuper):
    """infOutrosType -- Informa
    ç
    õ
    es dos demais documentos
    tpDoc -- Tipo de documento origin
    á
    rio
    Preencher com:
    00 - Declara
    ç
    ã
    o;
    10 - Dutovi
    á
    rio;
    59 - CF-e SAT;
    65 - NFC-e;
    99 - Outros
    descOutros -- Descri
    ç
    ã
    o do documento
    nDoc -- N
    ú
    mero
    dEmi -- Data de Emiss
    ã
    o
    Formato AAAA-MM-DD
    vDocFisc -- Valor do documento
    dPrev -- Data prevista de entrega
    Formato AAAA-MM-DD
    infUnidCarga -- Informa
    ç
    õ
    es das Unidades de Carga (Containeres/ULD/Outros)
    Dispositivo de carga utilizada (Unit Load Device - ULD) significa todo tipo de cont
    ê
    iner de carga, vag
    ã
    o, cont
    ê
    iner de avi
    ã
    o, palete de aeronave com rede ou palete de aeronave com rede sobre um iglu.
    infUnidTransp -- Informa
    ç
    õ
    es das Unidades de Transporte (Carreta/Reboque/Vag
    ã
    o)
    Deve ser preenchido com as informa
    ç
    õ
    es das unidades de transporte utilizadas.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpDoc=None, descOutros=None, nDoc=None, dEmi=None, vDocFisc=None, dPrev=None, infUnidCarga=None, infUnidTransp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpDoc = tpDoc
        self.validate_tpDocType(self.tpDoc)
        self.tpDoc_nsprefix_ = None
        self.descOutros = descOutros
        self.validate_descOutrosType(self.descOutros)
        self.descOutros_nsprefix_ = None
        self.nDoc = nDoc
        self.validate_nDocType80(self.nDoc)
        self.nDoc_nsprefix_ = None
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.dEmi_nsprefix_ = None
        self.vDocFisc = vDocFisc
        self.validate_TDec_1302Opc(self.vDocFisc)
        self.vDocFisc_nsprefix_ = None
        self.dPrev = dPrev
        self.validate_TData(self.dPrev)
        self.dPrev_nsprefix_ = None
        if infUnidCarga is None:
            self.infUnidCarga = []
        else:
            self.infUnidCarga = infUnidCarga
        self.infUnidCarga_nsprefix_ = None
        if infUnidTransp is None:
            self.infUnidTransp = []
        else:
            self.infUnidTransp = infUnidTransp
        self.infUnidTransp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infOutrosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infOutrosType.subclass:
            return infOutrosType.subclass(*args_, **kwargs_)
        else:
            return infOutrosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpDoc(self):
        return self.tpDoc
    def set_tpDoc(self, tpDoc):
        self.tpDoc = tpDoc
    def get_descOutros(self):
        return self.descOutros
    def set_descOutros(self, descOutros):
        self.descOutros = descOutros
    def get_nDoc(self):
        return self.nDoc
    def set_nDoc(self, nDoc):
        self.nDoc = nDoc
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def get_vDocFisc(self):
        return self.vDocFisc
    def set_vDocFisc(self, vDocFisc):
        self.vDocFisc = vDocFisc
    def get_dPrev(self):
        return self.dPrev
    def set_dPrev(self, dPrev):
        self.dPrev = dPrev
    def get_infUnidCarga(self):
        return self.infUnidCarga
    def set_infUnidCarga(self, infUnidCarga):
        self.infUnidCarga = infUnidCarga
    def add_infUnidCarga(self, value):
        self.infUnidCarga.append(value)
    def insert_infUnidCarga_at(self, index, value):
        self.infUnidCarga.insert(index, value)
    def replace_infUnidCarga_at(self, index, value):
        self.infUnidCarga[index] = value
    def get_infUnidTransp(self):
        return self.infUnidTransp
    def set_infUnidTransp(self, infUnidTransp):
        self.infUnidTransp = infUnidTransp
    def add_infUnidTransp(self, value):
        self.infUnidTransp.append(value)
    def insert_infUnidTransp_at(self, index, value):
        self.infUnidTransp.insert(index, value)
    def replace_infUnidTransp_at(self, index, value):
        self.infUnidTransp[index] = value
    def validate_tpDocType(self, value):
        result = True
        # Validate type tpDocType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['00', '10', '59', '65', '99']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpDocType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_descOutrosType(self, value):
        result = True
        # Validate type descOutrosType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 100:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on descOutrosType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on descOutrosType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_descOutrosType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_descOutrosType_patterns_, ))
                result = False
        return result
    validate_descOutrosType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nDocType80(self, value):
        result = True
        # Validate type nDocType80, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nDocType80' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nDocType80' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nDocType80_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nDocType80_patterns_, ))
                result = False
        return result
    validate_nDocType80_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def validate_TDec_1302Opc(self, value):
        result = True
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_1302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.tpDoc is not None or
            self.descOutros is not None or
            self.nDoc is not None or
            self.dEmi is not None or
            self.vDocFisc is not None or
            self.dPrev is not None or
            self.infUnidCarga or
            self.infUnidTransp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infOutrosType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infOutrosType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infOutrosType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infOutrosType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infOutrosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infOutrosType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infOutrosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpDoc is not None:
            namespaceprefix_ = self.tpDoc_nsprefix_ + ':' if (UseCapturedNS_ and self.tpDoc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpDoc>%s</%stpDoc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpDoc), input_name='tpDoc')), namespaceprefix_ , eol_))
        if self.descOutros is not None:
            namespaceprefix_ = self.descOutros_nsprefix_ + ':' if (UseCapturedNS_ and self.descOutros_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescOutros>%s</%sdescOutros>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.descOutros), input_name='descOutros')), namespaceprefix_ , eol_))
        if self.nDoc is not None:
            namespaceprefix_ = self.nDoc_nsprefix_ + ':' if (UseCapturedNS_ and self.nDoc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDoc>%s</%snDoc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDoc), input_name='nDoc')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            namespaceprefix_ = self.dEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
        if self.vDocFisc is not None:
            namespaceprefix_ = self.vDocFisc_nsprefix_ + ':' if (UseCapturedNS_ and self.vDocFisc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDocFisc>%s</%svDocFisc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDocFisc), input_name='vDocFisc')), namespaceprefix_ , eol_))
        if self.dPrev is not None:
            namespaceprefix_ = self.dPrev_nsprefix_ + ':' if (UseCapturedNS_ and self.dPrev_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdPrev>%s</%sdPrev>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dPrev), input_name='dPrev')), namespaceprefix_ , eol_))
        for infUnidCarga_ in self.infUnidCarga:
            namespaceprefix_ = self.infUnidCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.infUnidCarga_nsprefix_) else ''
            infUnidCarga_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infUnidCarga', pretty_print=pretty_print)
        for infUnidTransp_ in self.infUnidTransp:
            namespaceprefix_ = self.infUnidTransp_nsprefix_ + ':' if (UseCapturedNS_ and self.infUnidTransp_nsprefix_) else ''
            infUnidTransp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infUnidTransp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpDoc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpDoc')
            value_ = self.gds_validate_string(value_, node, 'tpDoc')
            self.tpDoc = value_
            self.tpDoc_nsprefix_ = child_.prefix
            # validate type tpDocType
            self.validate_tpDocType(self.tpDoc)
        elif nodeName_ == 'descOutros':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'descOutros')
            value_ = self.gds_validate_string(value_, node, 'descOutros')
            self.descOutros = value_
            self.descOutros_nsprefix_ = child_.prefix
            # validate type descOutrosType
            self.validate_descOutrosType(self.descOutros)
        elif nodeName_ == 'nDoc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nDoc')
            value_ = self.gds_validate_string(value_, node, 'nDoc')
            self.nDoc = value_
            self.nDoc_nsprefix_ = child_.prefix
            # validate type nDocType80
            self.validate_nDocType80(self.nDoc)
        elif nodeName_ == 'dEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dEmi')
            value_ = self.gds_validate_string(value_, node, 'dEmi')
            self.dEmi = value_
            self.dEmi_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dEmi)
        elif nodeName_ == 'vDocFisc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vDocFisc')
            value_ = self.gds_validate_string(value_, node, 'vDocFisc')
            self.vDocFisc = value_
            self.vDocFisc_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDocFisc)
        elif nodeName_ == 'dPrev':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dPrev')
            value_ = self.gds_validate_string(value_, node, 'dPrev')
            self.dPrev = value_
            self.dPrev_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dPrev)
        elif nodeName_ == 'infUnidCarga':
            obj_ = TUnidCarga.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infUnidCarga.append(obj_)
            obj_.original_tagname_ = 'infUnidCarga'
        elif nodeName_ == 'infUnidTransp':
            obj_ = TUnidadeTransp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infUnidTransp.append(obj_)
            obj_.original_tagname_ = 'infUnidTransp'
# end class infOutrosType


class docAntType(GeneratedsSuper):
    """docAntType -- Documentos de Transporte Anterior
    emiDocAnt -- Emissor do documento anterior
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, emiDocAnt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if emiDocAnt is None:
            self.emiDocAnt = []
        else:
            self.emiDocAnt = emiDocAnt
        self.emiDocAnt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docAntType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docAntType.subclass:
            return docAntType.subclass(*args_, **kwargs_)
        else:
            return docAntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_emiDocAnt(self):
        return self.emiDocAnt
    def set_emiDocAnt(self, emiDocAnt):
        self.emiDocAnt = emiDocAnt
    def add_emiDocAnt(self, value):
        self.emiDocAnt.append(value)
    def insert_emiDocAnt_at(self, index, value):
        self.emiDocAnt.insert(index, value)
    def replace_emiDocAnt_at(self, index, value):
        self.emiDocAnt[index] = value
    def _hasContent(self):
        if (
            self.emiDocAnt
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='docAntType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docAntType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docAntType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docAntType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docAntType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docAntType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='docAntType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for emiDocAnt_ in self.emiDocAnt:
            namespaceprefix_ = self.emiDocAnt_nsprefix_ + ':' if (UseCapturedNS_ and self.emiDocAnt_nsprefix_) else ''
            emiDocAnt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emiDocAnt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'emiDocAnt':
            obj_ = emiDocAntType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emiDocAnt.append(obj_)
            obj_.original_tagname_ = 'emiDocAnt'
# end class docAntType


class emiDocAntType(GeneratedsSuper):
    """emiDocAntType -- Emissor do documento anterior
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    UF -- Sigla da UF
    Informar EX para opera
    ç
    õ
    es com o exterior.
    xNome -- Raz
    ã
    o Social ou Nome do expedidor
    idDocAnt -- Informa
    ç
    õ
    es de identifica
    ç
    ã
    o dos documentos de Transporte Anterior
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, UF=None, xNome=None, idDocAnt=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_TIe(self.IE)
        self.IE_nsprefix_ = None
        self.UF = UF
        self.validate_TUf(self.UF)
        self.UF_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType81(self.xNome)
        self.xNome_nsprefix_ = None
        if idDocAnt is None:
            self.idDocAnt = []
        else:
            self.idDocAnt = idDocAnt
        self.idDocAnt_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emiDocAntType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emiDocAntType.subclass:
            return emiDocAntType.subclass(*args_, **kwargs_)
        else:
            return emiDocAntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_idDocAnt(self):
        return self.idDocAnt
    def set_idDocAnt(self, idDocAnt):
        self.idDocAnt = idDocAnt
    def add_idDocAnt(self, value):
        self.idDocAnt.append(value)
    def insert_idDocAnt_at(self, index, value):
        self.idDocAnt.insert(index, value)
    def replace_idDocAnt_at(self, index, value):
        self.idDocAnt[index] = value
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_TIe(self, value):
        result = True
        # Validate type TIe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TIe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TIe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TIe_patterns_, ))
                result = False
        return result
    validate_TIe_patterns_ = [['^([0-9]{2,14})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_xNomeType81(self, value):
        result = True
        # Validate type xNomeType81, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType81' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType81' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType81_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType81_patterns_, ))
                result = False
        return result
    validate_xNomeType81_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.UF is not None or
            self.xNome is not None or
            self.idDocAnt
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='emiDocAntType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emiDocAntType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'emiDocAntType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='emiDocAntType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='emiDocAntType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='emiDocAntType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='emiDocAntType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.UF is not None:
            namespaceprefix_ = self.UF_nsprefix_ + ':' if (UseCapturedNS_ and self.UF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        for idDocAnt_ in self.idDocAnt:
            namespaceprefix_ = self.idDocAnt_nsprefix_ + ':' if (UseCapturedNS_ and self.idDocAnt_nsprefix_) else ''
            idDocAnt_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='idDocAnt', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type TIe
            self.validate_TIe(self.IE)
        elif nodeName_ == 'UF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UF')
            value_ = self.gds_validate_string(value_, node, 'UF')
            self.UF = value_
            self.UF_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType81
            self.validate_xNomeType81(self.xNome)
        elif nodeName_ == 'idDocAnt':
            obj_ = idDocAntType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.idDocAnt.append(obj_)
            obj_.original_tagname_ = 'idDocAnt'
# end class emiDocAntType


class idDocAntType(GeneratedsSuper):
    """idDocAntType -- Informa
    ç
    õ
    es de identifica
    ç
    ã
    o dos documentos de Transporte Anterior
    idDocAntPap -- Documentos de transporte anterior em papel
    idDocAntEle -- Documentos de transporte anterior eletr
    ô
    nicos
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idDocAntPap=None, idDocAntEle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if idDocAntPap is None:
            self.idDocAntPap = []
        else:
            self.idDocAntPap = idDocAntPap
        self.idDocAntPap_nsprefix_ = None
        if idDocAntEle is None:
            self.idDocAntEle = []
        else:
            self.idDocAntEle = idDocAntEle
        self.idDocAntEle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idDocAntType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idDocAntType.subclass:
            return idDocAntType.subclass(*args_, **kwargs_)
        else:
            return idDocAntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idDocAntPap(self):
        return self.idDocAntPap
    def set_idDocAntPap(self, idDocAntPap):
        self.idDocAntPap = idDocAntPap
    def add_idDocAntPap(self, value):
        self.idDocAntPap.append(value)
    def insert_idDocAntPap_at(self, index, value):
        self.idDocAntPap.insert(index, value)
    def replace_idDocAntPap_at(self, index, value):
        self.idDocAntPap[index] = value
    def get_idDocAntEle(self):
        return self.idDocAntEle
    def set_idDocAntEle(self, idDocAntEle):
        self.idDocAntEle = idDocAntEle
    def add_idDocAntEle(self, value):
        self.idDocAntEle.append(value)
    def insert_idDocAntEle_at(self, index, value):
        self.idDocAntEle.insert(index, value)
    def replace_idDocAntEle_at(self, index, value):
        self.idDocAntEle[index] = value
    def _hasContent(self):
        if (
            self.idDocAntPap or
            self.idDocAntEle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='idDocAntType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idDocAntType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'idDocAntType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='idDocAntType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='idDocAntType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='idDocAntType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='idDocAntType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for idDocAntPap_ in self.idDocAntPap:
            namespaceprefix_ = self.idDocAntPap_nsprefix_ + ':' if (UseCapturedNS_ and self.idDocAntPap_nsprefix_) else ''
            idDocAntPap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='idDocAntPap', pretty_print=pretty_print)
        for idDocAntEle_ in self.idDocAntEle:
            namespaceprefix_ = self.idDocAntEle_nsprefix_ + ':' if (UseCapturedNS_ and self.idDocAntEle_nsprefix_) else ''
            idDocAntEle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='idDocAntEle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'idDocAntPap':
            obj_ = idDocAntPapType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.idDocAntPap.append(obj_)
            obj_.original_tagname_ = 'idDocAntPap'
        elif nodeName_ == 'idDocAntEle':
            obj_ = idDocAntEleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.idDocAntEle.append(obj_)
            obj_.original_tagname_ = 'idDocAntEle'
# end class idDocAntType


class idDocAntPapType(GeneratedsSuper):
    """idDocAntPapType -- Documentos de transporte anterior em papel
    tpDoc -- Tipo do Documento de Transporte Anterior
    Preencher com:
    07-ATRE;
    08-DTA (Despacho de Transito Aduaneiro);
    09-Conhecimento A
    é
    reo Internacional;
    10
    –
    Conhecimento - Carta de Porte Internacional;
    11
    –
    Conhecimento Avulso;
    12-TIF (Transporte Internacional Ferrovi
    á
    rio); 13-BL (Bill of Lading)
    serie -- S
    é
    rie do Documento Fiscal
    subser -- S
    é
    rie do Documento Fiscal
    nDoc -- N
    ú
    mero do Documento Fiscal
    dEmi -- Data de emiss
    ã
    o (AAAA-MM-DD)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpDoc=None, serie=None, subser=None, nDoc=None, dEmi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpDoc = tpDoc
        self.validate_tpDocType82(self.tpDoc)
        self.tpDoc_nsprefix_ = None
        self.serie = serie
        self.validate_serieType83(self.serie)
        self.serie_nsprefix_ = None
        self.subser = subser
        self.validate_subserType(self.subser)
        self.subser_nsprefix_ = None
        self.nDoc = nDoc
        self.validate_nDocType84(self.nDoc)
        self.nDoc_nsprefix_ = None
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.dEmi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idDocAntPapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idDocAntPapType.subclass:
            return idDocAntPapType.subclass(*args_, **kwargs_)
        else:
            return idDocAntPapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpDoc(self):
        return self.tpDoc
    def set_tpDoc(self, tpDoc):
        self.tpDoc = tpDoc
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_subser(self):
        return self.subser
    def set_subser(self, subser):
        self.subser = subser
    def get_nDoc(self):
        return self.nDoc
    def set_nDoc(self, nDoc):
        self.nDoc = nDoc
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def validate_tpDocType82(self, value):
        result = True
        # Validate type tpDocType82, a restriction on TDocAssoc.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['07', '08', '09', '10', '11', '12', '13']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpDocType82' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_serieType83(self, value):
        result = True
        # Validate type serieType83, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on serieType83' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on serieType83' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_serieType83_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_serieType83_patterns_, ))
                result = False
        return result
    validate_serieType83_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_subserType(self, value):
        result = True
        # Validate type subserType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on subserType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on subserType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_subserType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_subserType_patterns_, ))
                result = False
        return result
    validate_subserType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nDocType84(self, value):
        result = True
        # Validate type nDocType84, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nDocType84' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nDocType84' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nDocType84_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nDocType84_patterns_, ))
                result = False
        return result
    validate_nDocType84_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def _hasContent(self):
        if (
            self.tpDoc is not None or
            self.serie is not None or
            self.subser is not None or
            self.nDoc is not None or
            self.dEmi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='idDocAntPapType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idDocAntPapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'idDocAntPapType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='idDocAntPapType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='idDocAntPapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='idDocAntPapType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='idDocAntPapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpDoc is not None:
            namespaceprefix_ = self.tpDoc_nsprefix_ + ':' if (UseCapturedNS_ and self.tpDoc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpDoc>%s</%stpDoc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpDoc), input_name='tpDoc')), namespaceprefix_ , eol_))
        if self.serie is not None:
            namespaceprefix_ = self.serie_nsprefix_ + ':' if (UseCapturedNS_ and self.serie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.subser is not None:
            namespaceprefix_ = self.subser_nsprefix_ + ':' if (UseCapturedNS_ and self.subser_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubser>%s</%ssubser>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subser), input_name='subser')), namespaceprefix_ , eol_))
        if self.nDoc is not None:
            namespaceprefix_ = self.nDoc_nsprefix_ + ':' if (UseCapturedNS_ and self.nDoc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDoc>%s</%snDoc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDoc), input_name='nDoc')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            namespaceprefix_ = self.dEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpDoc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpDoc')
            value_ = self.gds_validate_string(value_, node, 'tpDoc')
            self.tpDoc = value_
            self.tpDoc_nsprefix_ = child_.prefix
            # validate type tpDocType82
            self.validate_tpDocType82(self.tpDoc)
        elif nodeName_ == 'serie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serie')
            value_ = self.gds_validate_string(value_, node, 'serie')
            self.serie = value_
            self.serie_nsprefix_ = child_.prefix
            # validate type serieType83
            self.validate_serieType83(self.serie)
        elif nodeName_ == 'subser':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subser')
            value_ = self.gds_validate_string(value_, node, 'subser')
            self.subser = value_
            self.subser_nsprefix_ = child_.prefix
            # validate type subserType
            self.validate_subserType(self.subser)
        elif nodeName_ == 'nDoc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nDoc')
            value_ = self.gds_validate_string(value_, node, 'nDoc')
            self.nDoc = value_
            self.nDoc_nsprefix_ = child_.prefix
            # validate type nDocType84
            self.validate_nDocType84(self.nDoc)
        elif nodeName_ == 'dEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dEmi')
            value_ = self.gds_validate_string(value_, node, 'dEmi')
            self.dEmi = value_
            self.dEmi_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dEmi)
# end class idDocAntPapType


class idDocAntEleType(GeneratedsSuper):
    """idDocAntEleType -- Documentos de transporte anterior eletr
    ô
    nicos
    chCTe -- Chave de acesso do CT-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCTe = chCTe
        self.validate_TChNFe(self.chCTe)
        self.chCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, idDocAntEleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if idDocAntEleType.subclass:
            return idDocAntEleType.subclass(*args_, **kwargs_)
        else:
            return idDocAntEleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCTe(self):
        return self.chCTe
    def set_chCTe(self, chCTe):
        self.chCTe = chCTe
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.chCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='idDocAntEleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('idDocAntEleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'idDocAntEleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='idDocAntEleType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='idDocAntEleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='idDocAntEleType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='idDocAntEleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTe is not None:
            namespaceprefix_ = self.chCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.chCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCTe')
            value_ = self.gds_validate_string(value_, node, 'chCTe')
            self.chCTe = value_
            self.chCTe_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.chCTe)
# end class idDocAntEleType


class infModalType(GeneratedsSuper):
    """infModalType -- Informa
    ç
    õ
    es do modal
     -- XML do modal
    Insira neste local o XML espec
    í
    fico do modal (rodovi
    á
    rio, a
    é
    reo, ferrovi
    á
    rio, aquavi
    á
    rio ou dutovi
    á
    rio).
    O elemento do tipo -any- permite estender o documento XML com elementos n
    ã
    o especificados pelo schema.
    Insira neste local - any- o XML espec
    í
    fico do modal (rodovi
    á
    rio, a
    é
    reo, ferrovi
    á
    rio, aquavi
    á
    rio ou dutovi
    á
    rio). A especifica
    ç
    ã
    o do schema XML para cada modal pode ser encontrada nos arquivos que acompanham este pacote de libera
    ç
    ã
    o:
    Rodovi
    á
    rio - ver arquivo CTeModalRodoviario_v9.99
    A
    é
    reo - ver arquivo CTeModalAereo_v9.99
    Aquavi
    á
    rio - arquivo CTeModalAquaviario_v9.99
    Ferrovi
    á
    rio - arquivo CTeModalFerroviario_v9.99
    Dutovi
    á
    rio - arquivo CTeModalDutoviario_v9.99
    Onde v9.99
    é
    a a designa
    ç
    ã
    o gen
    é
    rica para a vers
    ã
    o do arquivo. Por exemplo, o arquivo para o schema do modal Rodovi
    á
    rio na vers
    ã
    o 1.04 ser
    á
    denominado "CTeModalRodoviario_v1.04".
    versaoModal -- Vers
    ã
    o do leiaute espec
    í
    fico para o Modal
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versaoModal=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versaoModal = _cast(None, versaoModal)
        self.versaoModal_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infModalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infModalType.subclass:
            return infModalType.subclass(*args_, **kwargs_)
        else:
            return infModalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_versaoModal(self):
        return self.versaoModal
    def set_versaoModal(self, versaoModal):
        self.versaoModal = versaoModal
    def validate_versaoModalType(self, value):
        # Validate type versaoModalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoModalType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoModalType_patterns_, ))
    validate_versaoModalType_patterns_ = [['^(3\\.(0[0-9]|[1-9][0-9]))$']]
    def _hasContent(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infModalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infModalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infModalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infModalType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infModalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infModalType'):
        if self.versaoModal is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            outfile.write(' versaoModal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versaoModal), input_name='versaoModal')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infModalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versaoModal', node)
        if value is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            self.versaoModal = value
            self.validate_versaoModalType(self.versaoModal)    # validate type versaoModalType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'infModalType')
        self.set_anytypeobjs_(content_)
# end class infModalType


class veicNovosType(GeneratedsSuper):
    """veicNovosType -- informa
    ç
    õ
    es dos ve
    í
    culos transportados
    chassi -- Chassi do ve
    í
    culo
    cCor -- Cor do ve
    í
    culo
    C
    ó
    digo de cada montadora
    xCor -- Descri
    ç
    ã
    o da cor
    cMod -- C
    ó
    digo Marca Modelo
    Utilizar tabela RENAVAM
    vUnit -- Valor Unit
    á
    rio do Ve
    í
    culo
    vFrete -- Frete Unit
    á
    rio
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chassi=None, cCor=None, xCor=None, cMod=None, vUnit=None, vFrete=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chassi = chassi
        self.validate_chassiType(self.chassi)
        self.chassi_nsprefix_ = None
        self.cCor = cCor
        self.validate_cCorType(self.cCor)
        self.cCor_nsprefix_ = None
        self.xCor = xCor
        self.validate_xCorType(self.xCor)
        self.xCor_nsprefix_ = None
        self.cMod = cMod
        self.validate_cModType(self.cMod)
        self.cMod_nsprefix_ = None
        self.vUnit = vUnit
        self.validate_TDec_1302(self.vUnit)
        self.vUnit_nsprefix_ = None
        self.vFrete = vFrete
        self.validate_TDec_1302(self.vFrete)
        self.vFrete_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, veicNovosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if veicNovosType.subclass:
            return veicNovosType.subclass(*args_, **kwargs_)
        else:
            return veicNovosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chassi(self):
        return self.chassi
    def set_chassi(self, chassi):
        self.chassi = chassi
    def get_cCor(self):
        return self.cCor
    def set_cCor(self, cCor):
        self.cCor = cCor
    def get_xCor(self):
        return self.xCor
    def set_xCor(self, xCor):
        self.xCor = xCor
    def get_cMod(self):
        return self.cMod
    def set_cMod(self, cMod):
        self.cMod = cMod
    def get_vUnit(self):
        return self.vUnit
    def set_vUnit(self, vUnit):
        self.vUnit = vUnit
    def get_vFrete(self):
        return self.vFrete
    def set_vFrete(self, vFrete):
        self.vFrete = vFrete
    def validate_chassiType(self, value):
        result = True
        # Validate type chassiType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) != 17:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd length restriction on chassiType' % {"value": encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_chassiType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_chassiType_patterns_, ))
                result = False
        return result
    validate_chassiType_patterns_ = [['^([A-Z0-9]+)$']]
    def validate_cCorType(self, value):
        result = True
        # Validate type cCorType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on cCorType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on cCorType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_cCorType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cCorType_patterns_, ))
                result = False
        return result
    validate_cCorType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCorType(self, value):
        result = True
        # Validate type xCorType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCorType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCorType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCorType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCorType_patterns_, ))
                result = False
        return result
    validate_xCorType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_cModType(self, value):
        result = True
        # Validate type cModType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on cModType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on cModType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_cModType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cModType_patterns_, ))
                result = False
        return result
    validate_cModType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.chassi is not None or
            self.cCor is not None or
            self.xCor is not None or
            self.cMod is not None or
            self.vUnit is not None or
            self.vFrete is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='veicNovosType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('veicNovosType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'veicNovosType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='veicNovosType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='veicNovosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='veicNovosType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='veicNovosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chassi is not None:
            namespaceprefix_ = self.chassi_nsprefix_ + ':' if (UseCapturedNS_ and self.chassi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schassi>%s</%schassi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chassi), input_name='chassi')), namespaceprefix_ , eol_))
        if self.cCor is not None:
            namespaceprefix_ = self.cCor_nsprefix_ + ':' if (UseCapturedNS_ and self.cCor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scCor>%s</%scCor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cCor), input_name='cCor')), namespaceprefix_ , eol_))
        if self.xCor is not None:
            namespaceprefix_ = self.xCor_nsprefix_ + ':' if (UseCapturedNS_ and self.xCor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCor>%s</%sxCor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCor), input_name='xCor')), namespaceprefix_ , eol_))
        if self.cMod is not None:
            namespaceprefix_ = self.cMod_nsprefix_ + ':' if (UseCapturedNS_ and self.cMod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMod>%s</%scMod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMod), input_name='cMod')), namespaceprefix_ , eol_))
        if self.vUnit is not None:
            namespaceprefix_ = self.vUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.vUnit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svUnit>%s</%svUnit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vUnit), input_name='vUnit')), namespaceprefix_ , eol_))
        if self.vFrete is not None:
            namespaceprefix_ = self.vFrete_nsprefix_ + ':' if (UseCapturedNS_ and self.vFrete_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFrete>%s</%svFrete>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFrete), input_name='vFrete')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chassi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chassi')
            value_ = self.gds_validate_string(value_, node, 'chassi')
            self.chassi = value_
            self.chassi_nsprefix_ = child_.prefix
            # validate type chassiType
            self.validate_chassiType(self.chassi)
        elif nodeName_ == 'cCor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cCor')
            value_ = self.gds_validate_string(value_, node, 'cCor')
            self.cCor = value_
            self.cCor_nsprefix_ = child_.prefix
            # validate type cCorType
            self.validate_cCorType(self.cCor)
        elif nodeName_ == 'xCor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCor')
            value_ = self.gds_validate_string(value_, node, 'xCor')
            self.xCor = value_
            self.xCor_nsprefix_ = child_.prefix
            # validate type xCorType
            self.validate_xCorType(self.xCor)
        elif nodeName_ == 'cMod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMod')
            value_ = self.gds_validate_string(value_, node, 'cMod')
            self.cMod = value_
            self.cMod_nsprefix_ = child_.prefix
            # validate type cModType
            self.validate_cModType(self.cMod)
        elif nodeName_ == 'vUnit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vUnit')
            value_ = self.gds_validate_string(value_, node, 'vUnit')
            self.vUnit = value_
            self.vUnit_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vUnit)
        elif nodeName_ == 'vFrete':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vFrete')
            value_ = self.gds_validate_string(value_, node, 'vFrete')
            self.vFrete = value_
            self.vFrete_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFrete)
# end class veicNovosType


class cobrType(GeneratedsSuper):
    """cobrType -- Dados da cobran
    ç
    a do CT-e
    fat -- Dados da fatura
    dup -- Dados das duplicatas
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fat=None, dup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fat = fat
        self.fat_nsprefix_ = None
        if dup is None:
            self.dup = []
        else:
            self.dup = dup
        self.dup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cobrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cobrType.subclass:
            return cobrType.subclass(*args_, **kwargs_)
        else:
            return cobrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fat(self):
        return self.fat
    def set_fat(self, fat):
        self.fat = fat
    def get_dup(self):
        return self.dup
    def set_dup(self, dup):
        self.dup = dup
    def add_dup(self, value):
        self.dup.append(value)
    def insert_dup_at(self, index, value):
        self.dup.insert(index, value)
    def replace_dup_at(self, index, value):
        self.dup[index] = value
    def _hasContent(self):
        if (
            self.fat is not None or
            self.dup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='cobrType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cobrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cobrType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cobrType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cobrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cobrType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='cobrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fat is not None:
            namespaceprefix_ = self.fat_nsprefix_ + ':' if (UseCapturedNS_ and self.fat_nsprefix_) else ''
            self.fat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fat', pretty_print=pretty_print)
        for dup_ in self.dup:
            namespaceprefix_ = self.dup_nsprefix_ + ':' if (UseCapturedNS_ and self.dup_nsprefix_) else ''
            dup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fat':
            obj_ = fatType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fat = obj_
            obj_.original_tagname_ = 'fat'
        elif nodeName_ == 'dup':
            obj_ = dupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dup.append(obj_)
            obj_.original_tagname_ = 'dup'
# end class cobrType


class fatType(GeneratedsSuper):
    """fatType -- Dados da fatura
    nFat -- N
    ú
    mero da fatura
    vOrig -- Valor original da fatura
    vDesc -- Valor do desconto da fatura
    vLiq -- Valor l
    í
    quido da fatura
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nFat=None, vOrig=None, vDesc=None, vLiq=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nFat = nFat
        self.validate_nFatType(self.nFat)
        self.nFat_nsprefix_ = None
        self.vOrig = vOrig
        self.validate_TDec_1302Opc(self.vOrig)
        self.vOrig_nsprefix_ = None
        self.vDesc = vDesc
        self.validate_TDec_1302Opc(self.vDesc)
        self.vDesc_nsprefix_ = None
        self.vLiq = vLiq
        self.validate_TDec_1302Opc(self.vLiq)
        self.vLiq_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fatType.subclass:
            return fatType.subclass(*args_, **kwargs_)
        else:
            return fatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nFat(self):
        return self.nFat
    def set_nFat(self, nFat):
        self.nFat = nFat
    def get_vOrig(self):
        return self.vOrig
    def set_vOrig(self, vOrig):
        self.vOrig = vOrig
    def get_vDesc(self):
        return self.vDesc
    def set_vDesc(self, vDesc):
        self.vDesc = vDesc
    def get_vLiq(self):
        return self.vLiq
    def set_vLiq(self, vLiq):
        self.vLiq = vLiq
    def validate_nFatType(self, value):
        result = True
        # Validate type nFatType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nFatType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nFatType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nFatType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nFatType_patterns_, ))
                result = False
        return result
    validate_nFatType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TDec_1302Opc(self, value):
        result = True
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_1302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.nFat is not None or
            self.vOrig is not None or
            self.vDesc is not None or
            self.vLiq is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fatType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fatType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fatType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nFat is not None:
            namespaceprefix_ = self.nFat_nsprefix_ + ':' if (UseCapturedNS_ and self.nFat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snFat>%s</%snFat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nFat), input_name='nFat')), namespaceprefix_ , eol_))
        if self.vOrig is not None:
            namespaceprefix_ = self.vOrig_nsprefix_ + ':' if (UseCapturedNS_ and self.vOrig_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svOrig>%s</%svOrig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vOrig), input_name='vOrig')), namespaceprefix_ , eol_))
        if self.vDesc is not None:
            namespaceprefix_ = self.vDesc_nsprefix_ + ':' if (UseCapturedNS_ and self.vDesc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDesc>%s</%svDesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), namespaceprefix_ , eol_))
        if self.vLiq is not None:
            namespaceprefix_ = self.vLiq_nsprefix_ + ':' if (UseCapturedNS_ and self.vLiq_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svLiq>%s</%svLiq>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vLiq), input_name='vLiq')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nFat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nFat')
            value_ = self.gds_validate_string(value_, node, 'nFat')
            self.nFat = value_
            self.nFat_nsprefix_ = child_.prefix
            # validate type nFatType
            self.validate_nFatType(self.nFat)
        elif nodeName_ == 'vOrig':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vOrig')
            value_ = self.gds_validate_string(value_, node, 'vOrig')
            self.vOrig = value_
            self.vOrig_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOrig)
        elif nodeName_ == 'vDesc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vDesc')
            value_ = self.gds_validate_string(value_, node, 'vDesc')
            self.vDesc = value_
            self.vDesc_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDesc)
        elif nodeName_ == 'vLiq':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vLiq')
            value_ = self.gds_validate_string(value_, node, 'vLiq')
            self.vLiq = value_
            self.vLiq_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vLiq)
# end class fatType


class dupType(GeneratedsSuper):
    """dupType -- Dados das duplicatas
    nDup -- N
    ú
    mero da duplicata
    dVenc -- Data de vencimento da duplicata (AAAA-MM-DD)
    vDup -- Valor da duplicata
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nDup=None, dVenc=None, vDup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nDup = nDup
        self.validate_nDupType(self.nDup)
        self.nDup_nsprefix_ = None
        self.dVenc = dVenc
        self.validate_TData(self.dVenc)
        self.dVenc_nsprefix_ = None
        self.vDup = vDup
        self.validate_TDec_1302Opc(self.vDup)
        self.vDup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dupType.subclass:
            return dupType.subclass(*args_, **kwargs_)
        else:
            return dupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nDup(self):
        return self.nDup
    def set_nDup(self, nDup):
        self.nDup = nDup
    def get_dVenc(self):
        return self.dVenc
    def set_dVenc(self, dVenc):
        self.dVenc = dVenc
    def get_vDup(self):
        return self.vDup
    def set_vDup(self, vDup):
        self.vDup = vDup
    def validate_nDupType(self, value):
        result = True
        # Validate type nDupType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nDupType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nDupType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nDupType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nDupType_patterns_, ))
                result = False
        return result
    validate_nDupType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def validate_TDec_1302Opc(self, value):
        result = True
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_1302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.nDup is not None or
            self.dVenc is not None or
            self.vDup is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='dupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dupType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dupType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='dupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDup is not None:
            namespaceprefix_ = self.nDup_nsprefix_ + ':' if (UseCapturedNS_ and self.nDup_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDup>%s</%snDup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDup), input_name='nDup')), namespaceprefix_ , eol_))
        if self.dVenc is not None:
            namespaceprefix_ = self.dVenc_nsprefix_ + ':' if (UseCapturedNS_ and self.dVenc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdVenc>%s</%sdVenc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dVenc), input_name='dVenc')), namespaceprefix_ , eol_))
        if self.vDup is not None:
            namespaceprefix_ = self.vDup_nsprefix_ + ':' if (UseCapturedNS_ and self.vDup_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDup>%s</%svDup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDup), input_name='vDup')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nDup':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nDup')
            value_ = self.gds_validate_string(value_, node, 'nDup')
            self.nDup = value_
            self.nDup_nsprefix_ = child_.prefix
            # validate type nDupType
            self.validate_nDupType(self.nDup)
        elif nodeName_ == 'dVenc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dVenc')
            value_ = self.gds_validate_string(value_, node, 'dVenc')
            self.dVenc = value_
            self.dVenc_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dVenc)
        elif nodeName_ == 'vDup':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vDup')
            value_ = self.gds_validate_string(value_, node, 'vDup')
            self.vDup = value_
            self.vDup_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDup)
# end class dupType


class infCteSubType(GeneratedsSuper):
    """infCteSubType -- Informa
    ç
    õ
    es do CT-e de substitui
    ç
    ã
    o
    chCte -- Chave de acesso do CT-e a ser substitu
    í
    do (original)
    refCteAnu -- Chave de acesso do CT-e de Anula
    ç
    ã
    o
    tomaICMS -- Tomador
    é
    contribuinte do ICMS, mas n
    ã
    o
    é
    emitente de documento fiscal eletr
    ô
    nico
    indAlteraToma -- Indicador de CT-e Altera
    ç
    ã
    o de Tomador
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCte=None, refCteAnu=None, tomaICMS=None, indAlteraToma=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCte = chCte
        self.validate_chCteType(self.chCte)
        self.chCte_nsprefix_ = None
        self.refCteAnu = refCteAnu
        self.validate_refCteAnuType(self.refCteAnu)
        self.refCteAnu_nsprefix_ = None
        self.tomaICMS = tomaICMS
        self.tomaICMS_nsprefix_ = None
        self.indAlteraToma = indAlteraToma
        self.validate_indAlteraTomaType(self.indAlteraToma)
        self.indAlteraToma_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteSubType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteSubType.subclass:
            return infCteSubType.subclass(*args_, **kwargs_)
        else:
            return infCteSubType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCte(self):
        return self.chCte
    def set_chCte(self, chCte):
        self.chCte = chCte
    def get_refCteAnu(self):
        return self.refCteAnu
    def set_refCteAnu(self, refCteAnu):
        self.refCteAnu = refCteAnu
    def get_tomaICMS(self):
        return self.tomaICMS
    def set_tomaICMS(self, tomaICMS):
        self.tomaICMS = tomaICMS
    def get_indAlteraToma(self):
        return self.indAlteraToma
    def set_indAlteraToma(self, indAlteraToma):
        self.indAlteraToma = indAlteraToma
    def validate_chCteType(self, value):
        result = True
        # Validate type chCteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_chCteType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_chCteType_patterns_, ))
                result = False
        return result
    validate_chCteType_patterns_ = [['^([0-9]{44})$']]
    def validate_refCteAnuType(self, value):
        result = True
        # Validate type refCteAnuType, a restriction on TChNFe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on refCteAnuType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_refCteAnuType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_refCteAnuType_patterns_, ))
                result = False
        return result
    validate_refCteAnuType_patterns_ = [['^([0-9]{44})$']]
    def validate_indAlteraTomaType(self, value):
        result = True
        # Validate type indAlteraTomaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on indAlteraTomaType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.chCte is not None or
            self.refCteAnu is not None or
            self.tomaICMS is not None or
            self.indAlteraToma is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteSubType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteSubType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteSubType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteSubType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteSubType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteSubType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteSubType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCte is not None:
            namespaceprefix_ = self.chCte_nsprefix_ + ':' if (UseCapturedNS_ and self.chCte_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCte>%s</%schCte>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCte), input_name='chCte')), namespaceprefix_ , eol_))
        if self.refCteAnu is not None:
            namespaceprefix_ = self.refCteAnu_nsprefix_ + ':' if (UseCapturedNS_ and self.refCteAnu_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefCteAnu>%s</%srefCteAnu>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refCteAnu), input_name='refCteAnu')), namespaceprefix_ , eol_))
        if self.tomaICMS is not None:
            namespaceprefix_ = self.tomaICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.tomaICMS_nsprefix_) else ''
            self.tomaICMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tomaICMS', pretty_print=pretty_print)
        if self.indAlteraToma is not None:
            namespaceprefix_ = self.indAlteraToma_nsprefix_ + ':' if (UseCapturedNS_ and self.indAlteraToma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindAlteraToma>%s</%sindAlteraToma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indAlteraToma), input_name='indAlteraToma')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCte':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCte')
            value_ = self.gds_validate_string(value_, node, 'chCte')
            self.chCte = value_
            self.chCte_nsprefix_ = child_.prefix
            # validate type chCteType
            self.validate_chCteType(self.chCte)
        elif nodeName_ == 'refCteAnu':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refCteAnu')
            value_ = self.gds_validate_string(value_, node, 'refCteAnu')
            self.refCteAnu = value_
            self.refCteAnu_nsprefix_ = child_.prefix
            # validate type refCteAnuType
            self.validate_refCteAnuType(self.refCteAnu)
        elif nodeName_ == 'tomaICMS':
            obj_ = tomaICMSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tomaICMS = obj_
            obj_.original_tagname_ = 'tomaICMS'
        elif nodeName_ == 'indAlteraToma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indAlteraToma')
            value_ = self.gds_validate_string(value_, node, 'indAlteraToma')
            self.indAlteraToma = value_
            self.indAlteraToma_nsprefix_ = child_.prefix
            # validate type indAlteraTomaType
            self.validate_indAlteraTomaType(self.indAlteraToma)
# end class infCteSubType


class tomaICMSType(GeneratedsSuper):
    """tomaICMSType -- Tomador
    é
    contribuinte do ICMS, mas n
    ã
    o
    é
    emitente de documento fiscal eletr
    ô
    nico
    refNFe -- Chave de acesso da NF-e emitida pelo Tomador
    refNF -- Informa
    ç
    ã
    o da NF ou CT emitido pelo Tomador
    refCte -- Chave de acesso do CT-e emitido pelo Tomador
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refNFe=None, refNF=None, refCte=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refNFe = refNFe
        self.validate_TChNFe(self.refNFe)
        self.refNFe_nsprefix_ = None
        self.refNF = refNF
        self.refNF_nsprefix_ = None
        self.refCte = refCte
        self.validate_TChNFe(self.refCte)
        self.refCte_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tomaICMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tomaICMSType.subclass:
            return tomaICMSType.subclass(*args_, **kwargs_)
        else:
            return tomaICMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refNFe(self):
        return self.refNFe
    def set_refNFe(self, refNFe):
        self.refNFe = refNFe
    def get_refNF(self):
        return self.refNF
    def set_refNF(self, refNF):
        self.refNF = refNF
    def get_refCte(self):
        return self.refCte
    def set_refCte(self, refCte):
        self.refCte = refCte
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.refNFe is not None or
            self.refNF is not None or
            self.refCte is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaICMSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tomaICMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tomaICMSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tomaICMSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tomaICMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tomaICMSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaICMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.refNFe is not None:
            namespaceprefix_ = self.refNFe_nsprefix_ + ':' if (UseCapturedNS_ and self.refNFe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefNFe>%s</%srefNFe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refNFe), input_name='refNFe')), namespaceprefix_ , eol_))
        if self.refNF is not None:
            namespaceprefix_ = self.refNF_nsprefix_ + ':' if (UseCapturedNS_ and self.refNF_nsprefix_) else ''
            self.refNF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='refNF', pretty_print=pretty_print)
        if self.refCte is not None:
            namespaceprefix_ = self.refCte_nsprefix_ + ':' if (UseCapturedNS_ and self.refCte_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefCte>%s</%srefCte>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refCte), input_name='refCte')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refNFe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refNFe')
            value_ = self.gds_validate_string(value_, node, 'refNFe')
            self.refNFe = value_
            self.refNFe_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.refNFe)
        elif nodeName_ == 'refNF':
            obj_ = refNFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.refNF = obj_
            obj_.original_tagname_ = 'refNF'
        elif nodeName_ == 'refCte':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refCte')
            value_ = self.gds_validate_string(value_, node, 'refCte')
            self.refCte = value_
            self.refCte_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.refCte)
# end class tomaICMSType


class refNFType(GeneratedsSuper):
    """refNFType -- Informa
    ç
    ã
    o da NF ou CT emitido pelo Tomador
    CNPJ -- CNPJ do Emitente
    Informar o CNPJ do emitente do Documento Fiscal
    CPF -- N
    ú
    mero do CPF
    Informar o CPF do emitente do documento fiscal
    mod -- Modelo do Documento Fiscal
    serie -- Serie do documento fiscal
    subserie -- Subserie do documento fiscal
    nro -- N
    ú
    mero do documento fiscal
    valor -- Valor do documento fiscal.
    dEmi -- Data de emiss
    ã
    o do documento fiscal.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, mod=None, serie=None, subserie=None, nro=None, valor=None, dEmi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.mod = mod
        self.validate_TModDoc(self.mod)
        self.mod_nsprefix_ = None
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.serie_nsprefix_ = None
        self.subserie = subserie
        self.validate_TSerie(self.subserie)
        self.subserie_nsprefix_ = None
        self.nro = nro
        self.validate_nroType(self.nro)
        self.nro_nsprefix_ = None
        self.valor = valor
        self.validate_TDec_1302(self.valor)
        self.valor_nsprefix_ = None
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.dEmi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNFType.subclass:
            return refNFType.subclass(*args_, **kwargs_)
        else:
            return refNFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_subserie(self):
        return self.subserie
    def set_subserie(self, subserie):
        self.subserie = subserie
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_valor(self):
        return self.valor
    def set_valor(self, valor):
        self.valor = valor
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_TModDoc(self, value):
        result = True
        # Validate type TModDoc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['01', '1B', '02', '2D', '2E', '04', '06', '07', '08', '8B', '09', '10', '11', '13', '14', '15', '16', '17', '18', '20', '21', '22', '23', '24', '25', '26', '27', '28', '55']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TModDoc' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TSerie(self, value):
        result = True
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TSerie_patterns_, ))
                result = False
        return result
    validate_TSerie_patterns_ = [['^(0|[1-9]{1}[0-9]{0,2})$']]
    def validate_nroType(self, value):
        result = True
        # Validate type nroType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nroType_patterns_, ))
                result = False
        return result
    validate_nroType_patterns_ = [['^([0-9]{1,6})$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.mod is not None or
            self.serie is not None or
            self.subserie is not None or
            self.nro is not None or
            self.valor is not None or
            self.dEmi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='refNFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'refNFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='refNFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='refNFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='refNFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='refNFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.mod is not None:
            namespaceprefix_ = self.mod_nsprefix_ + ':' if (UseCapturedNS_ and self.mod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            namespaceprefix_ = self.serie_nsprefix_ + ':' if (UseCapturedNS_ and self.serie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.subserie is not None:
            namespaceprefix_ = self.subserie_nsprefix_ + ':' if (UseCapturedNS_ and self.subserie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubserie>%s</%ssubserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subserie), input_name='subserie')), namespaceprefix_ , eol_))
        if self.nro is not None:
            namespaceprefix_ = self.nro_nsprefix_ + ':' if (UseCapturedNS_ and self.nro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.valor is not None:
            namespaceprefix_ = self.valor_nsprefix_ + ':' if (UseCapturedNS_ and self.valor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalor>%s</%svalor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.valor), input_name='valor')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            namespaceprefix_ = self.dEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'mod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mod')
            value_ = self.gds_validate_string(value_, node, 'mod')
            self.mod = value_
            self.mod_nsprefix_ = child_.prefix
            # validate type TModDoc
            self.validate_TModDoc(self.mod)
        elif nodeName_ == 'serie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serie')
            value_ = self.gds_validate_string(value_, node, 'serie')
            self.serie = value_
            self.serie_nsprefix_ = child_.prefix
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'subserie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subserie')
            value_ = self.gds_validate_string(value_, node, 'subserie')
            self.subserie = value_
            self.subserie_nsprefix_ = child_.prefix
            # validate type TSerie
            self.validate_TSerie(self.subserie)
        elif nodeName_ == 'nro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nro')
            value_ = self.gds_validate_string(value_, node, 'nro')
            self.nro = value_
            self.nro_nsprefix_ = child_.prefix
            # validate type nroType
            self.validate_nroType(self.nro)
        elif nodeName_ == 'valor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'valor')
            value_ = self.gds_validate_string(value_, node, 'valor')
            self.valor = value_
            self.valor_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.valor)
        elif nodeName_ == 'dEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dEmi')
            value_ = self.gds_validate_string(value_, node, 'dEmi')
            self.dEmi = value_
            self.dEmi_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dEmi)
# end class refNFType


class infGlobalizadoType(GeneratedsSuper):
    """infGlobalizadoType -- Informa
    ç
    õ
    es do CT-e Globalizado
    xObs -- Preencher com informa
    ç
    õ
    es adicionais, legisla
    ç
    ã
    o do regime especial, etc
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xObs=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xObs = xObs
        self.validate_xObsType85(self.xObs)
        self.xObs_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infGlobalizadoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infGlobalizadoType.subclass:
            return infGlobalizadoType.subclass(*args_, **kwargs_)
        else:
            return infGlobalizadoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xObs(self):
        return self.xObs
    def set_xObs(self, xObs):
        self.xObs = xObs
    def validate_xObsType85(self, value):
        result = True
        # Validate type xObsType85, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xObsType85' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xObsType85' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xObsType85_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xObsType85_patterns_, ))
                result = False
        return result
    validate_xObsType85_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xObs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infGlobalizadoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infGlobalizadoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infGlobalizadoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infGlobalizadoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infGlobalizadoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infGlobalizadoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infGlobalizadoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xObs is not None:
            namespaceprefix_ = self.xObs_nsprefix_ + ':' if (UseCapturedNS_ and self.xObs_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxObs>%s</%sxObs>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xObs), input_name='xObs')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xObs':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xObs')
            value_ = self.gds_validate_string(value_, node, 'xObs')
            self.xObs = value_
            self.xObs_nsprefix_ = child_.prefix
            # validate type xObsType85
            self.validate_xObsType85(self.xObs)
# end class infGlobalizadoType


class infServVincType(GeneratedsSuper):
    """infServVincType -- Informa
    ç
    õ
    es do Servi
    ç
    o Vinculado a Multimodal
    infCTeMultimodal -- informa
    ç
    õ
    es do CT-e multimodal vinculado
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, infCTeMultimodal=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if infCTeMultimodal is None:
            self.infCTeMultimodal = []
        else:
            self.infCTeMultimodal = infCTeMultimodal
        self.infCTeMultimodal_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infServVincType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infServVincType.subclass:
            return infServVincType.subclass(*args_, **kwargs_)
        else:
            return infServVincType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infCTeMultimodal(self):
        return self.infCTeMultimodal
    def set_infCTeMultimodal(self, infCTeMultimodal):
        self.infCTeMultimodal = infCTeMultimodal
    def add_infCTeMultimodal(self, value):
        self.infCTeMultimodal.append(value)
    def insert_infCTeMultimodal_at(self, index, value):
        self.infCTeMultimodal.insert(index, value)
    def replace_infCTeMultimodal_at(self, index, value):
        self.infCTeMultimodal[index] = value
    def _hasContent(self):
        if (
            self.infCTeMultimodal
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infServVincType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infServVincType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infServVincType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infServVincType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infServVincType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infServVincType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infServVincType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for infCTeMultimodal_ in self.infCTeMultimodal:
            namespaceprefix_ = self.infCTeMultimodal_nsprefix_ + ':' if (UseCapturedNS_ and self.infCTeMultimodal_nsprefix_) else ''
            infCTeMultimodal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCTeMultimodal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infCTeMultimodal':
            obj_ = infCTeMultimodalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCTeMultimodal.append(obj_)
            obj_.original_tagname_ = 'infCTeMultimodal'
# end class infServVincType


class infCTeMultimodalType(GeneratedsSuper):
    """infCTeMultimodalType -- informa
    ç
    õ
    es do CT-e multimodal vinculado
    chCTeMultimodal -- Chave de acesso do CT-e Multimodal
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCTeMultimodal=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCTeMultimodal = chCTeMultimodal
        self.validate_TChNFe(self.chCTeMultimodal)
        self.chCTeMultimodal_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeMultimodalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeMultimodalType.subclass:
            return infCTeMultimodalType.subclass(*args_, **kwargs_)
        else:
            return infCTeMultimodalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCTeMultimodal(self):
        return self.chCTeMultimodal
    def set_chCTeMultimodal(self, chCTeMultimodal):
        self.chCTeMultimodal = chCTeMultimodal
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.chCTeMultimodal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeMultimodalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeMultimodalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCTeMultimodalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCTeMultimodalType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCTeMultimodalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCTeMultimodalType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeMultimodalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTeMultimodal is not None:
            namespaceprefix_ = self.chCTeMultimodal_nsprefix_ + ':' if (UseCapturedNS_ and self.chCTeMultimodal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTeMultimodal>%s</%schCTeMultimodal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCTeMultimodal), input_name='chCTeMultimodal')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCTeMultimodal':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCTeMultimodal')
            value_ = self.gds_validate_string(value_, node, 'chCTeMultimodal')
            self.chCTeMultimodal = value_
            self.chCTeMultimodal_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.chCTeMultimodal)
# end class infCTeMultimodalType


class infCteCompType(GeneratedsSuper):
    """infCteCompType -- Detalhamento do CT-e complementado
    chCTe -- Chave do CT-e complementado
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCTe = chCTe
        self.validate_TChNFe(self.chCTe)
        self.chCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteCompType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteCompType.subclass:
            return infCteCompType.subclass(*args_, **kwargs_)
        else:
            return infCteCompType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCTe(self):
        return self.chCTe
    def set_chCTe(self, chCTe):
        self.chCTe = chCTe
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.chCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteCompType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteCompType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteCompType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteCompType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteCompType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteCompType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteCompType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTe is not None:
            namespaceprefix_ = self.chCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.chCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCTe')
            value_ = self.gds_validate_string(value_, node, 'chCTe')
            self.chCTe = value_
            self.chCTe_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.chCTe)
# end class infCteCompType


class infCteAnuType(GeneratedsSuper):
    """infCteAnuType -- Detalhamento do CT-e do tipo Anula
    ç
    ã
    o
    chCte -- Chave de acesso do CT-e original a ser anulado e substitu
    í
    do
    dEmi -- Data de emiss
    ã
    o da declara
    ç
    ã
    o do tomador n
    ã
    o contribuinte do ICMS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCte=None, dEmi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCte = chCte
        self.validate_chCteType86(self.chCte)
        self.chCte_nsprefix_ = None
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.dEmi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteAnuType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteAnuType.subclass:
            return infCteAnuType.subclass(*args_, **kwargs_)
        else:
            return infCteAnuType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCte(self):
        return self.chCte
    def set_chCte(self, chCte):
        self.chCte = chCte
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def validate_chCteType86(self, value):
        result = True
        # Validate type chCteType86, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_chCteType86_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_chCteType86_patterns_, ))
                result = False
        return result
    validate_chCteType86_patterns_ = [['^([0-9]{44})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def _hasContent(self):
        if (
            self.chCte is not None or
            self.dEmi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteAnuType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteAnuType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteAnuType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteAnuType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteAnuType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteAnuType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteAnuType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCte is not None:
            namespaceprefix_ = self.chCte_nsprefix_ + ':' if (UseCapturedNS_ and self.chCte_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCte>%s</%schCte>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCte), input_name='chCte')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            namespaceprefix_ = self.dEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCte':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCte')
            value_ = self.gds_validate_string(value_, node, 'chCte')
            self.chCte = value_
            self.chCte_nsprefix_ = child_.prefix
            # validate type chCteType86
            self.validate_chCteType86(self.chCte)
        elif nodeName_ == 'dEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dEmi')
            value_ = self.gds_validate_string(value_, node, 'dEmi')
            self.dEmi = value_
            self.dEmi_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dEmi)
# end class infCteAnuType


class autXMLType87(GeneratedsSuper):
    """autXMLType87 -- Autorizados para download do XML do DF-e
    Informar CNPJ ou CPF. Preencher os zeros n
    ã
    o significativos.
    CNPJ -- CNPJ do autorizado
    Informar zeros n
    ã
    o significativos
    CPF -- CPF do autorizado
    Informar zeros n
    ã
    o significativos
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXMLType87)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXMLType87.subclass:
            return autXMLType87.subclass(*args_, **kwargs_)
        else:
            return autXMLType87(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='autXMLType87', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXMLType87')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'autXMLType87':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='autXMLType87')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='autXMLType87', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='autXMLType87'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='autXMLType87', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class autXMLType87


class infSolicNFFType(GeneratedsSuper):
    """infSolicNFFType -- Grupo de informa
    ç
    õ
    es do pedido de emiss
    ã
    o da Nota Fiscal F
    á
    cil
    xSolic -- Solicita
    ç
    ã
    o do pedido de emiss
    ã
    o da NFF.
    Ser
    á
    preenchido com a totalidade de campos informados no aplicativo emissor serializado.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xSolic=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xSolic = xSolic
        self.validate_xSolicType(self.xSolic)
        self.xSolic_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infSolicNFFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infSolicNFFType.subclass:
            return infSolicNFFType.subclass(*args_, **kwargs_)
        else:
            return infSolicNFFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xSolic(self):
        return self.xSolic
    def set_xSolic(self, xSolic):
        self.xSolic = xSolic
    def validate_xSolicType(self, value):
        result = True
        # Validate type xSolicType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xSolicType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xSolicType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xSolicType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xSolicType_patterns_, ))
                result = False
        return result
    validate_xSolicType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xSolic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infSolicNFFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infSolicNFFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infSolicNFFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infSolicNFFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infSolicNFFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infSolicNFFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infSolicNFFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xSolic is not None:
            namespaceprefix_ = self.xSolic_nsprefix_ + ':' if (UseCapturedNS_ and self.xSolic_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxSolic>%s</%sxSolic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xSolic), input_name='xSolic')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xSolic':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xSolic')
            value_ = self.gds_validate_string(value_, node, 'xSolic')
            self.xSolic = value_
            self.xSolic_nsprefix_ = child_.prefix
            # validate type xSolicType
            self.validate_xSolicType(self.xSolic)
# end class infSolicNFFType


class infCTeSuplType90(GeneratedsSuper):
    """infCTeSuplType90 -- Informa
    ç
    õ
    es suplementares do CT-e
    qrCodCTe -- Texto com o QR-Code impresso no DACTE
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, qrCodCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.qrCodCTe = qrCodCTe
        self.validate_qrCodCTeType91(self.qrCodCTe)
        self.qrCodCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeSuplType90)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeSuplType90.subclass:
            return infCTeSuplType90.subclass(*args_, **kwargs_)
        else:
            return infCTeSuplType90(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qrCodCTe(self):
        return self.qrCodCTe
    def set_qrCodCTe(self, qrCodCTe):
        self.qrCodCTe = qrCodCTe
    def validate_qrCodCTeType91(self, value):
        result = True
        # Validate type qrCodCTeType91, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on qrCodCTeType91' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on qrCodCTeType91' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_qrCodCTeType91_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_qrCodCTeType91_patterns_, ))
                result = False
        return result
    validate_qrCodCTeType91_patterns_ = [['^(((HTTPS?|https?)://.*\\?chCTe=[0-9]{44}&tpAmb=[1-2](&sign=[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})?))$']]
    def _hasContent(self):
        if (
            self.qrCodCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeSuplType90', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeSuplType90')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCTeSuplType90':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCTeSuplType90')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCTeSuplType90', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCTeSuplType90'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeSuplType90', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qrCodCTe is not None:
            namespaceprefix_ = self.qrCodCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.qrCodCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqrCodCTe>%s</%sqrCodCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qrCodCTe), input_name='qrCodCTe')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'qrCodCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qrCodCTe')
            value_ = self.gds_validate_string(value_, node, 'qrCodCTe')
            self.qrCodCTe = value_
            self.qrCodCTe_nsprefix_ = child_.prefix
            # validate type qrCodCTeType91
            self.validate_qrCodCTeType91(self.qrCodCTe)
# end class infCTeSuplType90


class infCteType92(GeneratedsSuper):
    """infCteType92 -- Informa
    ç
    õ
    es do CT-e Outros Servi
    ç
    os
    versao -- Vers
    ã
    o do leiaute
    Ex: "3.00"
    Id -- Identificador da tag a ser assinada
    Informar a chave de acesso do CT-e OS e precedida do literal "CTe"
    ide -- Identifica
    ç
    ã
    o do CT-e Outros Servi
    ç
    os
    compl -- Dados complementares do CT-e para fins operacionais ou comerciais
    emit -- Identifica
    ç
    ã
    o do Emitente do CT-e OS
    toma -- Informa
    ç
    õ
    es do Tomador/Usu
    á
    rio do Servi
    ç
    o
    Opcional para Excesso de Bagagem
    vPrest -- Valores da Presta
    ç
    ã
    o de Servi
    ç
    o
    imp -- Informa
    ç
    õ
    es relativas aos Impostos
    infCTeNorm -- Grupo de informa
    ç
    õ
    es do CT-e OS Normal
    infCteComp -- Detalhamento do CT-e complementado
    infCteAnu -- Detalhamento do CT-e do tipo Anula
    ç
    ã
    o
    autXML -- Autorizados para download do XML do DF-e
    Informar CNPJ ou CPF. Preencher os zeros n
    ã
    o significativos.
    infRespTec -- Informa
    ç
    õ
    es do Respons
    á
    vel T
    é
    cnico pela emiss
    ã
    o do DF-e
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versao=None, Id=None, ide=None, compl=None, emit=None, toma=None, vPrest=None, imp=None, infCTeNorm=None, infCteComp=None, infCteAnu=None, autXML=None, infRespTec=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versao = _cast(None, versao)
        self.versao_nsprefix_ = None
        self.Id = _cast(None, Id)
        self.Id_nsprefix_ = None
        self.ide = ide
        self.ide_nsprefix_ = None
        self.compl = compl
        self.compl_nsprefix_ = None
        self.emit = emit
        self.emit_nsprefix_ = None
        self.toma = toma
        self.toma_nsprefix_ = None
        self.vPrest = vPrest
        self.vPrest_nsprefix_ = None
        self.imp = imp
        self.imp_nsprefix_ = None
        self.infCTeNorm = infCTeNorm
        self.infCTeNorm_nsprefix_ = None
        self.infCteComp = infCteComp
        self.infCteComp_nsprefix_ = None
        self.infCteAnu = infCteAnu
        self.infCteAnu_nsprefix_ = None
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
        self.autXML_nsprefix_ = None
        self.infRespTec = infRespTec
        self.infRespTec_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteType92)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteType92.subclass:
            return infCteType92.subclass(*args_, **kwargs_)
        else:
            return infCteType92(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ide(self):
        return self.ide
    def set_ide(self, ide):
        self.ide = ide
    def get_compl(self):
        return self.compl
    def set_compl(self, compl):
        self.compl = compl
    def get_emit(self):
        return self.emit
    def set_emit(self, emit):
        self.emit = emit
    def get_toma(self):
        return self.toma
    def set_toma(self, toma):
        self.toma = toma
    def get_vPrest(self):
        return self.vPrest
    def set_vPrest(self, vPrest):
        self.vPrest = vPrest
    def get_imp(self):
        return self.imp
    def set_imp(self, imp):
        self.imp = imp
    def get_infCTeNorm(self):
        return self.infCTeNorm
    def set_infCTeNorm(self, infCTeNorm):
        self.infCTeNorm = infCTeNorm
    def get_infCteComp(self):
        return self.infCteComp
    def set_infCteComp(self, infCteComp):
        self.infCteComp = infCteComp
    def get_infCteAnu(self):
        return self.infCteAnu
    def set_infCteAnu(self, infCteAnu):
        self.infCteAnu = infCteAnu
    def get_autXML(self):
        return self.autXML
    def set_autXML(self, autXML):
        self.autXML = autXML
    def add_autXML(self, value):
        self.autXML.append(value)
    def insert_autXML_at(self, index, value):
        self.autXML.insert(index, value)
    def replace_autXML_at(self, index, value):
        self.autXML[index] = value
    def get_infRespTec(self):
        return self.infRespTec
    def set_infRespTec(self, infRespTec):
        self.infRespTec = infRespTec
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_versaoType157(self, value):
        # Validate type versaoType157, a restriction on TVerCTe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoType157_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoType157_patterns_, ))
    validate_versaoType157_patterns_ = [['^(3\\.00)$']]
    def validate_IdType158(self, value):
        # Validate type IdType158, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType158_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IdType158_patterns_, ))
    validate_IdType158_patterns_ = [['^(CTe[0-9]{44})$']]
    def _hasContent(self):
        if (
            self.ide is not None or
            self.compl is not None or
            self.emit is not None or
            self.toma is not None or
            self.vPrest is not None or
            self.imp is not None or
            self.infCTeNorm is not None or
            self.infCteComp is not None or
            self.infCteAnu is not None or
            self.autXML or
            self.infRespTec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteType92', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteType92')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteType92':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteType92')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteType92', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteType92'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteType92', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            namespaceprefix_ = self.ide_nsprefix_ + ':' if (UseCapturedNS_ and self.ide_nsprefix_) else ''
            self.ide.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ide', pretty_print=pretty_print)
        if self.compl is not None:
            namespaceprefix_ = self.compl_nsprefix_ + ':' if (UseCapturedNS_ and self.compl_nsprefix_) else ''
            self.compl.export(outfile, level, namespaceprefix_, namespacedef_='', name_='compl', pretty_print=pretty_print)
        if self.emit is not None:
            namespaceprefix_ = self.emit_nsprefix_ + ':' if (UseCapturedNS_ and self.emit_nsprefix_) else ''
            self.emit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emit', pretty_print=pretty_print)
        if self.toma is not None:
            namespaceprefix_ = self.toma_nsprefix_ + ':' if (UseCapturedNS_ and self.toma_nsprefix_) else ''
            self.toma.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toma', pretty_print=pretty_print)
        if self.vPrest is not None:
            namespaceprefix_ = self.vPrest_nsprefix_ + ':' if (UseCapturedNS_ and self.vPrest_nsprefix_) else ''
            self.vPrest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vPrest', pretty_print=pretty_print)
        if self.imp is not None:
            namespaceprefix_ = self.imp_nsprefix_ + ':' if (UseCapturedNS_ and self.imp_nsprefix_) else ''
            self.imp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='imp', pretty_print=pretty_print)
        if self.infCTeNorm is not None:
            namespaceprefix_ = self.infCTeNorm_nsprefix_ + ':' if (UseCapturedNS_ and self.infCTeNorm_nsprefix_) else ''
            self.infCTeNorm.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCTeNorm', pretty_print=pretty_print)
        if self.infCteComp is not None:
            namespaceprefix_ = self.infCteComp_nsprefix_ + ':' if (UseCapturedNS_ and self.infCteComp_nsprefix_) else ''
            self.infCteComp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCteComp', pretty_print=pretty_print)
        if self.infCteAnu is not None:
            namespaceprefix_ = self.infCteAnu_nsprefix_ + ':' if (UseCapturedNS_ and self.infCteAnu_nsprefix_) else ''
            self.infCteAnu.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCteAnu', pretty_print=pretty_print)
        for autXML_ in self.autXML:
            namespaceprefix_ = self.autXML_nsprefix_ + ':' if (UseCapturedNS_ and self.autXML_nsprefix_) else ''
            autXML_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='autXML', pretty_print=pretty_print)
        if self.infRespTec is not None:
            namespaceprefix_ = self.infRespTec_nsprefix_ + ':' if (UseCapturedNS_ and self.infRespTec_nsprefix_) else ''
            self.infRespTec.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infRespTec', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_versaoType157(self.versao)    # validate type versaoType157
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
            self.validate_IdType158(self.Id)    # validate type IdType158
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ide':
            obj_ = ideType93.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'compl':
            obj_ = complType108.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.compl = obj_
            obj_.original_tagname_ = 'compl'
        elif nodeName_ == 'emit':
            obj_ = emitType119.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'toma':
            obj_ = tomaType124.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toma = obj_
            obj_.original_tagname_ = 'toma'
        elif nodeName_ == 'vPrest':
            obj_ = vPrestType129.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vPrest = obj_
            obj_.original_tagname_ = 'vPrest'
        elif nodeName_ == 'imp':
            obj_ = impType132.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imp = obj_
            obj_.original_tagname_ = 'imp'
        elif nodeName_ == 'infCTeNorm':
            obj_ = infCTeNormType135.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCTeNorm = obj_
            obj_.original_tagname_ = 'infCTeNorm'
        elif nodeName_ == 'infCteComp':
            obj_ = infCteCompType153.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCteComp = obj_
            obj_.original_tagname_ = 'infCteComp'
        elif nodeName_ == 'infCteAnu':
            obj_ = infCteAnuType154.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCteAnu = obj_
            obj_.original_tagname_ = 'infCteAnu'
        elif nodeName_ == 'autXML':
            obj_ = autXMLType156.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
        elif nodeName_ == 'infRespTec':
            obj_ = TRespTec.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infRespTec = obj_
            obj_.original_tagname_ = 'infRespTec'
# end class infCteType92


class ideType93(GeneratedsSuper):
    """ideType93 -- Identifica
    ç
    ã
    o do CT-e Outros Servi
    ç
    os
    Informar apenas
    para tpEmis diferente de 1
    cUF -- C
    ó
    digo da UF do emitente do CT-e.
    Utilizar a Tabela do IBGE.
    cCT -- C
    ó
    digo num
    é
    rico que comp
    õ
    e a Chave de Acesso.
    N
    ú
    mero aleat
    ó
    rio gerado pelo emitente para cada CT-e, com o objetivo de evitar acessos indevidos ao documento.
    CFOP -- C
    ó
    digo Fiscal de Opera
    ç
    õ
    es e Presta
    ç
    õ
    es
    natOp -- Natureza da Opera
    ç
    ã
    o
    mod -- Modelo do documento fiscal
    Utilizar o c
    ó
    digo 67 para identifica
    ç
    ã
    o do CT-e Outros Servi
    ç
    os, emitido em substitui
    ç
    ã
    o a Nota Fiscal Modelo 7 para transporte de pessoas, valores e excesso de bagagem.
    serie -- S
    é
    rie do CT-e OS
    Preencher com "0" no caso de s
    é
    rie
    ú
    nica
    nCT -- N
    ú
    mero do CT-e OS
    dhEmi -- Data e hora de emiss
    ã
    o do CT-e OS
    Formato AAAA-MM-DDTHH:MM:DD TZD
    tpImp -- Formato de impress
    ã
    o do DACTE OS
    Preencher com: 1 - Retrato; 2 - Paisagem.
    tpEmis -- Forma de emiss
    ã
    o do CT-e
    Preencher com:
    1 - Normal;
    5 - Conting
    ê
    ncia FSDA;
    7 - Autoriza
    ç
    ã
    o pela SVC-RS;
    8 - Autoriza
    ç
    ã
    o pela SVC-SP
    cDV -- Digito Verificador da chave de acesso do CT-e
    Informar o d
    í
    gito  de controle da chave de acesso do CT-e, que deve ser calculado com a aplica
    ç
    ã
    o do algoritmo m
    ó
    dulo 11 (base 2,9) da chave de acesso.
    tpAmb -- Tipo do Ambiente
    Preencher com:1 - Produ
    ç
    ã
    o; 2 - Homologa
    ç
    ã
    o
    tpCTe -- Tipo do CT-e OS
    Preencher com:
    0 - CT-e Normal;
    1 - CT-e Complementar;
    2 - CT-e de Anula
    ç
    ã
    o;
    3 - CT-e de Substitui
    ç
    ã
    o.
    procEmi -- Identificador do processo de emiss
    ã
    o do CT-e OS
    Preencher com:
    0 - emiss
    ã
    o de CT-e com aplicativo do contribuinte;
    3- emiss
    ã
    o CT-e pelo contribuinte com aplicativo fornecido pelo Fisco.
    verProc -- Vers
    ã
    o do processo de emiss
    ã
    o
    Iinformar a vers
    ã
    o do aplicativo emissor de CT-e.
    cMunEnv -- C
    ó
    digo do Munic
    í
    pio de envio do CT-e (de onde o documento foi transmitido)
    Utilizar a tabela do IBGE. Informar 9999999 para as opera
    ç
    õ
    es com o exterior.
    xMunEnv -- Nome do Munic
    í
    pio de envio do CT-e (de onde o documento foi transmitido)
    Informar PAIS/Municipio para as opera
    ç
    õ
    es com o exterior.
    UFEnv -- Sigla da UF de envio do CT-e (de onde o documento foi transmitido)
    Informar 'EX' para opera
    ç
    õ
    es com o exterior.
    modal -- Modal do CT-e OS
    Preencher com:
    01-Rodovi
    á
    rio;
    02- A
    é
    reo;
    03 - Aquavi
    á
    rio;
    04 - Ferrovi
    á
    rio.
    tpServ -- Tipo do Servi
    ç
    o
    Preencher com:
    6 - Transporte de Pessoas;
    7 - Transporte de Valores;
    8 - Excesso de Bagagem.
    indIEToma -- Indicador da IE do tomador:
    1
    –
    Contribuinte ICMS;
    2
    –
    Contribuinte isento de inscri
    ç
    ã
    o;
    9
    –
    N
    ã
    o Contribuinte
    Aplica-se ao tomador que for indicado no toma3 ou toma4
    cMunIni -- C
    ó
    digo do Munic
    í
    pio de in
    í
    cio da presta
    ç
    ã
    o
    Utilizar a tabela do IBGE. Informar 9999999 para opera
    ç
    õ
    es com o exterior.
    xMunIni -- Nome do Munic
    í
    pio do in
    í
    cio da presta
    ç
    ã
    o
    Informar 'EXTERIOR' para opera
    ç
    õ
    es com o exterior.
    UFIni -- UF do in
    í
    cio da presta
    ç
    ã
    o
    Informar 'EX' para opera
    ç
    õ
    es com o exterior.
    cMunFim -- C
    ó
    digo do Munic
    í
    pio de t
    é
    rmino da presta
    ç
    ã
    o
    Utilizar a tabela do IBGE. Informar 9999999 para opera
    ç
    õ
    es com o exterior.
    xMunFim -- Nome do Munic
    í
    pio do t
    é
    rmino da presta
    ç
    ã
    o
    Informar 'EXTERIOR' para opera
    ç
    õ
    es com o exterior.
    UFFim -- UF do t
    é
    rmino da presta
    ç
    ã
    o
    Informar 'EX' para opera
    ç
    õ
    es com o exterior.
    infPercurso -- Informa
    ç
    õ
    es do Percurso do CT-e Outros Servi
    ç
    os
    dhCont -- Data e Hora da entrada em conting
    ê
    ncia
    Informar a data e hora no formato AAAA-MM-DDTHH:MM:SS
    xJust -- Justificativa da entrada em conting
    ê
    ncia
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, cUF=None, cCT=None, CFOP=None, natOp=None, mod=None, serie=None, nCT=None, dhEmi=None, tpImp=None, tpEmis=None, cDV=None, tpAmb=None, tpCTe=None, procEmi=None, verProc=None, cMunEnv=None, xMunEnv=None, UFEnv=None, modal=None, tpServ=None, indIEToma=None, cMunIni=None, xMunIni=None, UFIni=None, cMunFim=None, xMunFim=None, UFFim=None, infPercurso=None, dhCont=None, xJust=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cUF_nsprefix_ = None
        self.cCT = cCT
        self.validate_cCTType94(self.cCT)
        self.cCT_nsprefix_ = None
        self.CFOP = CFOP
        self.validate_TCfop(self.CFOP)
        self.CFOP_nsprefix_ = None
        self.natOp = natOp
        self.validate_natOpType95(self.natOp)
        self.natOp_nsprefix_ = None
        self.mod = mod
        self.validate_TModCTOS(self.mod)
        self.mod_nsprefix_ = None
        self.serie = serie
        self.validate_serieType96(self.serie)
        self.serie_nsprefix_ = None
        self.nCT = nCT
        self.validate_TNF(self.nCT)
        self.nCT_nsprefix_ = None
        self.dhEmi = dhEmi
        self.validate_dhEmiType97(self.dhEmi)
        self.dhEmi_nsprefix_ = None
        self.tpImp = tpImp
        self.validate_tpImpType98(self.tpImp)
        self.tpImp_nsprefix_ = None
        self.tpEmis = tpEmis
        self.validate_tpEmisType99(self.tpEmis)
        self.tpEmis_nsprefix_ = None
        self.cDV = cDV
        self.validate_cDVType100(self.cDV)
        self.cDV_nsprefix_ = None
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.tpAmb_nsprefix_ = None
        self.tpCTe = tpCTe
        self.validate_TFinCTe(self.tpCTe)
        self.tpCTe_nsprefix_ = None
        self.procEmi = procEmi
        self.validate_TProcEmi(self.procEmi)
        self.procEmi_nsprefix_ = None
        self.verProc = verProc
        self.validate_verProcType101(self.verProc)
        self.verProc_nsprefix_ = None
        self.cMunEnv = cMunEnv
        self.validate_TCodMunIBGE(self.cMunEnv)
        self.cMunEnv_nsprefix_ = None
        self.xMunEnv = xMunEnv
        self.validate_xMunEnvType102(self.xMunEnv)
        self.xMunEnv_nsprefix_ = None
        self.UFEnv = UFEnv
        self.validate_TUf(self.UFEnv)
        self.UFEnv_nsprefix_ = None
        self.modal = modal
        self.validate_TModTranspOS(self.modal)
        self.modal_nsprefix_ = None
        self.tpServ = tpServ
        self.validate_tpServType103(self.tpServ)
        self.tpServ_nsprefix_ = None
        self.indIEToma = indIEToma
        self.validate_indIETomaType104(self.indIEToma)
        self.indIEToma_nsprefix_ = None
        self.cMunIni = cMunIni
        self.validate_TCodMunIBGE(self.cMunIni)
        self.cMunIni_nsprefix_ = None
        self.xMunIni = xMunIni
        self.validate_xMunIniType105(self.xMunIni)
        self.xMunIni_nsprefix_ = None
        self.UFIni = UFIni
        self.validate_TUf(self.UFIni)
        self.UFIni_nsprefix_ = None
        self.cMunFim = cMunFim
        self.validate_TCodMunIBGE(self.cMunFim)
        self.cMunFim_nsprefix_ = None
        self.xMunFim = xMunFim
        self.validate_xMunFimType106(self.xMunFim)
        self.xMunFim_nsprefix_ = None
        self.UFFim = UFFim
        self.validate_TUf(self.UFFim)
        self.UFFim_nsprefix_ = None
        if infPercurso is None:
            self.infPercurso = []
        else:
            self.infPercurso = infPercurso
        self.infPercurso_nsprefix_ = None
        self.dhCont = dhCont
        self.validate_TDateTimeUTC(self.dhCont)
        self.dhCont_nsprefix_ = None
        self.xJust = xJust
        self.validate_xJustType107(self.xJust)
        self.xJust_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideType93)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideType93.subclass:
            return ideType93.subclass(*args_, **kwargs_)
        else:
            return ideType93(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_cCT(self):
        return self.cCT
    def set_cCT(self, cCT):
        self.cCT = cCT
    def get_CFOP(self):
        return self.CFOP
    def set_CFOP(self, CFOP):
        self.CFOP = CFOP
    def get_natOp(self):
        return self.natOp
    def set_natOp(self, natOp):
        self.natOp = natOp
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_nCT(self):
        return self.nCT
    def set_nCT(self, nCT):
        self.nCT = nCT
    def get_dhEmi(self):
        return self.dhEmi
    def set_dhEmi(self, dhEmi):
        self.dhEmi = dhEmi
    def get_tpImp(self):
        return self.tpImp
    def set_tpImp(self, tpImp):
        self.tpImp = tpImp
    def get_tpEmis(self):
        return self.tpEmis
    def set_tpEmis(self, tpEmis):
        self.tpEmis = tpEmis
    def get_cDV(self):
        return self.cDV
    def set_cDV(self, cDV):
        self.cDV = cDV
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_tpCTe(self):
        return self.tpCTe
    def set_tpCTe(self, tpCTe):
        self.tpCTe = tpCTe
    def get_procEmi(self):
        return self.procEmi
    def set_procEmi(self, procEmi):
        self.procEmi = procEmi
    def get_verProc(self):
        return self.verProc
    def set_verProc(self, verProc):
        self.verProc = verProc
    def get_cMunEnv(self):
        return self.cMunEnv
    def set_cMunEnv(self, cMunEnv):
        self.cMunEnv = cMunEnv
    def get_xMunEnv(self):
        return self.xMunEnv
    def set_xMunEnv(self, xMunEnv):
        self.xMunEnv = xMunEnv
    def get_UFEnv(self):
        return self.UFEnv
    def set_UFEnv(self, UFEnv):
        self.UFEnv = UFEnv
    def get_modal(self):
        return self.modal
    def set_modal(self, modal):
        self.modal = modal
    def get_tpServ(self):
        return self.tpServ
    def set_tpServ(self, tpServ):
        self.tpServ = tpServ
    def get_indIEToma(self):
        return self.indIEToma
    def set_indIEToma(self, indIEToma):
        self.indIEToma = indIEToma
    def get_cMunIni(self):
        return self.cMunIni
    def set_cMunIni(self, cMunIni):
        self.cMunIni = cMunIni
    def get_xMunIni(self):
        return self.xMunIni
    def set_xMunIni(self, xMunIni):
        self.xMunIni = xMunIni
    def get_UFIni(self):
        return self.UFIni
    def set_UFIni(self, UFIni):
        self.UFIni = UFIni
    def get_cMunFim(self):
        return self.cMunFim
    def set_cMunFim(self, cMunFim):
        self.cMunFim = cMunFim
    def get_xMunFim(self):
        return self.xMunFim
    def set_xMunFim(self, xMunFim):
        self.xMunFim = xMunFim
    def get_UFFim(self):
        return self.UFFim
    def set_UFFim(self, UFFim):
        self.UFFim = UFFim
    def get_infPercurso(self):
        return self.infPercurso
    def set_infPercurso(self, infPercurso):
        self.infPercurso = infPercurso
    def add_infPercurso(self, value):
        self.infPercurso.append(value)
    def insert_infPercurso_at(self, index, value):
        self.infPercurso.insert(index, value)
    def replace_infPercurso_at(self, index, value):
        self.infPercurso[index] = value
    def get_dhCont(self):
        return self.dhCont
    def set_dhCont(self, dhCont):
        self.dhCont = dhCont
    def get_xJust(self):
        return self.xJust
    def set_xJust(self, xJust):
        self.xJust = xJust
    def validate_TCodUfIBGE(self, value):
        result = True
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cCTType94(self, value):
        result = True
        # Validate type cCTType94, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cCTType94_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cCTType94_patterns_, ))
                result = False
        return result
    validate_cCTType94_patterns_ = [['^([0-9]{8})$']]
    def validate_TCfop(self, value):
        result = True
        # Validate type TCfop, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCfop_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCfop_patterns_, ))
                result = False
        return result
    validate_TCfop_patterns_ = [['^([123567][0-9]([0-9][1-9]|[1-9][0-9]))$']]
    def validate_natOpType95(self, value):
        result = True
        # Validate type natOpType95, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on natOpType95' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on natOpType95' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_natOpType95_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_natOpType95_patterns_, ))
                result = False
        return result
    validate_natOpType95_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TModCTOS(self, value):
        result = True
        # Validate type TModCTOS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['67']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TModCTOS' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_serieType96(self, value):
        result = True
        # Validate type serieType96, a restriction on TSerie.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_serieType96_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_serieType96_patterns_, ))
                result = False
        return result
    validate_serieType96_patterns_ = [['^(0|[1-9]{1}[0-9]{0,2})$']]
    def validate_TNF(self, value):
        result = True
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TNF_patterns_, ))
                result = False
        return result
    validate_TNF_patterns_ = [['^([1-9]{1}[0-9]{0,8})$']]
    def validate_dhEmiType97(self, value):
        result = True
        # Validate type dhEmiType97, a restriction on TDateTimeUTC.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_dhEmiType97_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_dhEmiType97_patterns_, ))
                result = False
        return result
    validate_dhEmiType97_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_tpImpType98(self, value):
        result = True
        # Validate type tpImpType98, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpImpType98' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tpEmisType99(self, value):
        result = True
        # Validate type tpEmisType99, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '5', '7', '8']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpEmisType99' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cDVType100(self, value):
        result = True
        # Validate type cDVType100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_cDVType100_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_cDVType100_patterns_, ))
                result = False
        return result
    validate_cDVType100_patterns_ = [['^([0-9]{1})$']]
    def validate_TAmb(self, value):
        result = True
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TAmb' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TFinCTe(self, value):
        result = True
        # Validate type TFinCTe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1', '2', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TFinCTe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TProcEmi(self, value):
        result = True
        # Validate type TProcEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TProcEmi' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_verProcType101(self, value):
        result = True
        # Validate type verProcType101, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on verProcType101' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on verProcType101' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_verProcType101_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_verProcType101_patterns_, ))
                result = False
        return result
    validate_verProcType101_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCodMunIBGE(self, value):
        result = True
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCodMunIBGE_patterns_, ))
                result = False
        return result
    validate_TCodMunIBGE_patterns_ = [['^([0-9]{7})$']]
    def validate_xMunEnvType102(self, value):
        result = True
        # Validate type xMunEnvType102, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunEnvType102' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunEnvType102' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunEnvType102_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunEnvType102_patterns_, ))
                result = False
        return result
    validate_xMunEnvType102_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TModTranspOS(self, value):
        result = True
        # Validate type TModTranspOS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['01', '02', '03', '04']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TModTranspOS' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_tpServType103(self, value):
        result = True
        # Validate type tpServType103, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['6', '7', '8']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpServType103' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_indIETomaType104(self, value):
        result = True
        # Validate type indIETomaType104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '9']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on indIETomaType104' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_xMunIniType105(self, value):
        result = True
        # Validate type xMunIniType105, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunIniType105' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunIniType105' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunIniType105_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunIniType105_patterns_, ))
                result = False
        return result
    validate_xMunIniType105_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xMunFimType106(self, value):
        result = True
        # Validate type xMunFimType106, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xMunFimType106' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xMunFimType106' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunFimType106_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xMunFimType106_patterns_, ))
                result = False
        return result
    validate_xMunFimType106_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TDateTimeUTC(self, value):
        result = True
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDateTimeUTC_patterns_, ))
                result = False
        return result
    validate_TDateTimeUTC_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_xJustType107(self, value):
        result = True
        # Validate type xJustType107, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 256:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xJustType107' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xJustType107' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xJustType107_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xJustType107_patterns_, ))
                result = False
        return result
    validate_xJustType107_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.cUF is not None or
            self.cCT is not None or
            self.CFOP is not None or
            self.natOp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nCT is not None or
            self.dhEmi is not None or
            self.tpImp is not None or
            self.tpEmis is not None or
            self.cDV is not None or
            self.tpAmb is not None or
            self.tpCTe is not None or
            self.procEmi is not None or
            self.verProc is not None or
            self.cMunEnv is not None or
            self.xMunEnv is not None or
            self.UFEnv is not None or
            self.modal is not None or
            self.tpServ is not None or
            self.indIEToma is not None or
            self.cMunIni is not None or
            self.xMunIni is not None or
            self.UFIni is not None or
            self.cMunFim is not None or
            self.xMunFim is not None or
            self.UFFim is not None or
            self.infPercurso or
            self.dhCont is not None or
            self.xJust is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ideType93', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideType93')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ideType93':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ideType93')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ideType93', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ideType93'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ideType93', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            namespaceprefix_ = self.cUF_nsprefix_ + ':' if (UseCapturedNS_ and self.cUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.cCT is not None:
            namespaceprefix_ = self.cCT_nsprefix_ + ':' if (UseCapturedNS_ and self.cCT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scCT>%s</%scCT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cCT), input_name='cCT')), namespaceprefix_ , eol_))
        if self.CFOP is not None:
            namespaceprefix_ = self.CFOP_nsprefix_ + ':' if (UseCapturedNS_ and self.CFOP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCFOP>%s</%sCFOP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CFOP), input_name='CFOP')), namespaceprefix_ , eol_))
        if self.natOp is not None:
            namespaceprefix_ = self.natOp_nsprefix_ + ':' if (UseCapturedNS_ and self.natOp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snatOp>%s</%snatOp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.natOp), input_name='natOp')), namespaceprefix_ , eol_))
        if self.mod is not None:
            namespaceprefix_ = self.mod_nsprefix_ + ':' if (UseCapturedNS_ and self.mod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            namespaceprefix_ = self.serie_nsprefix_ + ':' if (UseCapturedNS_ and self.serie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.nCT is not None:
            namespaceprefix_ = self.nCT_nsprefix_ + ':' if (UseCapturedNS_ and self.nCT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snCT>%s</%snCT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nCT), input_name='nCT')), namespaceprefix_ , eol_))
        if self.dhEmi is not None:
            namespaceprefix_ = self.dhEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dhEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhEmi>%s</%sdhEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhEmi), input_name='dhEmi')), namespaceprefix_ , eol_))
        if self.tpImp is not None:
            namespaceprefix_ = self.tpImp_nsprefix_ + ':' if (UseCapturedNS_ and self.tpImp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpImp>%s</%stpImp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpImp), input_name='tpImp')), namespaceprefix_ , eol_))
        if self.tpEmis is not None:
            namespaceprefix_ = self.tpEmis_nsprefix_ + ':' if (UseCapturedNS_ and self.tpEmis_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpEmis>%s</%stpEmis>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpEmis), input_name='tpEmis')), namespaceprefix_ , eol_))
        if self.cDV is not None:
            namespaceprefix_ = self.cDV_nsprefix_ + ':' if (UseCapturedNS_ and self.cDV_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scDV>%s</%scDV>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cDV), input_name='cDV')), namespaceprefix_ , eol_))
        if self.tpAmb is not None:
            namespaceprefix_ = self.tpAmb_nsprefix_ + ':' if (UseCapturedNS_ and self.tpAmb_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.tpCTe is not None:
            namespaceprefix_ = self.tpCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.tpCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpCTe>%s</%stpCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpCTe), input_name='tpCTe')), namespaceprefix_ , eol_))
        if self.procEmi is not None:
            namespaceprefix_ = self.procEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.procEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocEmi>%s</%sprocEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.procEmi), input_name='procEmi')), namespaceprefix_ , eol_))
        if self.verProc is not None:
            namespaceprefix_ = self.verProc_nsprefix_ + ':' if (UseCapturedNS_ and self.verProc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverProc>%s</%sverProc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), namespaceprefix_ , eol_))
        if self.cMunEnv is not None:
            namespaceprefix_ = self.cMunEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.cMunEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunEnv>%s</%scMunEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunEnv), input_name='cMunEnv')), namespaceprefix_ , eol_))
        if self.xMunEnv is not None:
            namespaceprefix_ = self.xMunEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.xMunEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMunEnv>%s</%sxMunEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMunEnv), input_name='xMunEnv')), namespaceprefix_ , eol_))
        if self.UFEnv is not None:
            namespaceprefix_ = self.UFEnv_nsprefix_ + ':' if (UseCapturedNS_ and self.UFEnv_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFEnv>%s</%sUFEnv>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFEnv), input_name='UFEnv')), namespaceprefix_ , eol_))
        if self.modal is not None:
            namespaceprefix_ = self.modal_nsprefix_ + ':' if (UseCapturedNS_ and self.modal_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodal>%s</%smodal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modal), input_name='modal')), namespaceprefix_ , eol_))
        if self.tpServ is not None:
            namespaceprefix_ = self.tpServ_nsprefix_ + ':' if (UseCapturedNS_ and self.tpServ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpServ>%s</%stpServ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpServ), input_name='tpServ')), namespaceprefix_ , eol_))
        if self.indIEToma is not None:
            namespaceprefix_ = self.indIEToma_nsprefix_ + ':' if (UseCapturedNS_ and self.indIEToma_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindIEToma>%s</%sindIEToma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indIEToma), input_name='indIEToma')), namespaceprefix_ , eol_))
        if self.cMunIni is not None:
            namespaceprefix_ = self.cMunIni_nsprefix_ + ':' if (UseCapturedNS_ and self.cMunIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunIni>%s</%scMunIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunIni), input_name='cMunIni')), namespaceprefix_ , eol_))
        if self.xMunIni is not None:
            namespaceprefix_ = self.xMunIni_nsprefix_ + ':' if (UseCapturedNS_ and self.xMunIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMunIni>%s</%sxMunIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMunIni), input_name='xMunIni')), namespaceprefix_ , eol_))
        if self.UFIni is not None:
            namespaceprefix_ = self.UFIni_nsprefix_ + ':' if (UseCapturedNS_ and self.UFIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFIni>%s</%sUFIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFIni), input_name='UFIni')), namespaceprefix_ , eol_))
        if self.cMunFim is not None:
            namespaceprefix_ = self.cMunFim_nsprefix_ + ':' if (UseCapturedNS_ and self.cMunFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunFim>%s</%scMunFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunFim), input_name='cMunFim')), namespaceprefix_ , eol_))
        if self.xMunFim is not None:
            namespaceprefix_ = self.xMunFim_nsprefix_ + ':' if (UseCapturedNS_ and self.xMunFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMunFim>%s</%sxMunFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMunFim), input_name='xMunFim')), namespaceprefix_ , eol_))
        if self.UFFim is not None:
            namespaceprefix_ = self.UFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.UFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFFim>%s</%sUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFFim), input_name='UFFim')), namespaceprefix_ , eol_))
        for infPercurso_ in self.infPercurso:
            namespaceprefix_ = self.infPercurso_nsprefix_ + ':' if (UseCapturedNS_ and self.infPercurso_nsprefix_) else ''
            infPercurso_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infPercurso', pretty_print=pretty_print)
        if self.dhCont is not None:
            namespaceprefix_ = self.dhCont_nsprefix_ + ':' if (UseCapturedNS_ and self.dhCont_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhCont>%s</%sdhCont>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhCont), input_name='dhCont')), namespaceprefix_ , eol_))
        if self.xJust is not None:
            namespaceprefix_ = self.xJust_nsprefix_ + ':' if (UseCapturedNS_ and self.xJust_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxJust>%s</%sxJust>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xJust), input_name='xJust')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cUF')
            value_ = self.gds_validate_string(value_, node, 'cUF')
            self.cUF = value_
            self.cUF_nsprefix_ = child_.prefix
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'cCT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cCT')
            value_ = self.gds_validate_string(value_, node, 'cCT')
            self.cCT = value_
            self.cCT_nsprefix_ = child_.prefix
            # validate type cCTType94
            self.validate_cCTType94(self.cCT)
        elif nodeName_ == 'CFOP':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CFOP')
            value_ = self.gds_validate_string(value_, node, 'CFOP')
            self.CFOP = value_
            self.CFOP_nsprefix_ = child_.prefix
            # validate type TCfop
            self.validate_TCfop(self.CFOP)
        elif nodeName_ == 'natOp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'natOp')
            value_ = self.gds_validate_string(value_, node, 'natOp')
            self.natOp = value_
            self.natOp_nsprefix_ = child_.prefix
            # validate type natOpType95
            self.validate_natOpType95(self.natOp)
        elif nodeName_ == 'mod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mod')
            value_ = self.gds_validate_string(value_, node, 'mod')
            self.mod = value_
            self.mod_nsprefix_ = child_.prefix
            # validate type TModCTOS
            self.validate_TModCTOS(self.mod)
        elif nodeName_ == 'serie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serie')
            value_ = self.gds_validate_string(value_, node, 'serie')
            self.serie = value_
            self.serie_nsprefix_ = child_.prefix
            # validate type serieType96
            self.validate_serieType96(self.serie)
        elif nodeName_ == 'nCT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nCT')
            value_ = self.gds_validate_string(value_, node, 'nCT')
            self.nCT = value_
            self.nCT_nsprefix_ = child_.prefix
            # validate type TNF
            self.validate_TNF(self.nCT)
        elif nodeName_ == 'dhEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhEmi')
            value_ = self.gds_validate_string(value_, node, 'dhEmi')
            self.dhEmi = value_
            self.dhEmi_nsprefix_ = child_.prefix
            # validate type dhEmiType97
            self.validate_dhEmiType97(self.dhEmi)
        elif nodeName_ == 'tpImp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpImp')
            value_ = self.gds_validate_string(value_, node, 'tpImp')
            self.tpImp = value_
            self.tpImp_nsprefix_ = child_.prefix
            # validate type tpImpType98
            self.validate_tpImpType98(self.tpImp)
        elif nodeName_ == 'tpEmis':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpEmis')
            value_ = self.gds_validate_string(value_, node, 'tpEmis')
            self.tpEmis = value_
            self.tpEmis_nsprefix_ = child_.prefix
            # validate type tpEmisType99
            self.validate_tpEmisType99(self.tpEmis)
        elif nodeName_ == 'cDV':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cDV')
            value_ = self.gds_validate_string(value_, node, 'cDV')
            self.cDV = value_
            self.cDV_nsprefix_ = child_.prefix
            # validate type cDVType100
            self.validate_cDVType100(self.cDV)
        elif nodeName_ == 'tpAmb':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpAmb')
            value_ = self.gds_validate_string(value_, node, 'tpAmb')
            self.tpAmb = value_
            self.tpAmb_nsprefix_ = child_.prefix
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'tpCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpCTe')
            value_ = self.gds_validate_string(value_, node, 'tpCTe')
            self.tpCTe = value_
            self.tpCTe_nsprefix_ = child_.prefix
            # validate type TFinCTe
            self.validate_TFinCTe(self.tpCTe)
        elif nodeName_ == 'procEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'procEmi')
            value_ = self.gds_validate_string(value_, node, 'procEmi')
            self.procEmi = value_
            self.procEmi_nsprefix_ = child_.prefix
            # validate type TProcEmi
            self.validate_TProcEmi(self.procEmi)
        elif nodeName_ == 'verProc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'verProc')
            value_ = self.gds_validate_string(value_, node, 'verProc')
            self.verProc = value_
            self.verProc_nsprefix_ = child_.prefix
            # validate type verProcType101
            self.validate_verProcType101(self.verProc)
        elif nodeName_ == 'cMunEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMunEnv')
            value_ = self.gds_validate_string(value_, node, 'cMunEnv')
            self.cMunEnv = value_
            self.cMunEnv_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunEnv)
        elif nodeName_ == 'xMunEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMunEnv')
            value_ = self.gds_validate_string(value_, node, 'xMunEnv')
            self.xMunEnv = value_
            self.xMunEnv_nsprefix_ = child_.prefix
            # validate type xMunEnvType102
            self.validate_xMunEnvType102(self.xMunEnv)
        elif nodeName_ == 'UFEnv':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UFEnv')
            value_ = self.gds_validate_string(value_, node, 'UFEnv')
            self.UFEnv = value_
            self.UFEnv_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UFEnv)
        elif nodeName_ == 'modal':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'modal')
            value_ = self.gds_validate_string(value_, node, 'modal')
            self.modal = value_
            self.modal_nsprefix_ = child_.prefix
            # validate type TModTranspOS
            self.validate_TModTranspOS(self.modal)
        elif nodeName_ == 'tpServ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpServ')
            value_ = self.gds_validate_string(value_, node, 'tpServ')
            self.tpServ = value_
            self.tpServ_nsprefix_ = child_.prefix
            # validate type tpServType103
            self.validate_tpServType103(self.tpServ)
        elif nodeName_ == 'indIEToma':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indIEToma')
            value_ = self.gds_validate_string(value_, node, 'indIEToma')
            self.indIEToma = value_
            self.indIEToma_nsprefix_ = child_.prefix
            # validate type indIETomaType104
            self.validate_indIETomaType104(self.indIEToma)
        elif nodeName_ == 'cMunIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMunIni')
            value_ = self.gds_validate_string(value_, node, 'cMunIni')
            self.cMunIni = value_
            self.cMunIni_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunIni)
        elif nodeName_ == 'xMunIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMunIni')
            value_ = self.gds_validate_string(value_, node, 'xMunIni')
            self.xMunIni = value_
            self.xMunIni_nsprefix_ = child_.prefix
            # validate type xMunIniType105
            self.validate_xMunIniType105(self.xMunIni)
        elif nodeName_ == 'UFIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UFIni')
            value_ = self.gds_validate_string(value_, node, 'UFIni')
            self.UFIni = value_
            self.UFIni_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UFIni)
        elif nodeName_ == 'cMunFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'cMunFim')
            value_ = self.gds_validate_string(value_, node, 'cMunFim')
            self.cMunFim = value_
            self.cMunFim_nsprefix_ = child_.prefix
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFim)
        elif nodeName_ == 'xMunFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xMunFim')
            value_ = self.gds_validate_string(value_, node, 'xMunFim')
            self.xMunFim = value_
            self.xMunFim_nsprefix_ = child_.prefix
            # validate type xMunFimType106
            self.validate_xMunFimType106(self.xMunFim)
        elif nodeName_ == 'UFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UFFim')
            value_ = self.gds_validate_string(value_, node, 'UFFim')
            self.UFFim = value_
            self.UFFim_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UFFim)
        elif nodeName_ == 'infPercurso':
            obj_ = infPercursoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infPercurso.append(obj_)
            obj_.original_tagname_ = 'infPercurso'
        elif nodeName_ == 'dhCont':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhCont')
            value_ = self.gds_validate_string(value_, node, 'dhCont')
            self.dhCont = value_
            self.dhCont_nsprefix_ = child_.prefix
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhCont)
        elif nodeName_ == 'xJust':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xJust')
            value_ = self.gds_validate_string(value_, node, 'xJust')
            self.xJust = value_
            self.xJust_nsprefix_ = child_.prefix
            # validate type xJustType107
            self.validate_xJustType107(self.xJust)
# end class ideType93


class infPercursoType(GeneratedsSuper):
    """infPercursoType -- Informa
    ç
    õ
    es do Percurso do CT-e Outros Servi
    ç
    os
    UFPer -- Sigla das Unidades da Federa
    ç
    ã
    o do percurso do ve
    í
    culo.
    N
    ã
    o
    é
    necess
    á
    rio repetir as UF de In
    í
    cio e Fim
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UFPer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.UFPer = UFPer
        self.validate_TUf(self.UFPer)
        self.UFPer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infPercursoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infPercursoType.subclass:
            return infPercursoType.subclass(*args_, **kwargs_)
        else:
            return infPercursoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UFPer(self):
        return self.UFPer
    def set_UFPer(self, UFPer):
        self.UFPer = UFPer
    def validate_TUf(self, value):
        result = True
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TUf' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.UFPer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infPercursoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infPercursoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infPercursoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infPercursoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infPercursoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infPercursoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infPercursoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UFPer is not None:
            namespaceprefix_ = self.UFPer_nsprefix_ + ':' if (UseCapturedNS_ and self.UFPer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFPer>%s</%sUFPer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFPer), input_name='UFPer')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UFPer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UFPer')
            value_ = self.gds_validate_string(value_, node, 'UFPer')
            self.UFPer = value_
            self.UFPer_nsprefix_ = child_.prefix
            # validate type TUf
            self.validate_TUf(self.UFPer)
# end class infPercursoType


class complType108(GeneratedsSuper):
    """complType108 -- Dados complementares do CT-e para fins operacionais ou comerciais
    xCaracAd -- Caracter
    í
    stica adicional do transporte
    Texto livre:
    REENTREGA; DEVOLU
    Ç
    Ã
    O; REFATURAMENTO; etc
    xCaracSer -- Caracter
    í
    stica adicional do servi
    ç
    o
    Texto livre:
    ENTREGA EXPRESSA; LOG
    Í
    STICA REVERSA; CONVENCIONAL; EMERGENCIAL; etc
    xEmi -- Funcion
    á
    rio emissor do CTe
    xObs -- Observa
    ç
    õ
    es Gerais
    ObsCont -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    ObsFisco -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCaracAd=None, xCaracSer=None, xEmi=None, xObs=None, ObsCont=None, ObsFisco=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCaracAd = xCaracAd
        self.validate_xCaracAdType109(self.xCaracAd)
        self.xCaracAd_nsprefix_ = None
        self.xCaracSer = xCaracSer
        self.validate_xCaracSerType110(self.xCaracSer)
        self.xCaracSer_nsprefix_ = None
        self.xEmi = xEmi
        self.validate_xEmiType111(self.xEmi)
        self.xEmi_nsprefix_ = None
        self.xObs = xObs
        self.validate_xObsType112(self.xObs)
        self.xObs_nsprefix_ = None
        if ObsCont is None:
            self.ObsCont = []
        else:
            self.ObsCont = ObsCont
        self.ObsCont_nsprefix_ = None
        if ObsFisco is None:
            self.ObsFisco = []
        else:
            self.ObsFisco = ObsFisco
        self.ObsFisco_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complType108)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complType108.subclass:
            return complType108.subclass(*args_, **kwargs_)
        else:
            return complType108(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xCaracAd(self):
        return self.xCaracAd
    def set_xCaracAd(self, xCaracAd):
        self.xCaracAd = xCaracAd
    def get_xCaracSer(self):
        return self.xCaracSer
    def set_xCaracSer(self, xCaracSer):
        self.xCaracSer = xCaracSer
    def get_xEmi(self):
        return self.xEmi
    def set_xEmi(self, xEmi):
        self.xEmi = xEmi
    def get_xObs(self):
        return self.xObs
    def set_xObs(self, xObs):
        self.xObs = xObs
    def get_ObsCont(self):
        return self.ObsCont
    def set_ObsCont(self, ObsCont):
        self.ObsCont = ObsCont
    def add_ObsCont(self, value):
        self.ObsCont.append(value)
    def insert_ObsCont_at(self, index, value):
        self.ObsCont.insert(index, value)
    def replace_ObsCont_at(self, index, value):
        self.ObsCont[index] = value
    def get_ObsFisco(self):
        return self.ObsFisco
    def set_ObsFisco(self, ObsFisco):
        self.ObsFisco = ObsFisco
    def add_ObsFisco(self, value):
        self.ObsFisco.append(value)
    def insert_ObsFisco_at(self, index, value):
        self.ObsFisco.insert(index, value)
    def replace_ObsFisco_at(self, index, value):
        self.ObsFisco[index] = value
    def validate_xCaracAdType109(self, value):
        result = True
        # Validate type xCaracAdType109, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCaracAdType109' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCaracAdType109' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCaracAdType109_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCaracAdType109_patterns_, ))
                result = False
        return result
    validate_xCaracAdType109_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCaracSerType110(self, value):
        result = True
        # Validate type xCaracSerType110, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCaracSerType110' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCaracSerType110' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCaracSerType110_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCaracSerType110_patterns_, ))
                result = False
        return result
    validate_xCaracSerType110_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xEmiType111(self, value):
        result = True
        # Validate type xEmiType111, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xEmiType111' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xEmiType111' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xEmiType111_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xEmiType111_patterns_, ))
                result = False
        return result
    validate_xEmiType111_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xObsType112(self, value):
        result = True
        # Validate type xObsType112, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xObsType112' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xObsType112' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xObsType112_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xObsType112_patterns_, ))
                result = False
        return result
    validate_xObsType112_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xCaracAd is not None or
            self.xCaracSer is not None or
            self.xEmi is not None or
            self.xObs is not None or
            self.ObsCont or
            self.ObsFisco
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='complType108', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complType108')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complType108':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complType108')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complType108', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='complType108'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='complType108', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xCaracAd is not None:
            namespaceprefix_ = self.xCaracAd_nsprefix_ + ':' if (UseCapturedNS_ and self.xCaracAd_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCaracAd>%s</%sxCaracAd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCaracAd), input_name='xCaracAd')), namespaceprefix_ , eol_))
        if self.xCaracSer is not None:
            namespaceprefix_ = self.xCaracSer_nsprefix_ + ':' if (UseCapturedNS_ and self.xCaracSer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCaracSer>%s</%sxCaracSer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCaracSer), input_name='xCaracSer')), namespaceprefix_ , eol_))
        if self.xEmi is not None:
            namespaceprefix_ = self.xEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.xEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxEmi>%s</%sxEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xEmi), input_name='xEmi')), namespaceprefix_ , eol_))
        if self.xObs is not None:
            namespaceprefix_ = self.xObs_nsprefix_ + ':' if (UseCapturedNS_ and self.xObs_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxObs>%s</%sxObs>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xObs), input_name='xObs')), namespaceprefix_ , eol_))
        for ObsCont_ in self.ObsCont:
            namespaceprefix_ = self.ObsCont_nsprefix_ + ':' if (UseCapturedNS_ and self.ObsCont_nsprefix_) else ''
            ObsCont_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObsCont', pretty_print=pretty_print)
        for ObsFisco_ in self.ObsFisco:
            namespaceprefix_ = self.ObsFisco_nsprefix_ + ':' if (UseCapturedNS_ and self.ObsFisco_nsprefix_) else ''
            ObsFisco_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObsFisco', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xCaracAd':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCaracAd')
            value_ = self.gds_validate_string(value_, node, 'xCaracAd')
            self.xCaracAd = value_
            self.xCaracAd_nsprefix_ = child_.prefix
            # validate type xCaracAdType109
            self.validate_xCaracAdType109(self.xCaracAd)
        elif nodeName_ == 'xCaracSer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xCaracSer')
            value_ = self.gds_validate_string(value_, node, 'xCaracSer')
            self.xCaracSer = value_
            self.xCaracSer_nsprefix_ = child_.prefix
            # validate type xCaracSerType110
            self.validate_xCaracSerType110(self.xCaracSer)
        elif nodeName_ == 'xEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xEmi')
            value_ = self.gds_validate_string(value_, node, 'xEmi')
            self.xEmi = value_
            self.xEmi_nsprefix_ = child_.prefix
            # validate type xEmiType111
            self.validate_xEmiType111(self.xEmi)
        elif nodeName_ == 'xObs':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xObs')
            value_ = self.gds_validate_string(value_, node, 'xObs')
            self.xObs = value_
            self.xObs_nsprefix_ = child_.prefix
            # validate type xObsType112
            self.validate_xObsType112(self.xObs)
        elif nodeName_ == 'ObsCont':
            obj_ = ObsContType113.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsCont.append(obj_)
            obj_.original_tagname_ = 'ObsCont'
        elif nodeName_ == 'ObsFisco':
            obj_ = ObsFiscoType116.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsFisco.append(obj_)
            obj_.original_tagname_ = 'ObsFisco'
# end class complType108


class ObsContType113(GeneratedsSuper):
    """ObsContType113 -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    xCampo -- Identifica
    ç
    ã
    o do campo
    xTexto -- Conte
    ú
    do do campo
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCampo = _cast(None, xCampo)
        self.xCampo_nsprefix_ = None
        self.xTexto = xTexto
        self.validate_xTextoType114(self.xTexto)
        self.xTexto_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsContType113)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsContType113.subclass:
            return ObsContType113.subclass(*args_, **kwargs_)
        else:
            return ObsContType113(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xTexto(self):
        return self.xTexto
    def set_xTexto(self, xTexto):
        self.xTexto = xTexto
    def get_xCampo(self):
        return self.xCampo
    def set_xCampo(self, xCampo):
        self.xCampo = xCampo
    def validate_xTextoType114(self, value):
        result = True
        # Validate type xTextoType114, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 160:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xTextoType114' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xTextoType114' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType114_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xTextoType114_patterns_, ))
                result = False
        return result
    validate_xTextoType114_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCampoType115(self, value):
        # Validate type xCampoType115, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCampoType115' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCampoType115' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCampoType115_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCampoType115_patterns_, ))
    validate_xCampoType115_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsContType113', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsContType113')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObsContType113':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsContType113')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsContType113', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsContType113'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsContType113', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            namespaceprefix_ = self.xTexto_nsprefix_ + ':' if (UseCapturedNS_ and self.xTexto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxTexto>%s</%sxTexto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_xCampoType115(self.xCampo)    # validate type xCampoType115
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xTexto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xTexto')
            value_ = self.gds_validate_string(value_, node, 'xTexto')
            self.xTexto = value_
            self.xTexto_nsprefix_ = child_.prefix
            # validate type xTextoType114
            self.validate_xTextoType114(self.xTexto)
# end class ObsContType113


class ObsFiscoType116(GeneratedsSuper):
    """ObsFiscoType116 -- Campo de uso livre do contribuinte
    Informar o nome do campo no atributo xCampo e o conte
    ú
    do do campo no XTexto
    xCampo -- Identifica
    ç
    ã
    o do campo
    xTexto -- Conte
    ú
    do do campo
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xCampo = _cast(None, xCampo)
        self.xCampo_nsprefix_ = None
        self.xTexto = xTexto
        self.validate_xTextoType117(self.xTexto)
        self.xTexto_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsFiscoType116)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsFiscoType116.subclass:
            return ObsFiscoType116.subclass(*args_, **kwargs_)
        else:
            return ObsFiscoType116(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xTexto(self):
        return self.xTexto
    def set_xTexto(self, xTexto):
        self.xTexto = xTexto
    def get_xCampo(self):
        return self.xCampo
    def set_xCampo(self, xCampo):
        self.xCampo = xCampo
    def validate_xTextoType117(self, value):
        result = True
        # Validate type xTextoType117, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xTextoType117' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xTextoType117' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType117_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xTextoType117_patterns_, ))
                result = False
        return result
    validate_xTextoType117_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xCampoType118(self, value):
        # Validate type xCampoType118, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCampoType118' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCampoType118' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCampoType118_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCampoType118_patterns_, ))
    validate_xCampoType118_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsFiscoType116', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsFiscoType116')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObsFiscoType116':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsFiscoType116')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsFiscoType116', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsFiscoType116'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ObsFiscoType116', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            namespaceprefix_ = self.xTexto_nsprefix_ + ':' if (UseCapturedNS_ and self.xTexto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxTexto>%s</%sxTexto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_xCampoType118(self.xCampo)    # validate type xCampoType118
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xTexto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xTexto')
            value_ = self.gds_validate_string(value_, node, 'xTexto')
            self.xTexto = value_
            self.xTexto_nsprefix_ = child_.prefix
            # validate type xTextoType117
            self.validate_xTextoType117(self.xTexto)
# end class ObsFiscoType116


class emitType119(GeneratedsSuper):
    """emitType119 -- Identifica
    ç
    ã
    o do Emitente do CT-e OS
    CNPJ -- CNPJ do emitente
    Informar zeros n
    ã
    o significativos
    IE -- Inscri
    ç
    ã
    o Estadual do Emitente
    IEST -- Inscri
    ç
    ã
    o Estadual do Substituto Tribut
    á
    rio
    xNome -- Raz
    ã
    o social ou Nome do emitente
    xFant -- Nome fantasia
    enderEmit -- Endere
    ç
    o do emitente
    CRT -- C
    ó
    digo do Regime Tribut
    á
    rio
    Informar: 1=Simples Nacional;
    2=Simples Nacional, excesso sublimite de receita bruta;
    3=Regime Normal.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, IE=None, IEST=None, xNome=None, xFant=None, enderEmit=None, CRT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.IE = IE
        self.validate_IEType120(self.IE)
        self.IE_nsprefix_ = None
        self.IEST = IEST
        self.validate_IESTType121(self.IEST)
        self.IEST_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType122(self.xNome)
        self.xNome_nsprefix_ = None
        self.xFant = xFant
        self.validate_xFantType123(self.xFant)
        self.xFant_nsprefix_ = None
        self.enderEmit = enderEmit
        self.enderEmit_nsprefix_ = None
        self.CRT = CRT
        self.validate_TCRT(self.CRT)
        self.CRT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emitType119)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emitType119.subclass:
            return emitType119.subclass(*args_, **kwargs_)
        else:
            return emitType119(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_IEST(self):
        return self.IEST
    def set_IEST(self, IEST):
        self.IEST = IEST
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_enderEmit(self):
        return self.enderEmit
    def set_enderEmit(self, enderEmit):
        self.enderEmit = enderEmit
    def get_CRT(self):
        return self.CRT
    def set_CRT(self, CRT):
        self.CRT = CRT
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_IEType120(self, value):
        result = True
        # Validate type IEType120, a restriction on TIe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType120' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType120_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType120_patterns_, ))
                result = False
        return result
    validate_IEType120_patterns_ = [['^([0-9]{2,14})$']]
    def validate_IESTType121(self, value):
        result = True
        # Validate type IESTType121, a restriction on TIe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IESTType121' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IESTType121_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IESTType121_patterns_, ))
                result = False
        return result
    validate_IESTType121_patterns_ = [['^([0-9]{2,14})$']]
    def validate_xNomeType122(self, value):
        result = True
        # Validate type xNomeType122, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType122' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType122' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType122_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType122_patterns_, ))
                result = False
        return result
    validate_xNomeType122_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xFantType123(self, value):
        result = True
        # Validate type xFantType123, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xFantType123' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xFantType123' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType123_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xFantType123_patterns_, ))
                result = False
        return result
    validate_xFantType123_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TCRT(self, value):
        result = True
        # Validate type TCRT, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TCRT' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TCRT' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on TCRT' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.IE is not None or
            self.IEST is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None or
            self.CRT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='emitType119', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emitType119')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'emitType119':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='emitType119')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='emitType119', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='emitType119'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='emitType119', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.IEST is not None:
            namespaceprefix_ = self.IEST_nsprefix_ + ':' if (UseCapturedNS_ and self.IEST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIEST>%s</%sIEST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IEST), input_name='IEST')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            namespaceprefix_ = self.xFant_nsprefix_ + ':' if (UseCapturedNS_ and self.xFant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.enderEmit is not None:
            namespaceprefix_ = self.enderEmit_nsprefix_ + ':' if (UseCapturedNS_ and self.enderEmit_nsprefix_) else ''
            self.enderEmit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderEmit', pretty_print=pretty_print)
        if self.CRT is not None:
            namespaceprefix_ = self.CRT_nsprefix_ + ':' if (UseCapturedNS_ and self.CRT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCRT>%s</%sCRT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CRT), input_name='CRT')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType120
            self.validate_IEType120(self.IE)
        elif nodeName_ == 'IEST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IEST')
            value_ = self.gds_validate_string(value_, node, 'IEST')
            self.IEST = value_
            self.IEST_nsprefix_ = child_.prefix
            # validate type IESTType121
            self.validate_IESTType121(self.IEST)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType122
            self.validate_xNomeType122(self.xNome)
        elif nodeName_ == 'xFant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xFant')
            value_ = self.gds_validate_string(value_, node, 'xFant')
            self.xFant = value_
            self.xFant_nsprefix_ = child_.prefix
            # validate type xFantType123
            self.validate_xFantType123(self.xFant)
        elif nodeName_ == 'enderEmit':
            obj_ = TEndeEmi.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
        elif nodeName_ == 'CRT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CRT')
            value_ = self.gds_validate_string(value_, node, 'CRT')
            self.CRT = value_
            self.CRT_nsprefix_ = child_.prefix
            # validate type TCRT
            self.validate_TCRT(self.CRT)
# end class emitType119


class tomaType124(GeneratedsSuper):
    """tomaType124 -- Informa
    ç
    õ
    es do Tomador/Usu
    á
    rio do Servi
    ç
    o
    Opcional para Excesso de Bagagem
    CNPJ -- N
    ú
    mero do CNPJ
    Em caso de empresa n
    ã
    o estabelecida no Brasil, ser
    á
    informado o CNPJ com zeros.
    Informar os zeros n
    ã
    o significativos.
    CPF -- N
    ú
    mero do CPF
    Informar os zeros n
    ã
    o significativos.
    IE -- Inscri
    ç
    ã
    o Estadual
    Informar a IE do tomador ou ISENTO se tomador
    é
    contribuinte do ICMS isento de inscri
    ç
    ã
    o no cadastro de contribuintes do ICMS. Caso o tomador n
    ã
    o seja contribuinte do ICMS n
    ã
    o informar o conte
    ú
    do.
    xNome -- Raz
    ã
    o social ou nome do tomador
    xFant -- Nome fantasia
    fone -- Telefone
    enderToma -- Dados do endere
    ç
    o
    email -- Endere
    ç
    o de email
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, IE=None, xNome=None, xFant=None, fone=None, enderToma=None, email=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.IE = IE
        self.validate_IEType125(self.IE)
        self.IE_nsprefix_ = None
        self.xNome = xNome
        self.validate_xNomeType126(self.xNome)
        self.xNome_nsprefix_ = None
        self.xFant = xFant
        self.validate_xFantType127(self.xFant)
        self.xFant_nsprefix_ = None
        self.fone = fone
        self.validate_TFone(self.fone)
        self.fone_nsprefix_ = None
        self.enderToma = enderToma
        self.enderToma_nsprefix_ = None
        self.email = email
        self.validate_emailType128(self.email)
        self.email_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tomaType124)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tomaType124.subclass:
            return tomaType124.subclass(*args_, **kwargs_)
        else:
            return tomaType124(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_enderToma(self):
        return self.enderToma
    def set_enderToma(self, enderToma):
        self.enderToma = enderToma
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TCnpjOpc(self, value):
        result = True
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpjOpc_patterns_, ))
                result = False
        return result
    validate_TCnpjOpc_patterns_ = [['^([0-9]{0}|[0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_IEType125(self, value):
        result = True
        # Validate type IEType125, a restriction on TIeDest.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 14:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on IEType125' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_IEType125_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_IEType125_patterns_, ))
                result = False
        return result
    validate_IEType125_patterns_ = [['^([0-9]{0,14}|ISENTO)$']]
    def validate_xNomeType126(self, value):
        result = True
        # Validate type xNomeType126, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType126' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType126' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType126_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType126_patterns_, ))
                result = False
        return result
    validate_xNomeType126_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_xFantType127(self, value):
        result = True
        # Validate type xFantType127, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xFantType127' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xFantType127' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType127_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xFantType127_patterns_, ))
                result = False
        return result
    validate_xFantType127_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TFone(self, value):
        result = True
        # Validate type TFone, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TFone_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TFone_patterns_, ))
                result = False
        return result
    validate_TFone_patterns_ = [['^([0-9]{6,14})$']]
    def validate_emailType128(self, value):
        result = True
        # Validate type emailType128, a restriction on TEmail.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on emailType128' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on emailType128' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType128_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_emailType128_patterns_, ))
                result = False
        return result
    validate_emailType128_patterns_ = [['^([^@]+@[^\\.]+\\..+)$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.fone is not None or
            self.enderToma is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaType124', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tomaType124')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tomaType124':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tomaType124')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tomaType124', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tomaType124'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaType124', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            namespaceprefix_ = self.IE_nsprefix_ + ':' if (UseCapturedNS_ and self.IE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            namespaceprefix_ = self.xFant_nsprefix_ + ':' if (UseCapturedNS_ and self.xFant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.fone is not None:
            namespaceprefix_ = self.fone_nsprefix_ + ':' if (UseCapturedNS_ and self.fone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.enderToma is not None:
            namespaceprefix_ = self.enderToma_nsprefix_ + ':' if (UseCapturedNS_ and self.enderToma_nsprefix_) else ''
            self.enderToma.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderToma', pretty_print=pretty_print)
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'IE')
            value_ = self.gds_validate_string(value_, node, 'IE')
            self.IE = value_
            self.IE_nsprefix_ = child_.prefix
            # validate type IEType125
            self.validate_IEType125(self.IE)
        elif nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType126
            self.validate_xNomeType126(self.xNome)
        elif nodeName_ == 'xFant':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xFant')
            value_ = self.gds_validate_string(value_, node, 'xFant')
            self.xFant = value_
            self.xFant_nsprefix_ = child_.prefix
            # validate type xFantType127
            self.validate_xFantType127(self.xFant)
        elif nodeName_ == 'fone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fone')
            value_ = self.gds_validate_string(value_, node, 'fone')
            self.fone = value_
            self.fone_nsprefix_ = child_.prefix
            # validate type TFone
            self.validate_TFone(self.fone)
        elif nodeName_ == 'enderToma':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enderToma = obj_
            obj_.original_tagname_ = 'enderToma'
        elif nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type emailType128
            self.validate_emailType128(self.email)
# end class tomaType124


class vPrestType129(GeneratedsSuper):
    """vPrestType129 -- Valores da Presta
    ç
    ã
    o de Servi
    ç
    o
    vTPrest -- Valor Total da Presta
    ç
    ã
    o do Servi
    ç
    o
    Pode conter zeros quando o CT-e for de complemento de ICMS
    vRec -- Valor a Receber
    Comp -- Componentes do Valor da Presta
    ç
    ã
    o
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vTPrest=None, vRec=None, Comp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vTPrest = vTPrest
        self.validate_TDec_1302(self.vTPrest)
        self.vTPrest_nsprefix_ = None
        self.vRec = vRec
        self.validate_TDec_1302(self.vRec)
        self.vRec_nsprefix_ = None
        if Comp is None:
            self.Comp = []
        else:
            self.Comp = Comp
        self.Comp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vPrestType129)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vPrestType129.subclass:
            return vPrestType129.subclass(*args_, **kwargs_)
        else:
            return vPrestType129(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vTPrest(self):
        return self.vTPrest
    def set_vTPrest(self, vTPrest):
        self.vTPrest = vTPrest
    def get_vRec(self):
        return self.vRec
    def set_vRec(self, vRec):
        self.vRec = vRec
    def get_Comp(self):
        return self.Comp
    def set_Comp(self, Comp):
        self.Comp = Comp
    def add_Comp(self, value):
        self.Comp.append(value)
    def insert_Comp_at(self, index, value):
        self.Comp.insert(index, value)
    def replace_Comp_at(self, index, value):
        self.Comp[index] = value
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.vTPrest is not None or
            self.vRec is not None or
            self.Comp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='vPrestType129', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vPrestType129')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'vPrestType129':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vPrestType129')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='vPrestType129', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vPrestType129'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='vPrestType129', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vTPrest is not None:
            namespaceprefix_ = self.vTPrest_nsprefix_ + ':' if (UseCapturedNS_ and self.vTPrest_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTPrest>%s</%svTPrest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vTPrest), input_name='vTPrest')), namespaceprefix_ , eol_))
        if self.vRec is not None:
            namespaceprefix_ = self.vRec_nsprefix_ + ':' if (UseCapturedNS_ and self.vRec_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svRec>%s</%svRec>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vRec), input_name='vRec')), namespaceprefix_ , eol_))
        for Comp_ in self.Comp:
            namespaceprefix_ = self.Comp_nsprefix_ + ':' if (UseCapturedNS_ and self.Comp_nsprefix_) else ''
            Comp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vTPrest':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vTPrest')
            value_ = self.gds_validate_string(value_, node, 'vTPrest')
            self.vTPrest = value_
            self.vTPrest_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTPrest)
        elif nodeName_ == 'vRec':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vRec')
            value_ = self.gds_validate_string(value_, node, 'vRec')
            self.vRec = value_
            self.vRec_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vRec)
        elif nodeName_ == 'Comp':
            obj_ = CompType130.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comp.append(obj_)
            obj_.original_tagname_ = 'Comp'
# end class vPrestType129


class CompType130(GeneratedsSuper):
    """CompType130 -- Componentes do Valor da Presta
    ç
    ã
    o
    xNome -- Nome do componente
    Exxemplos: FRETE PESO, FRETE VALOR, SEC/CAT, ADEME, AGENDAMENTO, etc
    vComp -- Valor do componente
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xNome=None, vComp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xNome = xNome
        self.validate_xNomeType131(self.xNome)
        self.xNome_nsprefix_ = None
        self.vComp = vComp
        self.validate_TDec_1302(self.vComp)
        self.vComp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompType130)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompType130.subclass:
            return CompType130.subclass(*args_, **kwargs_)
        else:
            return CompType130(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_vComp(self):
        return self.vComp
    def set_vComp(self, vComp):
        self.vComp = vComp
    def validate_xNomeType131(self, value):
        result = True
        # Validate type xNomeType131, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xNomeType131' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xNomeType131' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType131_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xNomeType131_patterns_, ))
                result = False
        return result
    validate_xNomeType131_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.xNome is not None or
            self.vComp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='CompType130', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompType130')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CompType130':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompType130')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompType130', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompType130'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='CompType130', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xNome is not None:
            namespaceprefix_ = self.xNome_nsprefix_ + ':' if (UseCapturedNS_ and self.xNome_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.vComp is not None:
            namespaceprefix_ = self.vComp_nsprefix_ + ':' if (UseCapturedNS_ and self.vComp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svComp>%s</%svComp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vComp), input_name='vComp')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xNome':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xNome')
            value_ = self.gds_validate_string(value_, node, 'xNome')
            self.xNome = value_
            self.xNome_nsprefix_ = child_.prefix
            # validate type xNomeType131
            self.validate_xNomeType131(self.xNome)
        elif nodeName_ == 'vComp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vComp')
            value_ = self.gds_validate_string(value_, node, 'vComp')
            self.vComp = value_
            self.vComp_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vComp)
# end class CompType130


class impType132(GeneratedsSuper):
    """impType132 -- Informa
    ç
    õ
    es relativas aos Impostos
    ICMS -- Informa
    ç
    õ
    es relativas ao ICMS
    vTotTrib -- Valor Total dos Tributos
    infAdFisco -- Informa
    ç
    õ
    es adicionais de interesse do Fisco
    Norma referenciada, informa
    ç
    õ
    es complementares, etc
    ICMSUFFim -- Informa
    ç
    õ
    es do ICMS de partilha com a UF de t
    é
    rmino do servi
    ç
    o de transporte na opera
    ç
    ã
    o interestadual
    Grupo a ser informado nas presta
    ç
    õ
    es interestaduais para consumidor final, n
    ã
    o contribuinte do ICMS
    infTribFed -- Informa
    ç
    õ
    es dos tributos federais
    Grupo a ser informado nas presta
    ç
    õ
    es interestaduais para consumidor final, n
    ã
    o contribuinte do ICMS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ICMS=None, vTotTrib=None, infAdFisco=None, ICMSUFFim=None, infTribFed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ICMS = ICMS
        self.ICMS_nsprefix_ = None
        self.vTotTrib = vTotTrib
        self.validate_TDec_1302(self.vTotTrib)
        self.vTotTrib_nsprefix_ = None
        self.infAdFisco = infAdFisco
        self.validate_infAdFiscoType133(self.infAdFisco)
        self.infAdFisco_nsprefix_ = None
        self.ICMSUFFim = ICMSUFFim
        self.ICMSUFFim_nsprefix_ = None
        self.infTribFed = infTribFed
        self.infTribFed_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, impType132)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if impType132.subclass:
            return impType132.subclass(*args_, **kwargs_)
        else:
            return impType132(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ICMS(self):
        return self.ICMS
    def set_ICMS(self, ICMS):
        self.ICMS = ICMS
    def get_vTotTrib(self):
        return self.vTotTrib
    def set_vTotTrib(self, vTotTrib):
        self.vTotTrib = vTotTrib
    def get_infAdFisco(self):
        return self.infAdFisco
    def set_infAdFisco(self, infAdFisco):
        self.infAdFisco = infAdFisco
    def get_ICMSUFFim(self):
        return self.ICMSUFFim
    def set_ICMSUFFim(self, ICMSUFFim):
        self.ICMSUFFim = ICMSUFFim
    def get_infTribFed(self):
        return self.infTribFed
    def set_infTribFed(self, infTribFed):
        self.infTribFed = infTribFed
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_infAdFiscoType133(self, value):
        result = True
        # Validate type infAdFiscoType133, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on infAdFiscoType133' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on infAdFiscoType133' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdFiscoType133_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_infAdFiscoType133_patterns_, ))
                result = False
        return result
    validate_infAdFiscoType133_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.ICMS is not None or
            self.vTotTrib is not None or
            self.infAdFisco is not None or
            self.ICMSUFFim is not None or
            self.infTribFed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='impType132', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('impType132')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'impType132':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='impType132')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='impType132', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='impType132'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='impType132', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS is not None:
            namespaceprefix_ = self.ICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMS_nsprefix_) else ''
            self.ICMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS', pretty_print=pretty_print)
        if self.vTotTrib is not None:
            namespaceprefix_ = self.vTotTrib_nsprefix_ + ':' if (UseCapturedNS_ and self.vTotTrib_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTotTrib>%s</%svTotTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vTotTrib), input_name='vTotTrib')), namespaceprefix_ , eol_))
        if self.infAdFisco is not None:
            namespaceprefix_ = self.infAdFisco_nsprefix_ + ':' if (UseCapturedNS_ and self.infAdFisco_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinfAdFisco>%s</%sinfAdFisco>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.infAdFisco), input_name='infAdFisco')), namespaceprefix_ , eol_))
        if self.ICMSUFFim is not None:
            namespaceprefix_ = self.ICMSUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.ICMSUFFim_nsprefix_) else ''
            self.ICMSUFFim.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSUFFim', pretty_print=pretty_print)
        if self.infTribFed is not None:
            namespaceprefix_ = self.infTribFed_nsprefix_ + ':' if (UseCapturedNS_ and self.infTribFed_nsprefix_) else ''
            self.infTribFed.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infTribFed', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ICMS':
            obj_ = TImpOS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMS = obj_
            obj_.original_tagname_ = 'ICMS'
        elif nodeName_ == 'vTotTrib':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vTotTrib')
            value_ = self.gds_validate_string(value_, node, 'vTotTrib')
            self.vTotTrib = value_
            self.vTotTrib_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotTrib)
        elif nodeName_ == 'infAdFisco':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'infAdFisco')
            value_ = self.gds_validate_string(value_, node, 'infAdFisco')
            self.infAdFisco = value_
            self.infAdFisco_nsprefix_ = child_.prefix
            # validate type infAdFiscoType133
            self.validate_infAdFiscoType133(self.infAdFisco)
        elif nodeName_ == 'ICMSUFFim':
            obj_ = ICMSUFFimType134.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ICMSUFFim = obj_
            obj_.original_tagname_ = 'ICMSUFFim'
        elif nodeName_ == 'infTribFed':
            obj_ = infTribFedType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infTribFed = obj_
            obj_.original_tagname_ = 'infTribFed'
# end class impType132


class ICMSUFFimType134(GeneratedsSuper):
    """ICMSUFFimType134 -- Informa
    ç
    õ
    es do ICMS de partilha com a UF de t
    é
    rmino do servi
    ç
    o de transporte na opera
    ç
    ã
    o interestadual
    Grupo a ser informado nas presta
    ç
    õ
    es interestaduais para consumidor final, n
    ã
    o contribuinte do ICMS
    vBCUFFim -- Valor da BC do ICMS na UF de t
    é
    rmino da presta
    ç
    ã
    o do servi
    ç
    o de transporte
    pFCPUFFim -- Percentual do ICMS relativo ao Fundo de Combate
    à
    pobreza (FCP) na UF de t
    é
    rmino da presta
    ç
    ã
    o do servi
    ç
    o de transporte
    Al
    í
    quota adotada nas opera
    ç
    õ
    es internas na UF do destinat
    á
    rio
    pICMSUFFim -- Al
    í
    quota interna da UF de t
    é
    rmino da presta
    ç
    ã
    o do servi
    ç
    o de transporte
    Al
    í
    quota adotada nas opera
    ç
    õ
    es internas na UF do destinat
    á
    rio
    pICMSInter -- Al
    í
    quota interestadual das UF envolvidas
    Al
    í
    quota interestadual das UF envolvidas
      
    * vFCPUFFim -- Valor do ICMS relativo ao Fundo de Combate
      á
      Pobreza (FCP) da UF de t
      é
      rmino da presta
      ç
      ã
      o
    * vICMSUFFim -- Valor do ICMS de partilha para a UF de t
      é
      rmino da presta
      ç
      ã
      o do servi
      ç
      o de transporte
    * vICMSUFIni -- Valor do ICMS de partilha para a UF de in
      í
      cio da presta
      ç
      ã
      o do servi
      ç
      o de transporte
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vBCUFFim=None, pFCPUFFim=None, pICMSUFFim=None, pICMSInter=None, vFCPUFFim=None, vICMSUFFim=None, vICMSUFIni=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vBCUFFim = vBCUFFim
        self.validate_TDec_1302(self.vBCUFFim)
        self.vBCUFFim_nsprefix_ = None
        self.pFCPUFFim = pFCPUFFim
        self.validate_TDec_0302(self.pFCPUFFim)
        self.pFCPUFFim_nsprefix_ = None
        self.pICMSUFFim = pICMSUFFim
        self.validate_TDec_0302(self.pICMSUFFim)
        self.pICMSUFFim_nsprefix_ = None
        self.pICMSInter = pICMSInter
        self.validate_TDec_0302(self.pICMSInter)
        self.pICMSInter_nsprefix_ = None
        self.vFCPUFFim = vFCPUFFim
        self.validate_TDec_1302(self.vFCPUFFim)
        self.vFCPUFFim_nsprefix_ = None
        self.vICMSUFFim = vICMSUFFim
        self.validate_TDec_1302(self.vICMSUFFim)
        self.vICMSUFFim_nsprefix_ = None
        self.vICMSUFIni = vICMSUFIni
        self.validate_TDec_1302(self.vICMSUFIni)
        self.vICMSUFIni_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSUFFimType134)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSUFFimType134.subclass:
            return ICMSUFFimType134.subclass(*args_, **kwargs_)
        else:
            return ICMSUFFimType134(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vBCUFFim(self):
        return self.vBCUFFim
    def set_vBCUFFim(self, vBCUFFim):
        self.vBCUFFim = vBCUFFim
    def get_pFCPUFFim(self):
        return self.pFCPUFFim
    def set_pFCPUFFim(self, pFCPUFFim):
        self.pFCPUFFim = pFCPUFFim
    def get_pICMSUFFim(self):
        return self.pICMSUFFim
    def set_pICMSUFFim(self, pICMSUFFim):
        self.pICMSUFFim = pICMSUFFim
    def get_pICMSInter(self):
        return self.pICMSInter
    def set_pICMSInter(self, pICMSInter):
        self.pICMSInter = pICMSInter
    def get_vFCPUFFim(self):
        return self.vFCPUFFim
    def set_vFCPUFFim(self, vFCPUFFim):
        self.vFCPUFFim = vFCPUFFim
    def get_vICMSUFFim(self):
        return self.vICMSUFFim
    def set_vICMSUFFim(self, vICMSUFFim):
        self.vICMSUFFim = vICMSUFFim
    def get_vICMSUFIni(self):
        return self.vICMSUFIni
    def set_vICMSUFIni(self, vICMSUFIni):
        self.vICMSUFIni = vICMSUFIni
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.vBCUFFim is not None or
            self.pFCPUFFim is not None or
            self.pICMSUFFim is not None or
            self.pICMSInter is not None or
            self.vFCPUFFim is not None or
            self.vICMSUFFim is not None or
            self.vICMSUFIni is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSUFFimType134', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSUFFimType134')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMSUFFimType134':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSUFFimType134')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSUFFimType134', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSUFFimType134'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSUFFimType134', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBCUFFim is not None:
            namespaceprefix_ = self.vBCUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.vBCUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCUFFim>%s</%svBCUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCUFFim), input_name='vBCUFFim')), namespaceprefix_ , eol_))
        if self.pFCPUFFim is not None:
            namespaceprefix_ = self.pFCPUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.pFCPUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPUFFim>%s</%spFCPUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPUFFim), input_name='pFCPUFFim')), namespaceprefix_ , eol_))
        if self.pICMSUFFim is not None:
            namespaceprefix_ = self.pICMSUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMSUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSUFFim>%s</%spICMSUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSUFFim), input_name='pICMSUFFim')), namespaceprefix_ , eol_))
        if self.pICMSInter is not None:
            namespaceprefix_ = self.pICMSInter_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMSInter_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSInter>%s</%spICMSInter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSInter), input_name='pICMSInter')), namespaceprefix_ , eol_))
        if self.vFCPUFFim is not None:
            namespaceprefix_ = self.vFCPUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.vFCPUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPUFFim>%s</%svFCPUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPUFFim), input_name='vFCPUFFim')), namespaceprefix_ , eol_))
        if self.vICMSUFFim is not None:
            namespaceprefix_ = self.vICMSUFFim_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMSUFFim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFFim>%s</%svICMSUFFim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFFim), input_name='vICMSUFFim')), namespaceprefix_ , eol_))
        if self.vICMSUFIni is not None:
            namespaceprefix_ = self.vICMSUFIni_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMSUFIni_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFIni>%s</%svICMSUFIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFIni), input_name='vICMSUFIni')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vBCUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBCUFFim')
            value_ = self.gds_validate_string(value_, node, 'vBCUFFim')
            self.vBCUFFim = value_
            self.vBCUFFim_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCUFFim)
        elif nodeName_ == 'pFCPUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pFCPUFFim')
            value_ = self.gds_validate_string(value_, node, 'pFCPUFFim')
            self.pFCPUFFim = value_
            self.pFCPUFFim_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pFCPUFFim)
        elif nodeName_ == 'pICMSUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMSUFFim')
            value_ = self.gds_validate_string(value_, node, 'pICMSUFFim')
            self.pICMSUFFim = value_
            self.pICMSUFFim_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMSUFFim)
        elif nodeName_ == 'pICMSInter':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMSInter')
            value_ = self.gds_validate_string(value_, node, 'pICMSInter')
            self.pICMSInter = value_
            self.pICMSInter_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMSInter)
        elif nodeName_ == 'vFCPUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vFCPUFFim')
            value_ = self.gds_validate_string(value_, node, 'vFCPUFFim')
            self.vFCPUFFim = value_
            self.vFCPUFFim_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPUFFim)
        elif nodeName_ == 'vICMSUFFim':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMSUFFim')
            value_ = self.gds_validate_string(value_, node, 'vICMSUFFim')
            self.vICMSUFFim = value_
            self.vICMSUFFim_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFFim)
        elif nodeName_ == 'vICMSUFIni':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMSUFIni')
            value_ = self.gds_validate_string(value_, node, 'vICMSUFIni')
            self.vICMSUFIni = value_
            self.vICMSUFIni_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFIni)
# end class ICMSUFFimType134


class infTribFedType(GeneratedsSuper):
    """infTribFedType -- Informa
    ç
    õ
    es dos tributos federais
    Grupo a ser informado nas presta
    ç
    õ
    es interestaduais para consumidor final, n
    ã
    o contribuinte do ICMS
    vPIS -- Valor do PIS
    vCOFINS -- Valor COFINS
    vIR -- Valor de Imposto de Renda
    vINSS -- Valor do INSS
    vCSLL -- Valor do CSLL
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vPIS=None, vCOFINS=None, vIR=None, vINSS=None, vCSLL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
        self.vPIS_nsprefix_ = None
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
        self.vCOFINS_nsprefix_ = None
        self.vIR = vIR
        self.validate_TDec_1302(self.vIR)
        self.vIR_nsprefix_ = None
        self.vINSS = vINSS
        self.validate_TDec_1302(self.vINSS)
        self.vINSS_nsprefix_ = None
        self.vCSLL = vCSLL
        self.validate_TDec_1302(self.vCSLL)
        self.vCSLL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infTribFedType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infTribFedType.subclass:
            return infTribFedType.subclass(*args_, **kwargs_)
        else:
            return infTribFedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vPIS(self):
        return self.vPIS
    def set_vPIS(self, vPIS):
        self.vPIS = vPIS
    def get_vCOFINS(self):
        return self.vCOFINS
    def set_vCOFINS(self, vCOFINS):
        self.vCOFINS = vCOFINS
    def get_vIR(self):
        return self.vIR
    def set_vIR(self, vIR):
        self.vIR = vIR
    def get_vINSS(self):
        return self.vINSS
    def set_vINSS(self, vINSS):
        self.vINSS = vINSS
    def get_vCSLL(self):
        return self.vCSLL
    def set_vCSLL(self, vCSLL):
        self.vCSLL = vCSLL
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.vPIS is not None or
            self.vCOFINS is not None or
            self.vIR is not None or
            self.vINSS is not None or
            self.vCSLL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infTribFedType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infTribFedType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infTribFedType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infTribFedType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infTribFedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infTribFedType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infTribFedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vPIS is not None:
            namespaceprefix_ = self.vPIS_nsprefix_ + ':' if (UseCapturedNS_ and self.vPIS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPIS>%s</%svPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), namespaceprefix_ , eol_))
        if self.vCOFINS is not None:
            namespaceprefix_ = self.vCOFINS_nsprefix_ + ':' if (UseCapturedNS_ and self.vCOFINS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCOFINS>%s</%svCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), namespaceprefix_ , eol_))
        if self.vIR is not None:
            namespaceprefix_ = self.vIR_nsprefix_ + ':' if (UseCapturedNS_ and self.vIR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svIR>%s</%svIR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vIR), input_name='vIR')), namespaceprefix_ , eol_))
        if self.vINSS is not None:
            namespaceprefix_ = self.vINSS_nsprefix_ + ':' if (UseCapturedNS_ and self.vINSS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svINSS>%s</%svINSS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vINSS), input_name='vINSS')), namespaceprefix_ , eol_))
        if self.vCSLL is not None:
            namespaceprefix_ = self.vCSLL_nsprefix_ + ':' if (UseCapturedNS_ and self.vCSLL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCSLL>%s</%svCSLL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCSLL), input_name='vCSLL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vPIS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vPIS')
            value_ = self.gds_validate_string(value_, node, 'vPIS')
            self.vPIS = value_
            self.vPIS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
        elif nodeName_ == 'vCOFINS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vCOFINS')
            value_ = self.gds_validate_string(value_, node, 'vCOFINS')
            self.vCOFINS = value_
            self.vCOFINS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
        elif nodeName_ == 'vIR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vIR')
            value_ = self.gds_validate_string(value_, node, 'vIR')
            self.vIR = value_
            self.vIR_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIR)
        elif nodeName_ == 'vINSS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vINSS')
            value_ = self.gds_validate_string(value_, node, 'vINSS')
            self.vINSS = value_
            self.vINSS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vINSS)
        elif nodeName_ == 'vCSLL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vCSLL')
            value_ = self.gds_validate_string(value_, node, 'vCSLL')
            self.vCSLL = value_
            self.vCSLL_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCSLL)
# end class infTribFedType


class infCTeNormType135(GeneratedsSuper):
    """infCTeNormType135 -- Grupo de informa
    ç
    õ
    es do CT-e OS Normal
    infServico -- Informa
    ç
    õ
    es da Presta
    ç
    ã
    o do Servi
    ç
    o
    infDocRef -- Informa
    ç
    õ
    es dos documentos referenciados
    seg -- Informa
    ç
    õ
    es de Seguro da Carga
    infModal -- Informa
    ç
    õ
    es do modal
    Obrigat
    ó
    rio para Pessoas e Bagagem
    infCteSub -- Informa
    ç
    õ
    es do CT-e de substitui
    ç
    ã
    o
    refCTeCanc -- Chave de acesso do CT-e Cancelado
    Somente para Transporte de Valores
    cobr -- Dados da cobran
    ç
    a do CT-e
    infGTVe -- Informa
    ç
    õ
    es das GTV-e relacionadas ao CT-e OS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, infServico=None, infDocRef=None, seg=None, infModal=None, infCteSub=None, refCTeCanc=None, cobr=None, infGTVe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.infServico = infServico
        self.infServico_nsprefix_ = None
        if infDocRef is None:
            self.infDocRef = []
        else:
            self.infDocRef = infDocRef
        self.infDocRef_nsprefix_ = None
        if seg is None:
            self.seg = []
        else:
            self.seg = seg
        self.seg_nsprefix_ = None
        self.infModal = infModal
        self.infModal_nsprefix_ = None
        self.infCteSub = infCteSub
        self.infCteSub_nsprefix_ = None
        self.refCTeCanc = refCTeCanc
        self.validate_refCTeCancType(self.refCTeCanc)
        self.refCTeCanc_nsprefix_ = None
        self.cobr = cobr
        self.cobr_nsprefix_ = None
        if infGTVe is None:
            self.infGTVe = []
        else:
            self.infGTVe = infGTVe
        self.infGTVe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeNormType135)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeNormType135.subclass:
            return infCTeNormType135.subclass(*args_, **kwargs_)
        else:
            return infCTeNormType135(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_infServico(self):
        return self.infServico
    def set_infServico(self, infServico):
        self.infServico = infServico
    def get_infDocRef(self):
        return self.infDocRef
    def set_infDocRef(self, infDocRef):
        self.infDocRef = infDocRef
    def add_infDocRef(self, value):
        self.infDocRef.append(value)
    def insert_infDocRef_at(self, index, value):
        self.infDocRef.insert(index, value)
    def replace_infDocRef_at(self, index, value):
        self.infDocRef[index] = value
    def get_seg(self):
        return self.seg
    def set_seg(self, seg):
        self.seg = seg
    def add_seg(self, value):
        self.seg.append(value)
    def insert_seg_at(self, index, value):
        self.seg.insert(index, value)
    def replace_seg_at(self, index, value):
        self.seg[index] = value
    def get_infModal(self):
        return self.infModal
    def set_infModal(self, infModal):
        self.infModal = infModal
    def get_infCteSub(self):
        return self.infCteSub
    def set_infCteSub(self, infCteSub):
        self.infCteSub = infCteSub
    def get_refCTeCanc(self):
        return self.refCTeCanc
    def set_refCTeCanc(self, refCTeCanc):
        self.refCTeCanc = refCTeCanc
    def get_cobr(self):
        return self.cobr
    def set_cobr(self, cobr):
        self.cobr = cobr
    def get_infGTVe(self):
        return self.infGTVe
    def set_infGTVe(self, infGTVe):
        self.infGTVe = infGTVe
    def add_infGTVe(self, value):
        self.infGTVe.append(value)
    def insert_infGTVe_at(self, index, value):
        self.infGTVe.insert(index, value)
    def replace_infGTVe_at(self, index, value):
        self.infGTVe[index] = value
    def validate_refCTeCancType(self, value):
        result = True
        # Validate type refCTeCancType, a restriction on TChNFe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on refCTeCancType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_refCTeCancType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_refCTeCancType_patterns_, ))
                result = False
        return result
    validate_refCTeCancType_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.infServico is not None or
            self.infDocRef or
            self.seg or
            self.infModal is not None or
            self.infCteSub is not None or
            self.refCTeCanc is not None or
            self.cobr is not None or
            self.infGTVe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeNormType135', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeNormType135')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCTeNormType135':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCTeNormType135')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCTeNormType135', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCTeNormType135'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeNormType135', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infServico is not None:
            namespaceprefix_ = self.infServico_nsprefix_ + ':' if (UseCapturedNS_ and self.infServico_nsprefix_) else ''
            self.infServico.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infServico', pretty_print=pretty_print)
        for infDocRef_ in self.infDocRef:
            namespaceprefix_ = self.infDocRef_nsprefix_ + ':' if (UseCapturedNS_ and self.infDocRef_nsprefix_) else ''
            infDocRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infDocRef', pretty_print=pretty_print)
        for seg_ in self.seg:
            namespaceprefix_ = self.seg_nsprefix_ + ':' if (UseCapturedNS_ and self.seg_nsprefix_) else ''
            seg_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='seg', pretty_print=pretty_print)
        if self.infModal is not None:
            namespaceprefix_ = self.infModal_nsprefix_ + ':' if (UseCapturedNS_ and self.infModal_nsprefix_) else ''
            self.infModal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infModal', pretty_print=pretty_print)
        if self.infCteSub is not None:
            namespaceprefix_ = self.infCteSub_nsprefix_ + ':' if (UseCapturedNS_ and self.infCteSub_nsprefix_) else ''
            self.infCteSub.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infCteSub', pretty_print=pretty_print)
        if self.refCTeCanc is not None:
            namespaceprefix_ = self.refCTeCanc_nsprefix_ + ':' if (UseCapturedNS_ and self.refCTeCanc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefCTeCanc>%s</%srefCTeCanc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refCTeCanc), input_name='refCTeCanc')), namespaceprefix_ , eol_))
        if self.cobr is not None:
            namespaceprefix_ = self.cobr_nsprefix_ + ':' if (UseCapturedNS_ and self.cobr_nsprefix_) else ''
            self.cobr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cobr', pretty_print=pretty_print)
        for infGTVe_ in self.infGTVe:
            namespaceprefix_ = self.infGTVe_nsprefix_ + ':' if (UseCapturedNS_ and self.infGTVe_nsprefix_) else ''
            infGTVe_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infGTVe', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'infServico':
            obj_ = infServicoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infServico = obj_
            obj_.original_tagname_ = 'infServico'
        elif nodeName_ == 'infDocRef':
            obj_ = infDocRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infDocRef.append(obj_)
            obj_.original_tagname_ = 'infDocRef'
        elif nodeName_ == 'seg':
            obj_ = segType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.seg.append(obj_)
            obj_.original_tagname_ = 'seg'
        elif nodeName_ == 'infModal':
            obj_ = infModalType139.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infModal = obj_
            obj_.original_tagname_ = 'infModal'
        elif nodeName_ == 'infCteSub':
            obj_ = infCteSubType141.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infCteSub = obj_
            obj_.original_tagname_ = 'infCteSub'
        elif nodeName_ == 'refCTeCanc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refCTeCanc')
            value_ = self.gds_validate_string(value_, node, 'refCTeCanc')
            self.refCTeCanc = value_
            self.refCTeCanc_nsprefix_ = child_.prefix
            # validate type refCTeCancType
            self.validate_refCTeCancType(self.refCTeCanc)
        elif nodeName_ == 'cobr':
            obj_ = cobrType147.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cobr = obj_
            obj_.original_tagname_ = 'cobr'
        elif nodeName_ == 'infGTVe':
            obj_ = infGTVeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infGTVe.append(obj_)
            obj_.original_tagname_ = 'infGTVe'
# end class infCTeNormType135


class infServicoType(GeneratedsSuper):
    """infServicoType -- Informa
    ç
    õ
    es da Presta
    ç
    ã
    o do Servi
    ç
    o
    xDescServ -- Descri
    ç
    ã
    o do Servi
    ç
    o prestado
    infQ -- Informa
    ç
    õ
    es de quantidades da Carga do CT-e
    Para Transporte de Pessoas indicar n
    ú
    mero de passageiros, para excesso de bagagem e transporte de valores indicar n
    ú
    mero de Volumes/Malotes
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, xDescServ=None, infQ=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.xDescServ = xDescServ
        self.validate_xDescServType(self.xDescServ)
        self.xDescServ_nsprefix_ = None
        self.infQ = infQ
        self.infQ_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infServicoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infServicoType.subclass:
            return infServicoType.subclass(*args_, **kwargs_)
        else:
            return infServicoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xDescServ(self):
        return self.xDescServ
    def set_xDescServ(self, xDescServ):
        self.xDescServ = xDescServ
    def get_infQ(self):
        return self.infQ
    def set_infQ(self, infQ):
        self.infQ = infQ
    def validate_xDescServType(self, value):
        result = True
        # Validate type xDescServType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xDescServType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xDescServType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xDescServType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xDescServType_patterns_, ))
                result = False
        return result
    validate_xDescServType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.xDescServ is not None or
            self.infQ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infServicoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infServicoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infServicoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infServicoType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infServicoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infServicoType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infServicoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xDescServ is not None:
            namespaceprefix_ = self.xDescServ_nsprefix_ + ':' if (UseCapturedNS_ and self.xDescServ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxDescServ>%s</%sxDescServ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xDescServ), input_name='xDescServ')), namespaceprefix_ , eol_))
        if self.infQ is not None:
            namespaceprefix_ = self.infQ_nsprefix_ + ':' if (UseCapturedNS_ and self.infQ_nsprefix_) else ''
            self.infQ.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infQ', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xDescServ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xDescServ')
            value_ = self.gds_validate_string(value_, node, 'xDescServ')
            self.xDescServ = value_
            self.xDescServ_nsprefix_ = child_.prefix
            # validate type xDescServType
            self.validate_xDescServType(self.xDescServ)
        elif nodeName_ == 'infQ':
            obj_ = infQType136.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.infQ = obj_
            obj_.original_tagname_ = 'infQ'
# end class infServicoType


class infQType136(GeneratedsSuper):
    """infQType136 -- Informa
    ç
    õ
    es de quantidades da Carga do CT-e
    Para Transporte de Pessoas indicar n
    ú
    mero de passageiros, para excesso de bagagem e transporte de valores indicar n
    ú
    mero de Volumes/Malotes
    qCarga -- Quantidade
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, qCarga=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.qCarga = qCarga
        self.validate_TDec_1104(self.qCarga)
        self.qCarga_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infQType136)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infQType136.subclass:
            return infQType136.subclass(*args_, **kwargs_)
        else:
            return infQType136(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qCarga(self):
        return self.qCarga
    def set_qCarga(self, qCarga):
        self.qCarga = qCarga
    def validate_TDec_1104(self, value):
        result = True
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1104_patterns_, ))
                result = False
        return result
    validate_TDec_1104_patterns_ = [['^(0|0\\.[0-9]{4}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?)$']]
    def _hasContent(self):
        if (
            self.qCarga is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infQType136', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infQType136')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infQType136':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infQType136')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infQType136', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infQType136'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infQType136', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qCarga is not None:
            namespaceprefix_ = self.qCarga_nsprefix_ + ':' if (UseCapturedNS_ and self.qCarga_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqCarga>%s</%sqCarga>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qCarga), input_name='qCarga')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'qCarga':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qCarga')
            value_ = self.gds_validate_string(value_, node, 'qCarga')
            self.qCarga = value_
            self.qCarga_nsprefix_ = child_.prefix
            # validate type TDec_1104
            self.validate_TDec_1104(self.qCarga)
# end class infQType136


class infDocRefType(GeneratedsSuper):
    """infDocRefType -- Informa
    ç
    õ
    es dos documentos referenciados
    nDoc -- N
    ú
    mero
    serie -- S
    é
    rie
    subserie -- Subs
    é
    rie
    dEmi -- Data de Emiss
    ã
    o
    Formato AAAA-MM-DD
    vDoc -- Valor Transportado
    chBPe -- Chave de acesso do BP-e que possui eventos excesso de bagagem
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nDoc=None, serie=None, subserie=None, dEmi=None, vDoc=None, chBPe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nDoc = nDoc
        self.validate_nDocType137(self.nDoc)
        self.nDoc_nsprefix_ = None
        self.serie = serie
        self.validate_serieType138(self.serie)
        self.serie_nsprefix_ = None
        self.subserie = subserie
        self.validate_subserieType(self.subserie)
        self.subserie_nsprefix_ = None
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.dEmi_nsprefix_ = None
        self.vDoc = vDoc
        self.validate_TDec_1302(self.vDoc)
        self.vDoc_nsprefix_ = None
        self.chBPe = chBPe
        self.validate_chBPeType(self.chBPe)
        self.chBPe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infDocRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infDocRefType.subclass:
            return infDocRefType.subclass(*args_, **kwargs_)
        else:
            return infDocRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nDoc(self):
        return self.nDoc
    def set_nDoc(self, nDoc):
        self.nDoc = nDoc
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_subserie(self):
        return self.subserie
    def set_subserie(self, subserie):
        self.subserie = subserie
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def get_vDoc(self):
        return self.vDoc
    def set_vDoc(self, vDoc):
        self.vDoc = vDoc
    def get_chBPe(self):
        return self.chBPe
    def set_chBPe(self, chBPe):
        self.chBPe = chBPe
    def validate_nDocType137(self, value):
        result = True
        # Validate type nDocType137, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nDocType137' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nDocType137' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nDocType137_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nDocType137_patterns_, ))
                result = False
        return result
    validate_nDocType137_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_serieType138(self, value):
        result = True
        # Validate type serieType138, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on serieType138' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on serieType138' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_serieType138_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_serieType138_patterns_, ))
                result = False
        return result
    validate_serieType138_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_subserieType(self, value):
        result = True
        # Validate type subserieType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on subserieType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on subserieType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_subserieType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_subserieType_patterns_, ))
                result = False
        return result
    validate_subserieType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_chBPeType(self, value):
        result = True
        # Validate type chBPeType, a restriction on TChNFe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on chBPeType' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_chBPeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_chBPeType_patterns_, ))
                result = False
        return result
    validate_chBPeType_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.nDoc is not None or
            self.serie is not None or
            self.subserie is not None or
            self.dEmi is not None or
            self.vDoc is not None or
            self.chBPe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infDocRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infDocRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infDocRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infDocRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infDocRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infDocRefType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infDocRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDoc is not None:
            namespaceprefix_ = self.nDoc_nsprefix_ + ':' if (UseCapturedNS_ and self.nDoc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDoc>%s</%snDoc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDoc), input_name='nDoc')), namespaceprefix_ , eol_))
        if self.serie is not None:
            namespaceprefix_ = self.serie_nsprefix_ + ':' if (UseCapturedNS_ and self.serie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.subserie is not None:
            namespaceprefix_ = self.subserie_nsprefix_ + ':' if (UseCapturedNS_ and self.subserie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubserie>%s</%ssubserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subserie), input_name='subserie')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            namespaceprefix_ = self.dEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
        if self.vDoc is not None:
            namespaceprefix_ = self.vDoc_nsprefix_ + ':' if (UseCapturedNS_ and self.vDoc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDoc>%s</%svDoc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDoc), input_name='vDoc')), namespaceprefix_ , eol_))
        if self.chBPe is not None:
            namespaceprefix_ = self.chBPe_nsprefix_ + ':' if (UseCapturedNS_ and self.chBPe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schBPe>%s</%schBPe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chBPe), input_name='chBPe')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nDoc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nDoc')
            value_ = self.gds_validate_string(value_, node, 'nDoc')
            self.nDoc = value_
            self.nDoc_nsprefix_ = child_.prefix
            # validate type nDocType137
            self.validate_nDocType137(self.nDoc)
        elif nodeName_ == 'serie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serie')
            value_ = self.gds_validate_string(value_, node, 'serie')
            self.serie = value_
            self.serie_nsprefix_ = child_.prefix
            # validate type serieType138
            self.validate_serieType138(self.serie)
        elif nodeName_ == 'subserie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subserie')
            value_ = self.gds_validate_string(value_, node, 'subserie')
            self.subserie = value_
            self.subserie_nsprefix_ = child_.prefix
            # validate type subserieType
            self.validate_subserieType(self.subserie)
        elif nodeName_ == 'dEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dEmi')
            value_ = self.gds_validate_string(value_, node, 'dEmi')
            self.dEmi = value_
            self.dEmi_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dEmi)
        elif nodeName_ == 'vDoc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vDoc')
            value_ = self.gds_validate_string(value_, node, 'vDoc')
            self.vDoc = value_
            self.vDoc_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDoc)
        elif nodeName_ == 'chBPe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chBPe')
            value_ = self.gds_validate_string(value_, node, 'chBPe')
            self.chBPe = value_
            self.chBPe_nsprefix_ = child_.prefix
            # validate type chBPeType
            self.validate_chBPeType(self.chBPe)
# end class infDocRefType


class segType(GeneratedsSuper):
    """segType -- Informa
    ç
    õ
    es de Seguro da Carga
    respSeg -- Respons
    á
    vel pelo seguro
    Preencher com:
    4 - Emitente do CT-e;
    5 - Tomador de Servi
    ç
    o.
      
    * xSeg -- Nome da Seguradora
    * nApol -- N
      ú
      mero da Ap
      ó
      lice
      Obrigat
      ó
      rio pela lei 11.442/07 (RCTRC)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, respSeg=None, xSeg=None, nApol=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.respSeg = respSeg
        self.validate_respSegType(self.respSeg)
        self.respSeg_nsprefix_ = None
        self.xSeg = xSeg
        self.validate_xSegType(self.xSeg)
        self.xSeg_nsprefix_ = None
        self.nApol = nApol
        self.validate_nApolType(self.nApol)
        self.nApol_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, segType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if segType.subclass:
            return segType.subclass(*args_, **kwargs_)
        else:
            return segType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_respSeg(self):
        return self.respSeg
    def set_respSeg(self, respSeg):
        self.respSeg = respSeg
    def get_xSeg(self):
        return self.xSeg
    def set_xSeg(self, xSeg):
        self.xSeg = xSeg
    def get_nApol(self):
        return self.nApol
    def set_nApol(self, nApol):
        self.nApol = nApol
    def validate_respSegType(self, value):
        result = True
        # Validate type respSegType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['4', '5']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on respSegType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) > 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on respSegType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on respSegType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_xSegType(self, value):
        result = True
        # Validate type xSegType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 30:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xSegType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xSegType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xSegType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xSegType_patterns_, ))
                result = False
        return result
    validate_xSegType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_nApolType(self, value):
        result = True
        # Validate type nApolType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nApolType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nApolType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nApolType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nApolType_patterns_, ))
                result = False
        return result
    validate_nApolType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.respSeg is not None or
            self.xSeg is not None or
            self.nApol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='segType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('segType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'segType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='segType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='segType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='segType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='segType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.respSeg is not None:
            namespaceprefix_ = self.respSeg_nsprefix_ + ':' if (UseCapturedNS_ and self.respSeg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srespSeg>%s</%srespSeg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.respSeg), input_name='respSeg')), namespaceprefix_ , eol_))
        if self.xSeg is not None:
            namespaceprefix_ = self.xSeg_nsprefix_ + ':' if (UseCapturedNS_ and self.xSeg_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxSeg>%s</%sxSeg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xSeg), input_name='xSeg')), namespaceprefix_ , eol_))
        if self.nApol is not None:
            namespaceprefix_ = self.nApol_nsprefix_ + ':' if (UseCapturedNS_ and self.nApol_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snApol>%s</%snApol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nApol), input_name='nApol')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'respSeg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'respSeg')
            value_ = self.gds_validate_string(value_, node, 'respSeg')
            self.respSeg = value_
            self.respSeg_nsprefix_ = child_.prefix
            # validate type respSegType
            self.validate_respSegType(self.respSeg)
        elif nodeName_ == 'xSeg':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xSeg')
            value_ = self.gds_validate_string(value_, node, 'xSeg')
            self.xSeg = value_
            self.xSeg_nsprefix_ = child_.prefix
            # validate type xSegType
            self.validate_xSegType(self.xSeg)
        elif nodeName_ == 'nApol':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nApol')
            value_ = self.gds_validate_string(value_, node, 'nApol')
            self.nApol = value_
            self.nApol_nsprefix_ = child_.prefix
            # validate type nApolType
            self.validate_nApolType(self.nApol)
# end class segType


class infModalType139(GeneratedsSuper):
    """infModalType139 -- Informa
    ç
    õ
    es do modal
    Obrigat
    ó
    rio para Pessoas e Bagagem
     -- XML do modal
    Insira neste local o XML espec
    í
    fico do modal
    O elemento do tipo -any- permite estender o documento XML com elementos n
    ã
    o especificados pelo schema.
    Insira neste local - any- o XML espec
    í
    fico do modal (rodovi
    á
    rio). A especifica
    ç
    ã
    o do schema XML para cada modal pode ser encontrada nos arquivos que acompanham este pacote de libera
    ç
    ã
    o:
    Rodovi
    á
    rio - ver arquivo CTeModalRodoviarioOS_v9.99
    Onde v9.99
    é
    a a designa
    ç
    ã
    o gen
    é
    rica para a vers
    ã
    o do arquivo. Por exemplo, o arquivo para o schema do modal Rodovi
    á
    rio na vers
    ã
    o 3.00 ser
    á
    denominado "CTeModalRodoviarioOS_v3.00".
    versaoModal -- Vers
    ã
    o do leiaute espec
    í
    fico para o Modal
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, versaoModal=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.versaoModal = _cast(None, versaoModal)
        self.versaoModal_nsprefix_ = None
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infModalType139)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infModalType139.subclass:
            return infModalType139.subclass(*args_, **kwargs_)
        else:
            return infModalType139(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_versaoModal(self):
        return self.versaoModal
    def set_versaoModal(self, versaoModal):
        self.versaoModal = versaoModal
    def validate_versaoModalType140(self, value):
        # Validate type versaoModalType140, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_versaoModalType140_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_versaoModalType140_patterns_, ))
    validate_versaoModalType140_patterns_ = [['^(3\\.(0[0-9]|[1-9][0-9]))$']]
    def _hasContent(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infModalType139', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infModalType139')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infModalType139':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infModalType139')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infModalType139', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infModalType139'):
        if self.versaoModal is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            outfile.write(' versaoModal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.versaoModal), input_name='versaoModal')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infModalType139', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            if self.anytypeobjs_ is not None:
                content_ = self.anytypeobjs_
                outfile.write(content_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versaoModal', node)
        if value is not None and 'versaoModal' not in already_processed:
            already_processed.add('versaoModal')
            self.versaoModal = value
            self.validate_versaoModalType140(self.versaoModal)    # validate type versaoModalType140
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'infModalType139')
        self.set_anytypeobjs_(content_)
# end class infModalType139


class infCteSubType141(GeneratedsSuper):
    """infCteSubType141 -- Informa
    ç
    õ
    es do CT-e de substitui
    ç
    ã
    o
    chCte -- Chave de acesso do CT-e a ser substitu
    í
    do (original)
    refCteAnu -- Chave de acesso do CT-e de Anula
    ç
    ã
    o
    tomaICMS -- Tomador
    é
    contribuinte do ICMS, mas n
    ã
    o
    é
    emitente de documento fiscal eletr
    ô
    nico
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCte=None, refCteAnu=None, tomaICMS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCte = chCte
        self.validate_chCteType142(self.chCte)
        self.chCte_nsprefix_ = None
        self.refCteAnu = refCteAnu
        self.validate_refCteAnuType143(self.refCteAnu)
        self.refCteAnu_nsprefix_ = None
        self.tomaICMS = tomaICMS
        self.tomaICMS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteSubType141)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteSubType141.subclass:
            return infCteSubType141.subclass(*args_, **kwargs_)
        else:
            return infCteSubType141(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCte(self):
        return self.chCte
    def set_chCte(self, chCte):
        self.chCte = chCte
    def get_refCteAnu(self):
        return self.refCteAnu
    def set_refCteAnu(self, refCteAnu):
        self.refCteAnu = refCteAnu
    def get_tomaICMS(self):
        return self.tomaICMS
    def set_tomaICMS(self, tomaICMS):
        self.tomaICMS = tomaICMS
    def validate_chCteType142(self, value):
        result = True
        # Validate type chCteType142, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_chCteType142_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_chCteType142_patterns_, ))
                result = False
        return result
    validate_chCteType142_patterns_ = [['^([0-9]{44})$']]
    def validate_refCteAnuType143(self, value):
        result = True
        # Validate type refCteAnuType143, a restriction on TChNFe.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on refCteAnuType143' % {"value": value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_refCteAnuType143_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_refCteAnuType143_patterns_, ))
                result = False
        return result
    validate_refCteAnuType143_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.chCte is not None or
            self.refCteAnu is not None or
            self.tomaICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteSubType141', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteSubType141')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteSubType141':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteSubType141')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteSubType141', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteSubType141'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteSubType141', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCte is not None:
            namespaceprefix_ = self.chCte_nsprefix_ + ':' if (UseCapturedNS_ and self.chCte_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCte>%s</%schCte>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCte), input_name='chCte')), namespaceprefix_ , eol_))
        if self.refCteAnu is not None:
            namespaceprefix_ = self.refCteAnu_nsprefix_ + ':' if (UseCapturedNS_ and self.refCteAnu_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefCteAnu>%s</%srefCteAnu>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refCteAnu), input_name='refCteAnu')), namespaceprefix_ , eol_))
        if self.tomaICMS is not None:
            namespaceprefix_ = self.tomaICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.tomaICMS_nsprefix_) else ''
            self.tomaICMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tomaICMS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCte':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCte')
            value_ = self.gds_validate_string(value_, node, 'chCte')
            self.chCte = value_
            self.chCte_nsprefix_ = child_.prefix
            # validate type chCteType142
            self.validate_chCteType142(self.chCte)
        elif nodeName_ == 'refCteAnu':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refCteAnu')
            value_ = self.gds_validate_string(value_, node, 'refCteAnu')
            self.refCteAnu = value_
            self.refCteAnu_nsprefix_ = child_.prefix
            # validate type refCteAnuType143
            self.validate_refCteAnuType143(self.refCteAnu)
        elif nodeName_ == 'tomaICMS':
            obj_ = tomaICMSType144.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tomaICMS = obj_
            obj_.original_tagname_ = 'tomaICMS'
# end class infCteSubType141


class tomaICMSType144(GeneratedsSuper):
    """tomaICMSType144 -- Tomador
    é
    contribuinte do ICMS, mas n
    ã
    o
    é
    emitente de documento fiscal eletr
    ô
    nico
    refNFe -- Chave de acesso da NF-e emitida pelo Tomador
    refNF -- Informa
    ç
    ã
    o da NF ou CT emitido pelo Tomador
    refCte -- Chave de acesso do CT-e emitido pelo Tomador
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refNFe=None, refNF=None, refCte=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refNFe = refNFe
        self.validate_TChNFe(self.refNFe)
        self.refNFe_nsprefix_ = None
        self.refNF = refNF
        self.refNF_nsprefix_ = None
        self.refCte = refCte
        self.validate_TChNFe(self.refCte)
        self.refCte_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tomaICMSType144)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tomaICMSType144.subclass:
            return tomaICMSType144.subclass(*args_, **kwargs_)
        else:
            return tomaICMSType144(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refNFe(self):
        return self.refNFe
    def set_refNFe(self, refNFe):
        self.refNFe = refNFe
    def get_refNF(self):
        return self.refNF
    def set_refNF(self, refNF):
        self.refNF = refNF
    def get_refCte(self):
        return self.refCte
    def set_refCte(self, refCte):
        self.refCte = refCte
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.refNFe is not None or
            self.refNF is not None or
            self.refCte is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaICMSType144', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tomaICMSType144')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tomaICMSType144':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tomaICMSType144')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tomaICMSType144', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tomaICMSType144'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='tomaICMSType144', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.refNFe is not None:
            namespaceprefix_ = self.refNFe_nsprefix_ + ':' if (UseCapturedNS_ and self.refNFe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefNFe>%s</%srefNFe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refNFe), input_name='refNFe')), namespaceprefix_ , eol_))
        if self.refNF is not None:
            namespaceprefix_ = self.refNF_nsprefix_ + ':' if (UseCapturedNS_ and self.refNF_nsprefix_) else ''
            self.refNF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='refNF', pretty_print=pretty_print)
        if self.refCte is not None:
            namespaceprefix_ = self.refCte_nsprefix_ + ':' if (UseCapturedNS_ and self.refCte_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefCte>%s</%srefCte>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refCte), input_name='refCte')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refNFe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refNFe')
            value_ = self.gds_validate_string(value_, node, 'refNFe')
            self.refNFe = value_
            self.refNFe_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.refNFe)
        elif nodeName_ == 'refNF':
            obj_ = refNFType145.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.refNF = obj_
            obj_.original_tagname_ = 'refNF'
        elif nodeName_ == 'refCte':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'refCte')
            value_ = self.gds_validate_string(value_, node, 'refCte')
            self.refCte = value_
            self.refCte_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.refCte)
# end class tomaICMSType144


class refNFType145(GeneratedsSuper):
    """refNFType145 -- Informa
    ç
    ã
    o da NF ou CT emitido pelo Tomador
    CNPJ -- CNPJ do Emitente
    Informar o CNPJ do emitente do Documento Fiscal
    CPF -- N
    ú
    mero do CPF
    Informar o CPF do emitente do documento fiscal
    mod -- Modelo do Documento Fiscal
    serie -- Serie do documento fiscal
    subserie -- Subserie do documento fiscal
    nro -- N
    ú
    mero do documento fiscal
    valor -- Valor do documento fiscal.
    dEmi -- Data de emiss
    ã
    o do documento fiscal.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, mod=None, serie=None, subserie=None, nro=None, valor=None, dEmi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
        self.mod = mod
        self.validate_TModDoc(self.mod)
        self.mod_nsprefix_ = None
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.serie_nsprefix_ = None
        self.subserie = subserie
        self.validate_TSerie(self.subserie)
        self.subserie_nsprefix_ = None
        self.nro = nro
        self.validate_nroType146(self.nro)
        self.nro_nsprefix_ = None
        self.valor = valor
        self.validate_TDec_1302(self.valor)
        self.valor_nsprefix_ = None
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.dEmi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNFType145)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNFType145.subclass:
            return refNFType145.subclass(*args_, **kwargs_)
        else:
            return refNFType145(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_subserie(self):
        return self.subserie
    def set_subserie(self, subserie):
        self.subserie = subserie
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_valor(self):
        return self.valor
    def set_valor(self, valor):
        self.valor = valor
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def validate_TModDoc(self, value):
        result = True
        # Validate type TModDoc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['01', '1B', '02', '2D', '2E', '04', '06', '07', '08', '8B', '09', '10', '11', '13', '14', '15', '16', '17', '18', '20', '21', '22', '23', '24', '25', '26', '27', '28', '55']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TModDoc' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TSerie(self, value):
        result = True
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TSerie_patterns_, ))
                result = False
        return result
    validate_TSerie_patterns_ = [['^(0|[1-9]{1}[0-9]{0,2})$']]
    def validate_nroType146(self, value):
        result = True
        # Validate type nroType146, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType146_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nroType146_patterns_, ))
                result = False
        return result
    validate_nroType146_patterns_ = [['^([0-9]{1,6})$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.mod is not None or
            self.serie is not None or
            self.subserie is not None or
            self.nro is not None or
            self.valor is not None or
            self.dEmi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='refNFType145', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNFType145')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'refNFType145':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='refNFType145')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='refNFType145', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='refNFType145'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='refNFType145', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.mod is not None:
            namespaceprefix_ = self.mod_nsprefix_ + ':' if (UseCapturedNS_ and self.mod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            namespaceprefix_ = self.serie_nsprefix_ + ':' if (UseCapturedNS_ and self.serie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.subserie is not None:
            namespaceprefix_ = self.subserie_nsprefix_ + ':' if (UseCapturedNS_ and self.subserie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubserie>%s</%ssubserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subserie), input_name='subserie')), namespaceprefix_ , eol_))
        if self.nro is not None:
            namespaceprefix_ = self.nro_nsprefix_ + ':' if (UseCapturedNS_ and self.nro_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.valor is not None:
            namespaceprefix_ = self.valor_nsprefix_ + ':' if (UseCapturedNS_ and self.valor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalor>%s</%svalor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.valor), input_name='valor')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            namespaceprefix_ = self.dEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'mod':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mod')
            value_ = self.gds_validate_string(value_, node, 'mod')
            self.mod = value_
            self.mod_nsprefix_ = child_.prefix
            # validate type TModDoc
            self.validate_TModDoc(self.mod)
        elif nodeName_ == 'serie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serie')
            value_ = self.gds_validate_string(value_, node, 'serie')
            self.serie = value_
            self.serie_nsprefix_ = child_.prefix
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'subserie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subserie')
            value_ = self.gds_validate_string(value_, node, 'subserie')
            self.subserie = value_
            self.subserie_nsprefix_ = child_.prefix
            # validate type TSerie
            self.validate_TSerie(self.subserie)
        elif nodeName_ == 'nro':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nro')
            value_ = self.gds_validate_string(value_, node, 'nro')
            self.nro = value_
            self.nro_nsprefix_ = child_.prefix
            # validate type nroType146
            self.validate_nroType146(self.nro)
        elif nodeName_ == 'valor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'valor')
            value_ = self.gds_validate_string(value_, node, 'valor')
            self.valor = value_
            self.valor_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.valor)
        elif nodeName_ == 'dEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dEmi')
            value_ = self.gds_validate_string(value_, node, 'dEmi')
            self.dEmi = value_
            self.dEmi_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dEmi)
# end class refNFType145


class cobrType147(GeneratedsSuper):
    """cobrType147 -- Dados da cobran
    ç
    a do CT-e
    fat -- Dados da fatura
    dup -- Dados das duplicatas
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fat=None, dup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fat = fat
        self.fat_nsprefix_ = None
        if dup is None:
            self.dup = []
        else:
            self.dup = dup
        self.dup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cobrType147)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cobrType147.subclass:
            return cobrType147.subclass(*args_, **kwargs_)
        else:
            return cobrType147(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fat(self):
        return self.fat
    def set_fat(self, fat):
        self.fat = fat
    def get_dup(self):
        return self.dup
    def set_dup(self, dup):
        self.dup = dup
    def add_dup(self, value):
        self.dup.append(value)
    def insert_dup_at(self, index, value):
        self.dup.insert(index, value)
    def replace_dup_at(self, index, value):
        self.dup[index] = value
    def _hasContent(self):
        if (
            self.fat is not None or
            self.dup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='cobrType147', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cobrType147')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cobrType147':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cobrType147')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cobrType147', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cobrType147'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='cobrType147', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fat is not None:
            namespaceprefix_ = self.fat_nsprefix_ + ':' if (UseCapturedNS_ and self.fat_nsprefix_) else ''
            self.fat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fat', pretty_print=pretty_print)
        for dup_ in self.dup:
            namespaceprefix_ = self.dup_nsprefix_ + ':' if (UseCapturedNS_ and self.dup_nsprefix_) else ''
            dup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fat':
            obj_ = fatType148.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fat = obj_
            obj_.original_tagname_ = 'fat'
        elif nodeName_ == 'dup':
            obj_ = dupType150.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dup.append(obj_)
            obj_.original_tagname_ = 'dup'
# end class cobrType147


class fatType148(GeneratedsSuper):
    """fatType148 -- Dados da fatura
    nFat -- N
    ú
    mero da fatura
    vOrig -- Valor original da fatura
    vDesc -- Valor do desconto da fatura
    vLiq -- Valor l
    í
    quido da fatura
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nFat=None, vOrig=None, vDesc=None, vLiq=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nFat = nFat
        self.validate_nFatType149(self.nFat)
        self.nFat_nsprefix_ = None
        self.vOrig = vOrig
        self.validate_TDec_1302Opc(self.vOrig)
        self.vOrig_nsprefix_ = None
        self.vDesc = vDesc
        self.validate_TDec_1302Opc(self.vDesc)
        self.vDesc_nsprefix_ = None
        self.vLiq = vLiq
        self.validate_TDec_1302Opc(self.vLiq)
        self.vLiq_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fatType148)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fatType148.subclass:
            return fatType148.subclass(*args_, **kwargs_)
        else:
            return fatType148(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nFat(self):
        return self.nFat
    def set_nFat(self, nFat):
        self.nFat = nFat
    def get_vOrig(self):
        return self.vOrig
    def set_vOrig(self, vOrig):
        self.vOrig = vOrig
    def get_vDesc(self):
        return self.vDesc
    def set_vDesc(self, vDesc):
        self.vDesc = vDesc
    def get_vLiq(self):
        return self.vLiq
    def set_vLiq(self, vLiq):
        self.vLiq = vLiq
    def validate_nFatType149(self, value):
        result = True
        # Validate type nFatType149, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nFatType149' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nFatType149' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nFatType149_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nFatType149_patterns_, ))
                result = False
        return result
    validate_nFatType149_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TDec_1302Opc(self, value):
        result = True
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_1302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.nFat is not None or
            self.vOrig is not None or
            self.vDesc is not None or
            self.vLiq is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fatType148', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fatType148')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fatType148':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fatType148')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fatType148', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fatType148'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='fatType148', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nFat is not None:
            namespaceprefix_ = self.nFat_nsprefix_ + ':' if (UseCapturedNS_ and self.nFat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snFat>%s</%snFat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nFat), input_name='nFat')), namespaceprefix_ , eol_))
        if self.vOrig is not None:
            namespaceprefix_ = self.vOrig_nsprefix_ + ':' if (UseCapturedNS_ and self.vOrig_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svOrig>%s</%svOrig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vOrig), input_name='vOrig')), namespaceprefix_ , eol_))
        if self.vDesc is not None:
            namespaceprefix_ = self.vDesc_nsprefix_ + ':' if (UseCapturedNS_ and self.vDesc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDesc>%s</%svDesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), namespaceprefix_ , eol_))
        if self.vLiq is not None:
            namespaceprefix_ = self.vLiq_nsprefix_ + ':' if (UseCapturedNS_ and self.vLiq_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svLiq>%s</%svLiq>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vLiq), input_name='vLiq')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nFat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nFat')
            value_ = self.gds_validate_string(value_, node, 'nFat')
            self.nFat = value_
            self.nFat_nsprefix_ = child_.prefix
            # validate type nFatType149
            self.validate_nFatType149(self.nFat)
        elif nodeName_ == 'vOrig':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vOrig')
            value_ = self.gds_validate_string(value_, node, 'vOrig')
            self.vOrig = value_
            self.vOrig_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOrig)
        elif nodeName_ == 'vDesc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vDesc')
            value_ = self.gds_validate_string(value_, node, 'vDesc')
            self.vDesc = value_
            self.vDesc_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDesc)
        elif nodeName_ == 'vLiq':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vLiq')
            value_ = self.gds_validate_string(value_, node, 'vLiq')
            self.vLiq = value_
            self.vLiq_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vLiq)
# end class fatType148


class dupType150(GeneratedsSuper):
    """dupType150 -- Dados das duplicatas
    nDup -- N
    ú
    mero da duplicata
    dVenc -- Data de vencimento da duplicata (AAAA-MM-DD)
    vDup -- Valor da duplicata
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nDup=None, dVenc=None, vDup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nDup = nDup
        self.validate_nDupType151(self.nDup)
        self.nDup_nsprefix_ = None
        self.dVenc = dVenc
        self.validate_TData(self.dVenc)
        self.dVenc_nsprefix_ = None
        self.vDup = vDup
        self.validate_TDec_1302Opc(self.vDup)
        self.vDup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dupType150)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dupType150.subclass:
            return dupType150.subclass(*args_, **kwargs_)
        else:
            return dupType150(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nDup(self):
        return self.nDup
    def set_nDup(self, nDup):
        self.nDup = nDup
    def get_dVenc(self):
        return self.dVenc
    def set_dVenc(self, dVenc):
        self.dVenc = dVenc
    def get_vDup(self):
        return self.vDup
    def set_vDup(self, vDup):
        self.vDup = vDup
    def validate_nDupType151(self, value):
        result = True
        # Validate type nDupType151, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 60:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nDupType151' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nDupType151' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nDupType151_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nDupType151_patterns_, ))
                result = False
        return result
    validate_nDupType151_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def validate_TDec_1302Opc(self, value):
        result = True
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_1302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.nDup is not None or
            self.dVenc is not None or
            self.vDup is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='dupType150', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dupType150')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dupType150':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dupType150')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dupType150', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dupType150'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='dupType150', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDup is not None:
            namespaceprefix_ = self.nDup_nsprefix_ + ':' if (UseCapturedNS_ and self.nDup_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDup>%s</%snDup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDup), input_name='nDup')), namespaceprefix_ , eol_))
        if self.dVenc is not None:
            namespaceprefix_ = self.dVenc_nsprefix_ + ':' if (UseCapturedNS_ and self.dVenc_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdVenc>%s</%sdVenc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dVenc), input_name='dVenc')), namespaceprefix_ , eol_))
        if self.vDup is not None:
            namespaceprefix_ = self.vDup_nsprefix_ + ':' if (UseCapturedNS_ and self.vDup_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDup>%s</%svDup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDup), input_name='vDup')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nDup':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nDup')
            value_ = self.gds_validate_string(value_, node, 'nDup')
            self.nDup = value_
            self.nDup_nsprefix_ = child_.prefix
            # validate type nDupType151
            self.validate_nDupType151(self.nDup)
        elif nodeName_ == 'dVenc':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dVenc')
            value_ = self.gds_validate_string(value_, node, 'dVenc')
            self.dVenc = value_
            self.dVenc_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dVenc)
        elif nodeName_ == 'vDup':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vDup')
            value_ = self.gds_validate_string(value_, node, 'vDup')
            self.vDup = value_
            self.vDup_nsprefix_ = child_.prefix
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDup)
# end class dupType150


class infGTVeType(GeneratedsSuper):
    """infGTVeType -- Informa
    ç
    õ
    es das GTV-e relacionadas ao CT-e OS
    chCTe -- Chave de acesso da GTV-e
    Comp -- Componentes do Valor da GTVe
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCTe=None, Comp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCTe = chCTe
        self.validate_chCTeType(self.chCTe)
        self.chCTe_nsprefix_ = None
        if Comp is None:
            self.Comp = []
        else:
            self.Comp = Comp
        self.Comp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infGTVeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infGTVeType.subclass:
            return infGTVeType.subclass(*args_, **kwargs_)
        else:
            return infGTVeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCTe(self):
        return self.chCTe
    def set_chCTe(self, chCTe):
        self.chCTe = chCTe
    def get_Comp(self):
        return self.Comp
    def set_Comp(self, Comp):
        self.Comp = Comp
    def add_Comp(self, value):
        self.Comp.append(value)
    def insert_Comp_at(self, index, value):
        self.Comp.insert(index, value)
    def replace_Comp_at(self, index, value):
        self.Comp[index] = value
    def validate_chCTeType(self, value):
        result = True
        # Validate type chCTeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_chCTeType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_chCTeType_patterns_, ))
                result = False
        return result
    validate_chCTeType_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.chCTe is not None or
            self.Comp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infGTVeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infGTVeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infGTVeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infGTVeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infGTVeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infGTVeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infGTVeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTe is not None:
            namespaceprefix_ = self.chCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.chCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespaceprefix_ , eol_))
        for Comp_ in self.Comp:
            namespaceprefix_ = self.Comp_nsprefix_ + ':' if (UseCapturedNS_ and self.Comp_nsprefix_) else ''
            Comp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCTe')
            value_ = self.gds_validate_string(value_, node, 'chCTe')
            self.chCTe = value_
            self.chCTe_nsprefix_ = child_.prefix
            # validate type chCTeType
            self.validate_chCTeType(self.chCTe)
        elif nodeName_ == 'Comp':
            obj_ = CompType152.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comp.append(obj_)
            obj_.original_tagname_ = 'Comp'
# end class infGTVeType


class CompType152(GeneratedsSuper):
    """CompType152 -- Componentes do Valor da GTVe
    tpComp -- Tipo do Componente
    1-Custodia
    2-Embarque
    3-Tempo de espera
    4-Malote
    5-Ad Valorem
    6-Outros
    vComp -- Valor do componente
    xComp -- Nome do componente (informar apenas para outros)
    Exemplos: FRETE PESO, FRETE VALOR, SEC/CAT, ADEME, AGENDAMENTO, etc
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tpComp=None, vComp=None, xComp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.tpComp = tpComp
        self.validate_tpCompType(self.tpComp)
        self.tpComp_nsprefix_ = None
        self.vComp = vComp
        self.validate_TDec_1302(self.vComp)
        self.vComp_nsprefix_ = None
        self.xComp = xComp
        self.validate_xCompType(self.xComp)
        self.xComp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompType152)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompType152.subclass:
            return CompType152.subclass(*args_, **kwargs_)
        else:
            return CompType152(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tpComp(self):
        return self.tpComp
    def set_tpComp(self, tpComp):
        self.tpComp = tpComp
    def get_vComp(self):
        return self.vComp
    def set_vComp(self, vComp):
        self.vComp = vComp
    def get_xComp(self):
        return self.xComp
    def set_xComp(self, xComp):
        self.xComp = xComp
    def validate_tpCompType(self, value):
        result = True
        # Validate type tpCompType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', '2', '3', '4', '5', '6']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on tpCompType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_xCompType(self, value):
        result = True
        # Validate type xCompType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 15:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on xCompType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on xCompType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_xCompType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_xCompType_patterns_, ))
                result = False
        return result
    validate_xCompType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.tpComp is not None or
            self.vComp is not None or
            self.xComp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='CompType152', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompType152')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CompType152':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompType152')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompType152', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompType152'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='CompType152', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpComp is not None:
            namespaceprefix_ = self.tpComp_nsprefix_ + ':' if (UseCapturedNS_ and self.tpComp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpComp>%s</%stpComp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpComp), input_name='tpComp')), namespaceprefix_ , eol_))
        if self.vComp is not None:
            namespaceprefix_ = self.vComp_nsprefix_ + ':' if (UseCapturedNS_ and self.vComp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svComp>%s</%svComp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vComp), input_name='vComp')), namespaceprefix_ , eol_))
        if self.xComp is not None:
            namespaceprefix_ = self.xComp_nsprefix_ + ':' if (UseCapturedNS_ and self.xComp_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxComp>%s</%sxComp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xComp), input_name='xComp')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tpComp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'tpComp')
            value_ = self.gds_validate_string(value_, node, 'tpComp')
            self.tpComp = value_
            self.tpComp_nsprefix_ = child_.prefix
            # validate type tpCompType
            self.validate_tpCompType(self.tpComp)
        elif nodeName_ == 'vComp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vComp')
            value_ = self.gds_validate_string(value_, node, 'vComp')
            self.vComp = value_
            self.vComp_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vComp)
        elif nodeName_ == 'xComp':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xComp')
            value_ = self.gds_validate_string(value_, node, 'xComp')
            self.xComp = value_
            self.xComp_nsprefix_ = child_.prefix
            # validate type xCompType
            self.validate_xCompType(self.xComp)
# end class CompType152


class infCteCompType153(GeneratedsSuper):
    """infCteCompType153 -- Detalhamento do CT-e complementado
    chCTe -- Chave do CT-e complementado
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCTe = chCTe
        self.validate_TChNFe(self.chCTe)
        self.chCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteCompType153)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteCompType153.subclass:
            return infCteCompType153.subclass(*args_, **kwargs_)
        else:
            return infCteCompType153(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCTe(self):
        return self.chCTe
    def set_chCTe(self, chCTe):
        self.chCTe = chCTe
    def validate_TChNFe(self, value):
        result = True
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 44:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on TChNFe' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TChNFe_patterns_, ))
                result = False
        return result
    validate_TChNFe_patterns_ = [['^([0-9]{44})$']]
    def _hasContent(self):
        if (
            self.chCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteCompType153', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteCompType153')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteCompType153':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteCompType153')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteCompType153', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteCompType153'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteCompType153', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCTe is not None:
            namespaceprefix_ = self.chCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.chCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCTe>%s</%schCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCTe), input_name='chCTe')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCTe')
            value_ = self.gds_validate_string(value_, node, 'chCTe')
            self.chCTe = value_
            self.chCTe_nsprefix_ = child_.prefix
            # validate type TChNFe
            self.validate_TChNFe(self.chCTe)
# end class infCteCompType153


class infCteAnuType154(GeneratedsSuper):
    """infCteAnuType154 -- Detalhamento do CT-e do tipo Anula
    ç
    ã
    o
    chCte -- Chave de acesso do CT-e original a ser anulado e substitu
    í
    do
    dEmi -- Data de emiss
    ã
    o da declara
    ç
    ã
    o do tomador n
    ã
    o contribuinte do ICMS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chCte=None, dEmi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chCte = chCte
        self.validate_chCteType155(self.chCte)
        self.chCte_nsprefix_ = None
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.dEmi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCteAnuType154)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCteAnuType154.subclass:
            return infCteAnuType154.subclass(*args_, **kwargs_)
        else:
            return infCteAnuType154(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chCte(self):
        return self.chCte
    def set_chCte(self, chCte):
        self.chCte = chCte
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def validate_chCteType155(self, value):
        result = True
        # Validate type chCteType155, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_chCteType155_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_chCteType155_patterns_, ))
                result = False
        return result
    validate_chCteType155_patterns_ = [['^([0-9]{44})$']]
    def validate_TData(self, value):
        result = True
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TData_patterns_, ))
                result = False
        return result
    validate_TData_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30))))))$']]
    def _hasContent(self):
        if (
            self.chCte is not None or
            self.dEmi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteAnuType154', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCteAnuType154')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCteAnuType154':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCteAnuType154')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCteAnuType154', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCteAnuType154'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCteAnuType154', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chCte is not None:
            namespaceprefix_ = self.chCte_nsprefix_ + ':' if (UseCapturedNS_ and self.chCte_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schCte>%s</%schCte>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chCte), input_name='chCte')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            namespaceprefix_ = self.dEmi_nsprefix_ + ':' if (UseCapturedNS_ and self.dEmi_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chCte':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'chCte')
            value_ = self.gds_validate_string(value_, node, 'chCte')
            self.chCte = value_
            self.chCte_nsprefix_ = child_.prefix
            # validate type chCteType155
            self.validate_chCteType155(self.chCte)
        elif nodeName_ == 'dEmi':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dEmi')
            value_ = self.gds_validate_string(value_, node, 'dEmi')
            self.dEmi = value_
            self.dEmi_nsprefix_ = child_.prefix
            # validate type TData
            self.validate_TData(self.dEmi)
# end class infCteAnuType154


class autXMLType156(GeneratedsSuper):
    """autXMLType156 -- Autorizados para download do XML do DF-e
    Informar CNPJ ou CPF. Preencher os zeros n
    ã
    o significativos.
    CNPJ -- CNPJ do autorizado
    Informar zeros n
    ã
    o significativos
    CPF -- CPF do autorizado
    Informar zeros n
    ã
    o significativos
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CNPJ_nsprefix_ = None
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.CPF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXMLType156)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXMLType156.subclass:
            return autXMLType156.subclass(*args_, **kwargs_)
        else:
            return autXMLType156(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def validate_TCnpj(self, value):
        result = True
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCnpj_patterns_, ))
                result = False
        return result
    validate_TCnpj_patterns_ = [['^([0-9]{14})$']]
    def validate_TCpf(self, value):
        result = True
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TCpf_patterns_, ))
                result = False
        return result
    validate_TCpf_patterns_ = [['^([0-9]{11})$']]
    def _hasContent(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='autXMLType156', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXMLType156')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'autXMLType156':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='autXMLType156')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='autXMLType156', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='autXMLType156'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='autXMLType156', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            namespaceprefix_ = self.CNPJ_nsprefix_ + ':' if (UseCapturedNS_ and self.CNPJ_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            namespaceprefix_ = self.CPF_nsprefix_ + ':' if (UseCapturedNS_ and self.CPF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CNPJ':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CNPJ')
            value_ = self.gds_validate_string(value_, node, 'CNPJ')
            self.CNPJ = value_
            self.CNPJ_nsprefix_ = child_.prefix
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CPF')
            value_ = self.gds_validate_string(value_, node, 'CPF')
            self.CPF = value_
            self.CPF_nsprefix_ = child_.prefix
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class autXMLType156


class infCTeSuplType159(GeneratedsSuper):
    """infCTeSuplType159 -- Informa
    ç
    õ
    es suplementares do CT-e
    qrCodCTe -- Texto com o QR-Code impresso no DACTE
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, qrCodCTe=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.qrCodCTe = qrCodCTe
        self.validate_qrCodCTeType160(self.qrCodCTe)
        self.qrCodCTe_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infCTeSuplType159)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infCTeSuplType159.subclass:
            return infCTeSuplType159.subclass(*args_, **kwargs_)
        else:
            return infCTeSuplType159(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qrCodCTe(self):
        return self.qrCodCTe
    def set_qrCodCTe(self, qrCodCTe):
        self.qrCodCTe = qrCodCTe
    def validate_qrCodCTeType160(self, value):
        result = True
        # Validate type qrCodCTeType160, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1000:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on qrCodCTeType160' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 50:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on qrCodCTeType160' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_qrCodCTeType160_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_qrCodCTeType160_patterns_, ))
                result = False
        return result
    validate_qrCodCTeType160_patterns_ = [['^(((HTTPS?|https?)://.*\\?chCTe=[0-9]{44}&tpAmb=[1-2](&sign=[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})?))$']]
    def _hasContent(self):
        if (
            self.qrCodCTe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeSuplType159', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infCTeSuplType159')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infCTeSuplType159':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infCTeSuplType159')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infCTeSuplType159', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infCTeSuplType159'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infCTeSuplType159', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qrCodCTe is not None:
            namespaceprefix_ = self.qrCodCTe_nsprefix_ + ':' if (UseCapturedNS_ and self.qrCodCTe_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqrCodCTe>%s</%sqrCodCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qrCodCTe), input_name='qrCodCTe')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'qrCodCTe':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qrCodCTe')
            value_ = self.gds_validate_string(value_, node, 'qrCodCTe')
            self.qrCodCTe = value_
            self.qrCodCTe_nsprefix_ = child_.prefix
            # validate type qrCodCTeType160
            self.validate_qrCodCTeType160(self.qrCodCTe)
# end class infCTeSuplType159


class infRecType(GeneratedsSuper):
    """infRecType -- Dados do Recibo do Lote
    nRec -- N
    ú
    mero do Recibo
    dhRecbto -- Data e hora do recebimento, no formato AAAA-MM-DDTHH:MM:SS TZD
    tMed -- Tempo m
    é
    dio de resposta do servi
    ç
    o (em segundos) dos
    ú
    ltimos 5 minutos
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nRec=None, dhRecbto=None, tMed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nRec = nRec
        self.validate_TRec(self.nRec)
        self.nRec_nsprefix_ = None
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.dhRecbto_nsprefix_ = None
        self.tMed = tMed
        self.validate_tMedType(self.tMed)
        self.tMed_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infRecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infRecType.subclass:
            return infRecType.subclass(*args_, **kwargs_)
        else:
            return infRecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nRec(self):
        return self.nRec
    def set_nRec(self, nRec):
        self.nRec = nRec
    def get_dhRecbto(self):
        return self.dhRecbto
    def set_dhRecbto(self, dhRecbto):
        self.dhRecbto = dhRecbto
    def get_tMed(self):
        return self.tMed
    def set_tMed(self, tMed):
        self.tMed = tMed
    def validate_TRec(self, value):
        result = True
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TRec_patterns_, ))
                result = False
        return result
    validate_TRec_patterns_ = [['^([0-9]{15})$']]
    def validate_TDateTimeUTC(self, value):
        result = True
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDateTimeUTC_patterns_, ))
                result = False
        return result
    validate_TDateTimeUTC_patterns_ = [['^((((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00)))$']]
    def validate_tMedType(self, value):
        result = True
        # Validate type tMedType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_tMedType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_tMedType_patterns_, ))
                result = False
        return result
    validate_tMedType_patterns_ = [['^([0-9]{1,4})$']]
    def _hasContent(self):
        if (
            self.nRec is not None or
            self.dhRecbto is not None or
            self.tMed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infRecType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infRecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'infRecType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infRecType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infRecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infRecType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='infRecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRec is not None:
            namespaceprefix_ = self.nRec_nsprefix_ + ':' if (UseCapturedNS_ and self.nRec_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRec>%s</%snRec>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), namespaceprefix_ , eol_))
        if self.dhRecbto is not None:
            namespaceprefix_ = self.dhRecbto_nsprefix_ + ':' if (UseCapturedNS_ and self.dhRecbto_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespaceprefix_ , eol_))
        if self.tMed is not None:
            namespaceprefix_ = self.tMed_nsprefix_ + ':' if (UseCapturedNS_ and self.tMed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stMed>%s</%stMed>%s' % (namespaceprefix_ , self.gds_format_integer(self.tMed, input_name='tMed'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nRec':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nRec')
            value_ = self.gds_validate_string(value_, node, 'nRec')
            self.nRec = value_
            self.nRec_nsprefix_ = child_.prefix
            # validate type TRec
            self.validate_TRec(self.nRec)
        elif nodeName_ == 'dhRecbto':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'dhRecbto')
            value_ = self.gds_validate_string(value_, node, 'dhRecbto')
            self.dhRecbto = value_
            self.dhRecbto_nsprefix_ = child_.prefix
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'tMed' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'tMed')
            ival_ = self.gds_validate_integer(ival_, node, 'tMed')
            self.tMed = ival_
            self.tMed_nsprefix_ = child_.prefix
            # validate type tMedType
            self.validate_tMedType(self.tMed)
# end class infRecType


class ICMS00Type(GeneratedsSuper):
    """ICMS00Type -- Presta
    ç
    ã
    o sujeito
    à
    tributa
    ç
    ã
    o normal do ICMS
    CST -- classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    00 - tributa
    ç
    ã
    o normal ICMS
    vBC -- Valor da BC do ICMS
    pICMS -- Al
    í
    quota do ICMS
    vICMS -- Valor do ICMS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pICMS=None, vICMS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType(self.CST)
        self.CST_nsprefix_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vBC_nsprefix_ = None
        self.pICMS = pICMS
        self.validate_TDec_0302(self.pICMS)
        self.pICMS_nsprefix_ = None
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS00Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS00Type.subclass:
            return ICMS00Type.subclass(*args_, **kwargs_)
        else:
            return ICMS00Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def validate_CSTType(self, value):
        result = True
        # Validate type CSTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['00']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS00Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS00Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS00Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS00Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS00Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS00Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS00Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            namespaceprefix_ = self.vBC_nsprefix_ + ':' if (UseCapturedNS_ and self.vBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            namespaceprefix_ = self.pICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            namespaceprefix_ = self.vICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType
            self.validate_CSTType(self.CST)
        elif nodeName_ == 'vBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBC')
            value_ = self.gds_validate_string(value_, node, 'vBC')
            self.vBC = value_
            self.vBC_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMS')
            value_ = self.gds_validate_string(value_, node, 'pICMS')
            self.pICMS = value_
            self.pICMS_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMS)
        elif nodeName_ == 'vICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMS')
            value_ = self.gds_validate_string(value_, node, 'vICMS')
            self.vICMS = value_
            self.vICMS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
# end class ICMS00Type


class ICMS20Type(GeneratedsSuper):
    """ICMS20Type -- Presta
    ç
    ã
    o sujeito
    à
    tributa
    ç
    ã
    o com redu
    ç
    ã
    o de BC do ICMS
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do servi
    ç
    o
    20 - tributa
    ç
    ã
    o com BC reduzida do ICMS
    pRedBC -- Percentual de redu
    ç
    ã
    o da BC
    vBC -- Valor da BC do ICMS
    pICMS -- Al
    í
    quota do ICMS
    vICMS -- Valor do ICMS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType190(self.CST)
        self.CST_nsprefix_ = None
        self.pRedBC = pRedBC
        self.validate_TDec_0302Opc(self.pRedBC)
        self.pRedBC_nsprefix_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vBC_nsprefix_ = None
        self.pICMS = pICMS
        self.validate_TDec_0302(self.pICMS)
        self.pICMS_nsprefix_ = None
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS20Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS20Type.subclass:
            return ICMS20Type.subclass(*args_, **kwargs_)
        else:
            return ICMS20Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def validate_CSTType190(self, value):
        result = True
        # Validate type CSTType190, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['20']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType190' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_0302Opc(self, value):
        result = True
        # Validate type TDec_0302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_0302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS20Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS20Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS20Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS20Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS20Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS20Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS20Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            namespaceprefix_ = self.pRedBC_nsprefix_ + ':' if (UseCapturedNS_ and self.pRedBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            namespaceprefix_ = self.vBC_nsprefix_ + ':' if (UseCapturedNS_ and self.vBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            namespaceprefix_ = self.pICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            namespaceprefix_ = self.vICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType190
            self.validate_CSTType190(self.CST)
        elif nodeName_ == 'pRedBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pRedBC')
            value_ = self.gds_validate_string(value_, node, 'pRedBC')
            self.pRedBC = value_
            self.pRedBC_nsprefix_ = child_.prefix
            # validate type TDec_0302Opc
            self.validate_TDec_0302Opc(self.pRedBC)
        elif nodeName_ == 'vBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBC')
            value_ = self.gds_validate_string(value_, node, 'vBC')
            self.vBC = value_
            self.vBC_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMS')
            value_ = self.gds_validate_string(value_, node, 'pICMS')
            self.pICMS = value_
            self.pICMS_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMS)
        elif nodeName_ == 'vICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMS')
            value_ = self.gds_validate_string(value_, node, 'vICMS')
            self.vICMS = value_
            self.vICMS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
# end class ICMS20Type


class ICMS45Type(GeneratedsSuper):
    """ICMS45Type -- ICMS  Isento, n
    ã
    o Tributado ou diferido
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    Preencher com:
    40 - ICMS isen
    ç
    ã
    o;
    41 - ICMS n
    ã
    o tributada;
    51 - ICMS diferido
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType191(self.CST)
        self.CST_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS45Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS45Type.subclass:
            return ICMS45Type.subclass(*args_, **kwargs_)
        else:
            return ICMS45Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def validate_CSTType191(self, value):
        result = True
        # Validate type CSTType191, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['40', '41', '51']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType191' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS45Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS45Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS45Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS45Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS45Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS45Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS45Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType191
            self.validate_CSTType191(self.CST)
# end class ICMS45Type


class ICMS60Type(GeneratedsSuper):
    """ICMS60Type -- Tributa
    ç
    ã
    o pelo ICMS60 - ICMS cobrado por substitui
    ç
    ã
    o tribut
    á
    ria.Responsabilidade do recolhimento do ICMS atribu
    í
    do ao tomador ou 3
    º
    por ST
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    60 - ICMS cobrado por substitui
    ç
    ã
    o tribut
    á
    ria
    vBCSTRet -- Valor da BC do ICMS ST retido
    Valor do frete sobre o qual ser
    á
    calculado o ICMS a ser substitu
    í
    do na Presta
    ç
    ã
    o.
    vICMSSTRet -- Valor do ICMS ST retido
    Resultado da multiplica
    ç
    ã
    o do
    “
    vBCSTRet
    ”
    x
    “
    pICMSSTRet
    ”
    –
    que ser
    á
    valor do ICMS a ser retido pelo Substituto. Podendo o valor do ICMS a ser retido efetivamente, sofrer ajustes conforme a op
    ç
    ã
    o tributaria do transportador substitu
    í
    do.
    pICMSSTRet -- Al
    í
    quota do ICMS
    Percentual de Al
    í
    quota incidente na presta
    ç
    ã
    o de servi
    ç
    o de transporte.
    vCred -- Valor do Cr
    é
    dito outorgado/Presumido
    Preencher somente quando o transportador substitu
    í
    do, for optante pelo cr
    é
    dito outorgado previsto no Conv
    ê
    nio 106/96 e corresponde ao percentual de 20% do valor do ICMS ST retido.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBCSTRet=None, vICMSSTRet=None, pICMSSTRet=None, vCred=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType192(self.CST)
        self.CST_nsprefix_ = None
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.vBCSTRet_nsprefix_ = None
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vICMSSTRet_nsprefix_ = None
        self.pICMSSTRet = pICMSSTRet
        self.validate_TDec_0302(self.pICMSSTRet)
        self.pICMSSTRet_nsprefix_ = None
        self.vCred = vCred
        self.validate_TDec_1302(self.vCred)
        self.vCred_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS60Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS60Type.subclass:
            return ICMS60Type.subclass(*args_, **kwargs_)
        else:
            return ICMS60Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBCSTRet(self):
        return self.vBCSTRet
    def set_vBCSTRet(self, vBCSTRet):
        self.vBCSTRet = vBCSTRet
    def get_vICMSSTRet(self):
        return self.vICMSSTRet
    def set_vICMSSTRet(self, vICMSSTRet):
        self.vICMSSTRet = vICMSSTRet
    def get_pICMSSTRet(self):
        return self.pICMSSTRet
    def set_pICMSSTRet(self, pICMSSTRet):
        self.pICMSSTRet = pICMSSTRet
    def get_vCred(self):
        return self.vCred
    def set_vCred(self, vCred):
        self.vCred = vCred
    def validate_CSTType192(self, value):
        result = True
        # Validate type CSTType192, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['60']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType192' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.vBCSTRet is not None or
            self.vICMSSTRet is not None or
            self.pICMSSTRet is not None or
            self.vCred is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS60Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS60Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS60Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS60Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS60Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS60Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS60Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBCSTRet is not None:
            namespaceprefix_ = self.vBCSTRet_nsprefix_ + ':' if (UseCapturedNS_ and self.vBCSTRet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCSTRet>%s</%svBCSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTRet), input_name='vBCSTRet')), namespaceprefix_ , eol_))
        if self.vICMSSTRet is not None:
            namespaceprefix_ = self.vICMSSTRet_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMSSTRet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSSTRet>%s</%svICMSSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTRet), input_name='vICMSSTRet')), namespaceprefix_ , eol_))
        if self.pICMSSTRet is not None:
            namespaceprefix_ = self.pICMSSTRet_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMSSTRet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSSTRet>%s</%spICMSSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSSTRet), input_name='pICMSSTRet')), namespaceprefix_ , eol_))
        if self.vCred is not None:
            namespaceprefix_ = self.vCred_nsprefix_ + ':' if (UseCapturedNS_ and self.vCred_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCred>%s</%svCred>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCred), input_name='vCred')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType192
            self.validate_CSTType192(self.CST)
        elif nodeName_ == 'vBCSTRet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBCSTRet')
            value_ = self.gds_validate_string(value_, node, 'vBCSTRet')
            self.vBCSTRet = value_
            self.vBCSTRet_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'vICMSSTRet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMSSTRet')
            value_ = self.gds_validate_string(value_, node, 'vICMSSTRet')
            self.vICMSSTRet = value_
            self.vICMSSTRet_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'pICMSSTRet':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMSSTRet')
            value_ = self.gds_validate_string(value_, node, 'pICMSSTRet')
            self.pICMSSTRet = value_
            self.pICMSSTRet_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMSSTRet)
        elif nodeName_ == 'vCred':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vCred')
            value_ = self.gds_validate_string(value_, node, 'vCred')
            self.vCred = value_
            self.vCred_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCred)
# end class ICMS60Type


class ICMS90Type(GeneratedsSuper):
    """ICMS90Type -- ICMS Outros
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS outros
    pRedBC -- Percentual de redu
    ç
    ã
    o da BC
    vBC -- Valor da BC do ICMS
    pICMS -- Al
    í
    quota do ICMS
    vICMS -- Valor do ICMS
    vCred -- Valor do Cr
    é
    dito Outorgado/Presumido
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, vCred=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType193(self.CST)
        self.CST_nsprefix_ = None
        self.pRedBC = pRedBC
        self.validate_TDec_0302Opc(self.pRedBC)
        self.pRedBC_nsprefix_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vBC_nsprefix_ = None
        self.pICMS = pICMS
        self.validate_TDec_0302(self.pICMS)
        self.pICMS_nsprefix_ = None
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMS_nsprefix_ = None
        self.vCred = vCred
        self.validate_TDec_1302(self.vCred)
        self.vCred_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS90Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS90Type.subclass:
            return ICMS90Type.subclass(*args_, **kwargs_)
        else:
            return ICMS90Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vCred(self):
        return self.vCred
    def set_vCred(self, vCred):
        self.vCred = vCred
    def validate_CSTType193(self, value):
        result = True
        # Validate type CSTType193, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['90']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType193' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_0302Opc(self, value):
        result = True
        # Validate type TDec_0302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_0302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vCred is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS90Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS90Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS90Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS90Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS90Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS90Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS90Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            namespaceprefix_ = self.pRedBC_nsprefix_ + ':' if (UseCapturedNS_ and self.pRedBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            namespaceprefix_ = self.vBC_nsprefix_ + ':' if (UseCapturedNS_ and self.vBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            namespaceprefix_ = self.pICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            namespaceprefix_ = self.vICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vCred is not None:
            namespaceprefix_ = self.vCred_nsprefix_ + ':' if (UseCapturedNS_ and self.vCred_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCred>%s</%svCred>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCred), input_name='vCred')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType193
            self.validate_CSTType193(self.CST)
        elif nodeName_ == 'pRedBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pRedBC')
            value_ = self.gds_validate_string(value_, node, 'pRedBC')
            self.pRedBC = value_
            self.pRedBC_nsprefix_ = child_.prefix
            # validate type TDec_0302Opc
            self.validate_TDec_0302Opc(self.pRedBC)
        elif nodeName_ == 'vBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBC')
            value_ = self.gds_validate_string(value_, node, 'vBC')
            self.vBC = value_
            self.vBC_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMS')
            value_ = self.gds_validate_string(value_, node, 'pICMS')
            self.pICMS = value_
            self.pICMS_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMS)
        elif nodeName_ == 'vICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMS')
            value_ = self.gds_validate_string(value_, node, 'vICMS')
            self.vICMS = value_
            self.vICMS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vCred':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vCred')
            value_ = self.gds_validate_string(value_, node, 'vCred')
            self.vCred = value_
            self.vCred_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCred)
# end class ICMS90Type


class ICMSOutraUFType(GeneratedsSuper):
    """ICMSOutraUFType -- ICMS devido
    à
    UF de origem da presta
    ç
    ã
    o, quando  diferente da UF do emitente
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS Outra UF
    pRedBCOutraUF -- Percentual de redu
    ç
    ã
    o da BC
    vBCOutraUF -- Valor da BC do ICMS
    pICMSOutraUF -- Al
    í
    quota do ICMS
    vICMSOutraUF -- Valor do ICMS devido outra UF
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBCOutraUF=None, vBCOutraUF=None, pICMSOutraUF=None, vICMSOutraUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType194(self.CST)
        self.CST_nsprefix_ = None
        self.pRedBCOutraUF = pRedBCOutraUF
        self.validate_TDec_0302Opc(self.pRedBCOutraUF)
        self.pRedBCOutraUF_nsprefix_ = None
        self.vBCOutraUF = vBCOutraUF
        self.validate_TDec_1302(self.vBCOutraUF)
        self.vBCOutraUF_nsprefix_ = None
        self.pICMSOutraUF = pICMSOutraUF
        self.validate_TDec_0302(self.pICMSOutraUF)
        self.pICMSOutraUF_nsprefix_ = None
        self.vICMSOutraUF = vICMSOutraUF
        self.validate_TDec_1302(self.vICMSOutraUF)
        self.vICMSOutraUF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSOutraUFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSOutraUFType.subclass:
            return ICMSOutraUFType.subclass(*args_, **kwargs_)
        else:
            return ICMSOutraUFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_pRedBCOutraUF(self):
        return self.pRedBCOutraUF
    def set_pRedBCOutraUF(self, pRedBCOutraUF):
        self.pRedBCOutraUF = pRedBCOutraUF
    def get_vBCOutraUF(self):
        return self.vBCOutraUF
    def set_vBCOutraUF(self, vBCOutraUF):
        self.vBCOutraUF = vBCOutraUF
    def get_pICMSOutraUF(self):
        return self.pICMSOutraUF
    def set_pICMSOutraUF(self, pICMSOutraUF):
        self.pICMSOutraUF = pICMSOutraUF
    def get_vICMSOutraUF(self):
        return self.vICMSOutraUF
    def set_vICMSOutraUF(self, vICMSOutraUF):
        self.vICMSOutraUF = vICMSOutraUF
    def validate_CSTType194(self, value):
        result = True
        # Validate type CSTType194, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['90']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType194' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_0302Opc(self, value):
        result = True
        # Validate type TDec_0302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_0302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.pRedBCOutraUF is not None or
            self.vBCOutraUF is not None or
            self.pICMSOutraUF is not None or
            self.vICMSOutraUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSOutraUFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSOutraUFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMSOutraUFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSOutraUFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSOutraUFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSOutraUFType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSOutraUFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.pRedBCOutraUF is not None:
            namespaceprefix_ = self.pRedBCOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.pRedBCOutraUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCOutraUF>%s</%spRedBCOutraUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCOutraUF), input_name='pRedBCOutraUF')), namespaceprefix_ , eol_))
        if self.vBCOutraUF is not None:
            namespaceprefix_ = self.vBCOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.vBCOutraUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCOutraUF>%s</%svBCOutraUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCOutraUF), input_name='vBCOutraUF')), namespaceprefix_ , eol_))
        if self.pICMSOutraUF is not None:
            namespaceprefix_ = self.pICMSOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMSOutraUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSOutraUF>%s</%spICMSOutraUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSOutraUF), input_name='pICMSOutraUF')), namespaceprefix_ , eol_))
        if self.vICMSOutraUF is not None:
            namespaceprefix_ = self.vICMSOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMSOutraUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSOutraUF>%s</%svICMSOutraUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSOutraUF), input_name='vICMSOutraUF')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType194
            self.validate_CSTType194(self.CST)
        elif nodeName_ == 'pRedBCOutraUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pRedBCOutraUF')
            value_ = self.gds_validate_string(value_, node, 'pRedBCOutraUF')
            self.pRedBCOutraUF = value_
            self.pRedBCOutraUF_nsprefix_ = child_.prefix
            # validate type TDec_0302Opc
            self.validate_TDec_0302Opc(self.pRedBCOutraUF)
        elif nodeName_ == 'vBCOutraUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBCOutraUF')
            value_ = self.gds_validate_string(value_, node, 'vBCOutraUF')
            self.vBCOutraUF = value_
            self.vBCOutraUF_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCOutraUF)
        elif nodeName_ == 'pICMSOutraUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMSOutraUF')
            value_ = self.gds_validate_string(value_, node, 'pICMSOutraUF')
            self.pICMSOutraUF = value_
            self.pICMSOutraUF_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMSOutraUF)
        elif nodeName_ == 'vICMSOutraUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMSOutraUF')
            value_ = self.gds_validate_string(value_, node, 'vICMSOutraUF')
            self.vICMSOutraUF = value_
            self.vICMSOutraUF_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSOutraUF)
# end class ICMSOutraUFType


class ICMSSNType(GeneratedsSuper):
    """ICMSSNType -- Simples Nacional
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS Simples Nacional
    indSN -- Indica se o contribuinte
    é
    Simples Nacional			1=Sim
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, indSN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType195(self.CST)
        self.CST_nsprefix_ = None
        self.indSN = indSN
        self.validate_indSNType(self.indSN)
        self.indSN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSNType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSNType.subclass:
            return ICMSSNType.subclass(*args_, **kwargs_)
        else:
            return ICMSSNType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_indSN(self):
        return self.indSN
    def set_indSN(self, indSN):
        self.indSN = indSN
    def validate_CSTType195(self, value):
        result = True
        # Validate type CSTType195, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['90']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType195' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_indSNType(self, value):
        result = True
        # Validate type indSNType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on indSNType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.CST is not None or
            self.indSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSSNType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSNType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMSSNType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSNType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSNType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSNType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSSNType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.indSN is not None:
            namespaceprefix_ = self.indSN_nsprefix_ + ':' if (UseCapturedNS_ and self.indSN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSN>%s</%sindSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indSN), input_name='indSN')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType195
            self.validate_CSTType195(self.CST)
        elif nodeName_ == 'indSN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indSN')
            value_ = self.gds_validate_string(value_, node, 'indSN')
            self.indSN = value_
            self.indSN_nsprefix_ = child_.prefix
            # validate type indSNType
            self.validate_indSNType(self.indSN)
# end class ICMSSNType


class ICMS00Type196(GeneratedsSuper):
    """ICMS00Type196 -- Presta
    ç
    ã
    o sujeito
    à
    tributa
    ç
    ã
    o normal do ICMS
    CST -- classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    00 - tributa
    ç
    ã
    o normal ICMS
    vBC -- Valor da BC do ICMS
    pICMS -- Al
    í
    quota do ICMS
    vICMS -- Valor do ICMS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pICMS=None, vICMS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType197(self.CST)
        self.CST_nsprefix_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vBC_nsprefix_ = None
        self.pICMS = pICMS
        self.validate_TDec_0302(self.pICMS)
        self.pICMS_nsprefix_ = None
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS00Type196)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS00Type196.subclass:
            return ICMS00Type196.subclass(*args_, **kwargs_)
        else:
            return ICMS00Type196(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def validate_CSTType197(self, value):
        result = True
        # Validate type CSTType197, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['00']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType197' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS00Type196', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS00Type196')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS00Type196':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS00Type196')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS00Type196', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS00Type196'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS00Type196', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            namespaceprefix_ = self.vBC_nsprefix_ + ':' if (UseCapturedNS_ and self.vBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            namespaceprefix_ = self.pICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            namespaceprefix_ = self.vICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType197
            self.validate_CSTType197(self.CST)
        elif nodeName_ == 'vBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBC')
            value_ = self.gds_validate_string(value_, node, 'vBC')
            self.vBC = value_
            self.vBC_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMS')
            value_ = self.gds_validate_string(value_, node, 'pICMS')
            self.pICMS = value_
            self.pICMS_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMS)
        elif nodeName_ == 'vICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMS')
            value_ = self.gds_validate_string(value_, node, 'vICMS')
            self.vICMS = value_
            self.vICMS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
# end class ICMS00Type196


class ICMS20Type198(GeneratedsSuper):
    """ICMS20Type198 -- Presta
    ç
    ã
    o sujeito
    à
    tributa
    ç
    ã
    o com redu
    ç
    ã
    o de BC do ICMS
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do servi
    ç
    o
    20 - tributa
    ç
    ã
    o com BC reduzida do ICMS
    pRedBC -- Percentual de redu
    ç
    ã
    o da BC
    vBC -- Valor da BC do ICMS
    pICMS -- Al
    í
    quota do ICMS
    vICMS -- Valor do ICMS
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType199(self.CST)
        self.CST_nsprefix_ = None
        self.pRedBC = pRedBC
        self.validate_TDec_0302Opc(self.pRedBC)
        self.pRedBC_nsprefix_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vBC_nsprefix_ = None
        self.pICMS = pICMS
        self.validate_TDec_0302(self.pICMS)
        self.pICMS_nsprefix_ = None
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS20Type198)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS20Type198.subclass:
            return ICMS20Type198.subclass(*args_, **kwargs_)
        else:
            return ICMS20Type198(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def validate_CSTType199(self, value):
        result = True
        # Validate type CSTType199, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['20']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType199' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_0302Opc(self, value):
        result = True
        # Validate type TDec_0302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_0302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS20Type198', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS20Type198')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS20Type198':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS20Type198')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS20Type198', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS20Type198'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS20Type198', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            namespaceprefix_ = self.pRedBC_nsprefix_ + ':' if (UseCapturedNS_ and self.pRedBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            namespaceprefix_ = self.vBC_nsprefix_ + ':' if (UseCapturedNS_ and self.vBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            namespaceprefix_ = self.pICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            namespaceprefix_ = self.vICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType199
            self.validate_CSTType199(self.CST)
        elif nodeName_ == 'pRedBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pRedBC')
            value_ = self.gds_validate_string(value_, node, 'pRedBC')
            self.pRedBC = value_
            self.pRedBC_nsprefix_ = child_.prefix
            # validate type TDec_0302Opc
            self.validate_TDec_0302Opc(self.pRedBC)
        elif nodeName_ == 'vBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBC')
            value_ = self.gds_validate_string(value_, node, 'vBC')
            self.vBC = value_
            self.vBC_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMS')
            value_ = self.gds_validate_string(value_, node, 'pICMS')
            self.pICMS = value_
            self.pICMS_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMS)
        elif nodeName_ == 'vICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMS')
            value_ = self.gds_validate_string(value_, node, 'vICMS')
            self.vICMS = value_
            self.vICMS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
# end class ICMS20Type198


class ICMS45Type200(GeneratedsSuper):
    """ICMS45Type200 -- ICMS  Isento, n
    ã
    o Tributado ou diferido
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    Preencher com:
    40 - ICMS isen
    ç
    ã
    o;
    41 - ICMS n
    ã
    o tributada;
    51 - ICMS diferido
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType201(self.CST)
        self.CST_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS45Type200)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS45Type200.subclass:
            return ICMS45Type200.subclass(*args_, **kwargs_)
        else:
            return ICMS45Type200(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def validate_CSTType201(self, value):
        result = True
        # Validate type CSTType201, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['40', '41', '51']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType201' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS45Type200', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS45Type200')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS45Type200':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS45Type200')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS45Type200', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS45Type200'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS45Type200', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType201
            self.validate_CSTType201(self.CST)
# end class ICMS45Type200


class ICMS90Type202(GeneratedsSuper):
    """ICMS90Type202 -- ICMS Outros
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - Outros
    pRedBC -- Percentual de redu
    ç
    ã
    o da BC
    vBC -- Valor da BC do ICMS
    pICMS -- Al
    í
    quota do ICMS
    vICMS -- Valor do ICMS
    vCred -- Valor do Cr
    é
    dito Outorgado/Presumido
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, vCred=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType203(self.CST)
        self.CST_nsprefix_ = None
        self.pRedBC = pRedBC
        self.validate_TDec_0302Opc(self.pRedBC)
        self.pRedBC_nsprefix_ = None
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vBC_nsprefix_ = None
        self.pICMS = pICMS
        self.validate_TDec_0302(self.pICMS)
        self.pICMS_nsprefix_ = None
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMS_nsprefix_ = None
        self.vCred = vCred
        self.validate_TDec_1302(self.vCred)
        self.vCred_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS90Type202)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS90Type202.subclass:
            return ICMS90Type202.subclass(*args_, **kwargs_)
        else:
            return ICMS90Type202(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vCred(self):
        return self.vCred
    def set_vCred(self, vCred):
        self.vCred = vCred
    def validate_CSTType203(self, value):
        result = True
        # Validate type CSTType203, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['90']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType203' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_0302Opc(self, value):
        result = True
        # Validate type TDec_0302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_0302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vCred is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS90Type202', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS90Type202')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMS90Type202':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS90Type202')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS90Type202', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS90Type202'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMS90Type202', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            namespaceprefix_ = self.pRedBC_nsprefix_ + ':' if (UseCapturedNS_ and self.pRedBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            namespaceprefix_ = self.vBC_nsprefix_ + ':' if (UseCapturedNS_ and self.vBC_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            namespaceprefix_ = self.pICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            namespaceprefix_ = self.vICMS_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vCred is not None:
            namespaceprefix_ = self.vCred_nsprefix_ + ':' if (UseCapturedNS_ and self.vCred_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCred>%s</%svCred>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCred), input_name='vCred')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType203
            self.validate_CSTType203(self.CST)
        elif nodeName_ == 'pRedBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pRedBC')
            value_ = self.gds_validate_string(value_, node, 'pRedBC')
            self.pRedBC = value_
            self.pRedBC_nsprefix_ = child_.prefix
            # validate type TDec_0302Opc
            self.validate_TDec_0302Opc(self.pRedBC)
        elif nodeName_ == 'vBC':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBC')
            value_ = self.gds_validate_string(value_, node, 'vBC')
            self.vBC = value_
            self.vBC_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMS')
            value_ = self.gds_validate_string(value_, node, 'pICMS')
            self.pICMS = value_
            self.pICMS_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMS)
        elif nodeName_ == 'vICMS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMS')
            value_ = self.gds_validate_string(value_, node, 'vICMS')
            self.vICMS = value_
            self.vICMS_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vCred':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vCred')
            value_ = self.gds_validate_string(value_, node, 'vCred')
            self.vCred = value_
            self.vCred_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCred)
# end class ICMS90Type202


class ICMSOutraUFType204(GeneratedsSuper):
    """ICMSOutraUFType204 -- ICMS devido
    à
    UF de origem da presta
    ç
    ã
    o, quando  diferente da UF do emitente
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS Outra UF
    pRedBCOutraUF -- Percentual de redu
    ç
    ã
    o da BC
    vBCOutraUF -- Valor da BC do ICMS
    pICMSOutraUF -- Al
    í
    quota do ICMS
    vICMSOutraUF -- Valor do ICMS devido outra UF
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, pRedBCOutraUF=None, vBCOutraUF=None, pICMSOutraUF=None, vICMSOutraUF=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType205(self.CST)
        self.CST_nsprefix_ = None
        self.pRedBCOutraUF = pRedBCOutraUF
        self.validate_TDec_0302Opc(self.pRedBCOutraUF)
        self.pRedBCOutraUF_nsprefix_ = None
        self.vBCOutraUF = vBCOutraUF
        self.validate_TDec_1302(self.vBCOutraUF)
        self.vBCOutraUF_nsprefix_ = None
        self.pICMSOutraUF = pICMSOutraUF
        self.validate_TDec_0302(self.pICMSOutraUF)
        self.pICMSOutraUF_nsprefix_ = None
        self.vICMSOutraUF = vICMSOutraUF
        self.validate_TDec_1302(self.vICMSOutraUF)
        self.vICMSOutraUF_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSOutraUFType204)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSOutraUFType204.subclass:
            return ICMSOutraUFType204.subclass(*args_, **kwargs_)
        else:
            return ICMSOutraUFType204(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_pRedBCOutraUF(self):
        return self.pRedBCOutraUF
    def set_pRedBCOutraUF(self, pRedBCOutraUF):
        self.pRedBCOutraUF = pRedBCOutraUF
    def get_vBCOutraUF(self):
        return self.vBCOutraUF
    def set_vBCOutraUF(self, vBCOutraUF):
        self.vBCOutraUF = vBCOutraUF
    def get_pICMSOutraUF(self):
        return self.pICMSOutraUF
    def set_pICMSOutraUF(self, pICMSOutraUF):
        self.pICMSOutraUF = pICMSOutraUF
    def get_vICMSOutraUF(self):
        return self.vICMSOutraUF
    def set_vICMSOutraUF(self, vICMSOutraUF):
        self.vICMSOutraUF = vICMSOutraUF
    def validate_CSTType205(self, value):
        result = True
        # Validate type CSTType205, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['90']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType205' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_TDec_0302Opc(self, value):
        result = True
        # Validate type TDec_0302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Opc_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302Opc_patterns_, ))
                result = False
        return result
    validate_TDec_0302Opc_patterns_ = [['^(0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def validate_TDec_1302(self, value):
        result = True
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_1302_patterns_, ))
                result = False
        return result
    validate_TDec_1302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)$']]
    def validate_TDec_0302(self, value):
        result = True
        # Validate type TDec_0302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_TDec_0302_patterns_, ))
                result = False
        return result
    validate_TDec_0302_patterns_ = [['^(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2})?)$']]
    def _hasContent(self):
        if (
            self.CST is not None or
            self.pRedBCOutraUF is not None or
            self.vBCOutraUF is not None or
            self.pICMSOutraUF is not None or
            self.vICMSOutraUF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSOutraUFType204', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSOutraUFType204')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMSOutraUFType204':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSOutraUFType204')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSOutraUFType204', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSOutraUFType204'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSOutraUFType204', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.pRedBCOutraUF is not None:
            namespaceprefix_ = self.pRedBCOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.pRedBCOutraUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCOutraUF>%s</%spRedBCOutraUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCOutraUF), input_name='pRedBCOutraUF')), namespaceprefix_ , eol_))
        if self.vBCOutraUF is not None:
            namespaceprefix_ = self.vBCOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.vBCOutraUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCOutraUF>%s</%svBCOutraUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCOutraUF), input_name='vBCOutraUF')), namespaceprefix_ , eol_))
        if self.pICMSOutraUF is not None:
            namespaceprefix_ = self.pICMSOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.pICMSOutraUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSOutraUF>%s</%spICMSOutraUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSOutraUF), input_name='pICMSOutraUF')), namespaceprefix_ , eol_))
        if self.vICMSOutraUF is not None:
            namespaceprefix_ = self.vICMSOutraUF_nsprefix_ + ':' if (UseCapturedNS_ and self.vICMSOutraUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSOutraUF>%s</%svICMSOutraUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSOutraUF), input_name='vICMSOutraUF')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType205
            self.validate_CSTType205(self.CST)
        elif nodeName_ == 'pRedBCOutraUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pRedBCOutraUF')
            value_ = self.gds_validate_string(value_, node, 'pRedBCOutraUF')
            self.pRedBCOutraUF = value_
            self.pRedBCOutraUF_nsprefix_ = child_.prefix
            # validate type TDec_0302Opc
            self.validate_TDec_0302Opc(self.pRedBCOutraUF)
        elif nodeName_ == 'vBCOutraUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vBCOutraUF')
            value_ = self.gds_validate_string(value_, node, 'vBCOutraUF')
            self.vBCOutraUF = value_
            self.vBCOutraUF_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCOutraUF)
        elif nodeName_ == 'pICMSOutraUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pICMSOutraUF')
            value_ = self.gds_validate_string(value_, node, 'pICMSOutraUF')
            self.pICMSOutraUF = value_
            self.pICMSOutraUF_nsprefix_ = child_.prefix
            # validate type TDec_0302
            self.validate_TDec_0302(self.pICMSOutraUF)
        elif nodeName_ == 'vICMSOutraUF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vICMSOutraUF')
            value_ = self.gds_validate_string(value_, node, 'vICMSOutraUF')
            self.vICMSOutraUF = value_
            self.vICMSOutraUF_nsprefix_ = child_.prefix
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSOutraUF)
# end class ICMSOutraUFType204


class ICMSSNType206(GeneratedsSuper):
    """ICMSSNType206 -- Simples Nacional
    CST -- Classifica
    ç
    ã
    o Tribut
    á
    ria do Servi
    ç
    o
    90 - ICMS Simples Nacional
    indSN -- Indica se o contribuinte
    é
    Simples Nacional			1=Sim
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CST=None, indSN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.CST = CST
        self.validate_CSTType207(self.CST)
        self.CST_nsprefix_ = None
        self.indSN = indSN
        self.validate_indSNType208(self.indSN)
        self.indSN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSNType206)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSNType206.subclass:
            return ICMSSNType206.subclass(*args_, **kwargs_)
        else:
            return ICMSSNType206(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_indSN(self):
        return self.indSN
    def set_indSN(self, indSN):
        self.indSN = indSN
    def validate_CSTType207(self, value):
        result = True
        # Validate type CSTType207, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['90']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CSTType207' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_indSNType208(self, value):
        result = True
        # Validate type indSNType208, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on indSNType208' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.CST is not None or
            self.indSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSSNType206', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSNType206')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ICMSSNType206':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSNType206')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSNType206', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSNType206'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='ICMSSNType206', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            namespaceprefix_ = self.CST_nsprefix_ + ':' if (UseCapturedNS_ and self.CST_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.indSN is not None:
            namespaceprefix_ = self.indSN_nsprefix_ + ':' if (UseCapturedNS_ and self.indSN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSN>%s</%sindSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indSN), input_name='indSN')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CST':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CST')
            value_ = self.gds_validate_string(value_, node, 'CST')
            self.CST = value_
            self.CST_nsprefix_ = child_.prefix
            # validate type CSTType207
            self.validate_CSTType207(self.CST)
        elif nodeName_ == 'indSN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indSN')
            value_ = self.gds_validate_string(value_, node, 'indSN')
            self.indSN = value_
            self.indSN_nsprefix_ = child_.prefix
            # validate type indSNType208
            self.validate_indSNType208(self.indSN)
# end class ICMSSNType206


class lacUnidTranspType(GeneratedsSuper):
    """lacUnidTranspType -- Lacres das Unidades de Transporte
    nLacre -- N
    ú
    mero do lacre
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nLacre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nLacre = nLacre
        self.validate_nLacreType(self.nLacre)
        self.nLacre_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacUnidTranspType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacUnidTranspType.subclass:
            return lacUnidTranspType.subclass(*args_, **kwargs_)
        else:
            return lacUnidTranspType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nLacre(self):
        return self.nLacre
    def set_nLacre(self, nLacre):
        self.nLacre = nLacre
    def validate_nLacreType(self, value):
        result = True
        # Validate type nLacreType, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nLacreType' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nLacreType' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nLacreType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nLacreType_patterns_, ))
                result = False
        return result
    validate_nLacreType_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='lacUnidTranspType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacUnidTranspType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lacUnidTranspType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lacUnidTranspType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lacUnidTranspType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lacUnidTranspType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='lacUnidTranspType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            namespaceprefix_ = self.nLacre_nsprefix_ + ':' if (UseCapturedNS_ and self.nLacre_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snLacre>%s</%snLacre>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nLacre), input_name='nLacre')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nLacre':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nLacre')
            value_ = self.gds_validate_string(value_, node, 'nLacre')
            self.nLacre = value_
            self.nLacre_nsprefix_ = child_.prefix
            # validate type nLacreType
            self.validate_nLacreType(self.nLacre)
# end class lacUnidTranspType


class lacUnidCargaType(GeneratedsSuper):
    """lacUnidCargaType -- Lacres das Unidades de Carga
    nLacre -- N
    ú
    mero do lacre
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, nLacre=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.nLacre = nLacre
        self.validate_nLacreType209(self.nLacre)
        self.nLacre_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacUnidCargaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacUnidCargaType.subclass:
            return lacUnidCargaType.subclass(*args_, **kwargs_)
        else:
            return lacUnidCargaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_nLacre(self):
        return self.nLacre
    def set_nLacre(self, nLacre):
        self.nLacre = nLacre
    def validate_nLacreType209(self, value):
        result = True
        # Validate type nLacreType209, a restriction on TString.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on nLacreType209' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on nLacreType209' % {"value" : value, "lineno": lineno} )
                result = False
            if not self.gds_validate_simple_patterns(
                    self.validate_nLacreType209_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_nLacreType209_patterns_, ))
                result = False
        return result
    validate_nLacreType209_patterns_ = [['^([!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}|[!-ÿ]{1})$']]
    def _hasContent(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='lacUnidCargaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacUnidCargaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'lacUnidCargaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lacUnidCargaType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lacUnidCargaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lacUnidCargaType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://www.w3.org/2001/XMLSchema" ', name_='lacUnidCargaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            namespaceprefix_ = self.nLacre_nsprefix_ + ':' if (UseCapturedNS_ and self.nLacre_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snLacre>%s</%snLacre>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nLacre), input_name='nLacre')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'nLacre':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'nLacre')
            value_ = self.gds_validate_string(value_, node, 'nLacre')
            self.nLacre = value_
            self.nLacre_nsprefix_ = child_.prefix
            # validate type nLacreType209
            self.validate_nLacreType209(self.nLacre)
# end class lacUnidCargaType


class CanonicalizationMethodType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm='http://www.w3.org/TR/2001/REC-xml-c14n-20010315', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CanonicalizationMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CanonicalizationMethodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CanonicalizationMethodType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CanonicalizationMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CanonicalizationMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm='http://www.w3.org/2000/09/xmldsig#rsa-sha1', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SignatureMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignatureMethodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureMethodType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignatureMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SignatureMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SignatureMethodType


class DigestMethodType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Algorithm='http://www.w3.org/2000/09/xmldsig#sha1', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Algorithm = _cast(None, Algorithm)
        self.Algorithm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DigestMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DigestMethodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DigestMethodType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DigestMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DigestMethodType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DigestMethodType


GDSClassesMapping = {
    'CTe': TCTe,
    'Signature': SignatureType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TCTe'
        rootClass = TCTe
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TCTe'
        rootClass = TCTe
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TCTe'
        rootClass = TCTe
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TCTe'
        rootClass = TCTe
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from ctelib import *\n\n')
        sys.stdout.write('import ctelib as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://www.portalfiscal.inf.br/cte': [('TDateTimeUTC',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TAmb',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('Tano',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TCodUfIBGE',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TCodMunIBGE',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TCOrgaoIBGE',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TChNFe',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TCnpj',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TFone',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TCnpjVar',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TCnpjOpc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TCpf',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TCpfVar',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TData',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0302',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0303',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0302_0303',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0302Opc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0803',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0803Opc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0804',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0804Opc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_0906Opc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_1104',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_1104Opc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_1203',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_1203Opc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_1204',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_1204Opc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_1302',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TDec_1302Opc',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TIe',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TIeDest',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TJust',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TMed',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TModCTOS',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TModGTVe',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TModCT_Carga_OS',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TModCT',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TModNF',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TtipoUnidTransp',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TtipoUnidCarga',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TMotivo',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TNF',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TProt',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TRec',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TSerie',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TServ',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TStat',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TString',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TUf',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TUF_sem_EX',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TVerAplic',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TLatitude',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TLongitude',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TIPv4',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TPlaca',
                                         './schemas/v300/tiposGeralCTe_v3.00.xsd',
                                         'ST'),
                                        ('TModTranspGTVe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TFinGTVe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TCfop',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TCListServ',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TContainer',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TDocAssoc',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TEmail',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TFinCTe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TFinCTeOS',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TIdLote',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TModDoc',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TModTranspOS',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TModTransp',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TRNTRC',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TCIOT',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TCRT',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TProcEmi',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TTime',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TVerCTe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'ST'),
                                        ('TGTVe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TProtCTe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TProtCTeOS',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TProtGTVe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TRetCTe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TRetGTVe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TRetCTeOS',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TCTe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TCTeOS',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TEnviCTe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TRetEnviCTe',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TEndeEmi',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TEndereco',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TEndernac',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TEndOrg',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TLocal',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TEndReEnt',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TImp',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TImpOS',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TUnidadeTransp',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TUnidCarga',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT'),
                                        ('TRespTec',
                                         './schemas/v300/cteTiposBasico_v3.00.xsd',
                                         'CT')],
 'http://www.w3.org/2000/09/xmldsig#': [('DigestValueType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'ST'),
                                        ('TTransformURI',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'ST'),
                                        ('SignatureType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'CT'),
                                        ('SignatureValueType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'CT'),
                                        ('SignedInfoType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'CT'),
                                        ('ReferenceType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'CT'),
                                        ('TransformsType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'CT'),
                                        ('TransformType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'CT'),
                                        ('KeyInfoType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'CT'),
                                        ('X509DataType',
                                         './schemas/v300/xmldsig-core-schema_v1.01.xsd',
                                         'CT')]}

__all__ = [
    "CanonicalizationMethodType",
    "CompType",
    "CompType130",
    "CompType152",
    "DigestMethodType",
    "EntregaType",
    "ICMS00Type",
    "ICMS00Type196",
    "ICMS20Type",
    "ICMS20Type198",
    "ICMS45Type",
    "ICMS45Type200",
    "ICMS60Type",
    "ICMS90Type",
    "ICMS90Type202",
    "ICMSOutraUFType",
    "ICMSOutraUFType204",
    "ICMSSNType",
    "ICMSSNType206",
    "ICMSUFFimType",
    "ICMSUFFimType134",
    "KeyInfoType",
    "ObsContType",
    "ObsContType113",
    "ObsContType53",
    "ObsFiscoType",
    "ObsFiscoType116",
    "ObsFiscoType56",
    "ReferenceType",
    "SignatureMethodType",
    "SignatureType",
    "SignatureValueType",
    "SignedInfoType",
    "TCTe",
    "TCTeOS",
    "TEndOrg",
    "TEndReEnt",
    "TEndeEmi",
    "TEndereco",
    "TEndernac",
    "TEnviCTe",
    "TGTVe",
    "TImp",
    "TImpOS",
    "TLocal",
    "TProtCTe",
    "TProtCTeOS",
    "TProtGTVe",
    "TRespTec",
    "TRetCTe",
    "TRetCTeOS",
    "TRetEnviCTe",
    "TRetGTVe",
    "TUnidCarga",
    "TUnidadeTransp",
    "TransformType",
    "TransformsType",
    "X509DataType",
    "autXMLType",
    "autXMLType156",
    "autXMLType87",
    "cobrType",
    "cobrType147",
    "comDataType",
    "comHoraType",
    "complType",
    "complType108",
    "complType44",
    "destType",
    "destType73",
    "detGTVType",
    "docAntType",
    "dupType",
    "dupType150",
    "emiDocAntType",
    "emitType",
    "emitType119",
    "emitType59",
    "expedType",
    "fatType",
    "fatType148",
    "fluxoType",
    "idDocAntEleType",
    "idDocAntPapType",
    "idDocAntType",
    "ideType",
    "ideType26",
    "ideType93",
    "impType",
    "impType132",
    "infCTeMultimodalType",
    "infCTeNormType",
    "infCTeNormType135",
    "infCTeSuplType",
    "infCTeSuplType159",
    "infCTeSuplType90",
    "infCargaType",
    "infCteAnuType",
    "infCteAnuType154",
    "infCteCompType",
    "infCteCompType153",
    "infCteSubType",
    "infCteSubType141",
    "infCteType",
    "infCteType25",
    "infCteType92",
    "infDocRefType",
    "infDocType",
    "infEspecieType",
    "infFiscoType",
    "infFiscoType17",
    "infFiscoType22",
    "infGTVeType",
    "infGlobalizadoType",
    "infModalType",
    "infModalType139",
    "infNFType",
    "infNFeType",
    "infOutrosType",
    "infPercursoType",
    "infProtType",
    "infProtType15",
    "infProtType20",
    "infQType",
    "infQType136",
    "infRecType",
    "infServVincType",
    "infServicoType",
    "infSolicNFFType",
    "infTribFedType",
    "infVeiculoType",
    "lacUnidCargaType",
    "lacUnidTranspType",
    "noInterType",
    "noPeriodoType",
    "passType",
    "recebType",
    "refNFType",
    "refNFType145",
    "remType",
    "remType64",
    "segType",
    "semDataType",
    "semHoraType",
    "toma3Type",
    "toma4Type",
    "tomaICMSType",
    "tomaICMSType144",
    "tomaTerceiroType",
    "tomaType",
    "tomaType124",
    "vPrestType",
    "vPrestType129",
    "veicNovosType"
]
